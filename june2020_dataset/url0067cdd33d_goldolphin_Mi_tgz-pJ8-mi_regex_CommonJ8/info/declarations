Compiled from "Bitmap.java"
public class mi.common.Bitmap {
  public mi.common.Bitmap(int);
  public boolean get(int);
  public void set(int, boolean);
  public static void main(java.lang.String[]);
}
Compiled from "CharHashMap.java"
public class mi.common.CharHashMap<T> implements java.lang.Iterable<mi.common.CharHashMap$Entry<T>> {
  public mi.common.CharHashMap(int, double);
  public mi.common.CharHashMap(int);
  public mi.common.CharHashMap();
  public boolean contains(char);
  public T get(char);
  public void put(char, T);
  public void remove(char);
  public void clear();
  public int size();
  public java.util.Iterator<mi.common.CharHashMap$Entry<T>> iterator();
  public static void main(java.lang.String[]);
  static mi.common.CharHashMap$Entry[] access$500(mi.common.CharHashMap);
}
Compiled from "CharHashMap.java"
class mi.common.CharHashMap$1 {
}
Compiled from "CharHashMap.java"
public class mi.common.CharHashMap$Entry<T> {
  public char getKey();
  public T getValue();
  static java.lang.Object access$000(mi.common.CharHashMap$Entry);
  static java.lang.Object access$002(mi.common.CharHashMap$Entry, java.lang.Object);
  mi.common.CharHashMap$Entry(char, java.lang.Object, mi.common.CharHashMap$1);
  static mi.common.CharHashMap$Entry access$200(mi.common.CharHashMap$Entry);
  static char access$300(mi.common.CharHashMap$Entry);
  static mi.common.CharHashMap$Entry access$202(mi.common.CharHashMap$Entry, mi.common.CharHashMap$Entry);
}
Compiled from "CharHashMap.java"
class mi.common.CharHashMap$Iterator implements java.util.Iterator<mi.common.CharHashMap$Entry<T>> {
  final mi.common.CharHashMap this$0;
  public boolean hasNext();
  public mi.common.CharHashMap$Entry<T> next();
  public void remove();
  public java.lang.Object next();
  mi.common.CharHashMap$Iterator(mi.common.CharHashMap, mi.common.CharHashMap$1);
}
Compiled from "CharType.java"
public final class mi.common.CharType extends java.lang.Enum<mi.common.CharType> {
  public static final mi.common.CharType DIGIT;
  public static final mi.common.CharType UPPERCASE;
  public static final mi.common.CharType LOWERCASE;
  public static final mi.common.CharType OTHER;
  public static mi.common.CharType[] values();
  public static mi.common.CharType valueOf(java.lang.String);
  public static mi.common.CharType getType(char);
  public static boolean isDigit(char);
  public static boolean isUpperCase(char);
  public static boolean isLowerCase(char);
  public static boolean isLetter(char);
  public static boolean isIdHead(char);
  public static boolean isIdTail(char);
  public static boolean isOperatorPart(char);
  public static boolean isNewLineChar(char);
  public static boolean isSpaceChar(char);
  public static boolean isBlankChar(char);
  public static void main(java.lang.String[]);
  static {};
}
Compiled from "CharacterSet.java"
public class mi.common.CharacterSet {
  public mi.common.CharacterSet();
  public mi.common.CharacterSet(int);
  public void add(char);
  public void remove(char);
  public boolean contains(char);
}
Compiled from "IntStack.java"
public class mi.common.IntStack {
  public mi.common.IntStack(int);
  public int pop();
  public int peek();
  public void push(int);
}
Compiled from "Utils.java"
public final class mi.common.Utils {
  public mi.common.Utils();
  public static void performance(java.lang.Runnable);
  public static void verify(boolean);
}
Compiled from "Application.java"
public class mi.lang.ast.Application {
  public mi.lang.ast.Application();
}
Compiled from "Context.java"
public class mi.lang.ast.Context {
  public mi.lang.ast.Context();
}
Compiled from "Function.java"
public class mi.lang.ast.Function {
  public mi.lang.ast.Function();
}
Compiled from "Type.java"
public class mi.lang.ast.Type {
  public static final mi.lang.ast.Type Byte;
  public static final mi.lang.ast.Type Integer;
  public static final mi.lang.ast.Type Float;
  public static final mi.lang.ast.Type Double;
  public static final mi.lang.ast.Type Char;
  public mi.lang.ast.Type(mi.lang.ast.Type, mi.lang.ast.Type);
  static {};
}
Compiled from "Value.java"
public class mi.lang.ast.Value {
  public mi.lang.ast.Value();
}
Compiled from "Variable.java"
public class mi.lang.ast.Variable {
  public mi.lang.ast.Variable();
}
Compiled from "ISymbol.java"
public interface mi.lang.parser.ISymbol {
}
Compiled from "LexPattern.java"
public class mi.lang.parser.LexPattern {
  public mi.lang.parser.LexPattern();
  public boolean match(mi.legacy.parser.character.IParseStream, mi.legacy.parser.pattern.IHandler<mi.lang.parser.ISymbol>);
}
Compiled from "Lexer.java"
public class mi.lang.parser.Lexer {
  public mi.lang.parser.Lexer();
  public static void skipLineComment(mi.legacy.parser.character.IParseStream);
  public static void skipSpace(mi.legacy.parser.character.IParseStream);
  public static boolean matchInteger(mi.legacy.parser.character.IParseStream, java.lang.StringBuilder);
}
Compiled from "Parser.java"
public class mi.lang.parser.Parser {
  public mi.lang.parser.Parser();
}
Compiled from "Symbols.java"
public class mi.lang.parser.Symbols {
  public mi.lang.parser.Symbols();
}
Compiled from "Symbols.java"
public class mi.lang.parser.Symbols$Id implements mi.lang.parser.ISymbol {
  public final java.lang.String name;
  public mi.lang.parser.Symbols$Id(java.lang.String);
}
Compiled from "Grammar.java"
public abstract class mi.legacy.parser.Grammar {
  public mi.legacy.parser.Grammar();
  protected mi.legacy.parser.Grammar$Nonterm N(java.lang.String);
  protected mi.legacy.parser.Grammar$Term T(java.lang.String);
  protected void addProduction(mi.legacy.parser.Grammar$Nonterm, mi.legacy.parser.Grammar$ISymbol...);
  public java.util.ArrayList<mi.legacy.parser.Grammar$Production> getProductions();
  public mi.legacy.parser.Grammar$Nonterm getTopHead();
  protected abstract mi.legacy.parser.Grammar$Nonterm define();
}
Compiled from "Grammar.java"
public interface mi.legacy.parser.Grammar$ISymbol {
  public abstract java.lang.String name();
}
Compiled from "Grammar.java"
public class mi.legacy.parser.Grammar$Nonterm implements mi.legacy.parser.Grammar$ISymbol {
  public mi.legacy.parser.Grammar$Nonterm(java.lang.String);
  public java.lang.String name();
}
Compiled from "Grammar.java"
public class mi.legacy.parser.Grammar$Production {
  public final mi.legacy.parser.Grammar$Nonterm head;
  public final mi.legacy.parser.Grammar$ISymbol[] body;
  public mi.legacy.parser.Grammar$Production(mi.legacy.parser.Grammar$Nonterm, mi.legacy.parser.Grammar$ISymbol[]);
}
Compiled from "Grammar.java"
public class mi.legacy.parser.Grammar$Term implements mi.legacy.parser.Grammar$ISymbol {
  public mi.legacy.parser.Grammar$Term(java.lang.String);
  public java.lang.String name();
}
Compiled from "GraphStack.java"
public class mi.legacy.parser.GraphStack<T> {
  public mi.legacy.parser.GraphStack<T> push(T);
  public mi.legacy.parser.GraphStack<T> pop();
  public T getData();
  public static <T> mi.legacy.parser.GraphStack<T> newBottom(T);
}
Compiled from "Nonterm.java"
public class mi.legacy.parser.Nonterm {
  public static final int ANY;
  public static final mi.legacy.parser.Transition$NontermTransition NULL_LEFTMOST_TRANSITION;
  public final int id;
  public final java.lang.String name;
  public mi.legacy.parser.Nonterm(int, java.lang.String);
  public mi.legacy.parser.Transition$NontermTransition getLeftMostTransition();
  public mi.legacy.parser.State addLeftMostRule(int, mi.legacy.parser.State$StateGenerator);
  public java.lang.String toString();
  static {};
}
Compiled from "ParseException.java"
public class mi.legacy.parser.ParseException extends java.lang.RuntimeException {
  public mi.legacy.parser.ParseException(java.lang.String);
  public mi.legacy.parser.ParseException(java.lang.String, java.lang.Throwable);
}
Compiled from "Parser.java"
public class mi.legacy.parser.Parser {
  mi.legacy.parser.Parser(mi.legacy.parser.Nonterm[], mi.legacy.parser.State, int, boolean);
  public boolean parse(mi.stream.ICharStream);
}
Compiled from "Parser.java"
class mi.legacy.parser.Parser$1 {
}
Compiled from "Parser.java"
class mi.legacy.parser.Parser$SubParsers {
  public void add(mi.legacy.parser.State, mi.legacy.parser.GraphStack<mi.legacy.parser.Transition$NontermTransition>);
  public mi.legacy.parser.State getState(int);
  public mi.legacy.parser.GraphStack<mi.legacy.parser.Transition$NontermTransition> getStack(int);
  public int size();
  public void clear();
  mi.legacy.parser.Parser$SubParsers(mi.legacy.parser.Parser$1);
}
Compiled from "ParserBuilder.java"
public class mi.legacy.parser.ParserBuilder {
  public mi.legacy.parser.ParserBuilder();
  public mi.legacy.parser.Parser build(mi.legacy.parser.Grammar, boolean);
}
Compiled from "ParserBuilder.java"
class mi.legacy.parser.ParserBuilder$1 {
}
Compiled from "ParserBuilder.java"
class mi.legacy.parser.ParserBuilder$NontermGraph {
  mi.legacy.parser.ParserBuilder$NontermGraph(int[], mi.legacy.parser.ParserBuilder$1);
  static int[] access$200(mi.legacy.parser.ParserBuilder$NontermGraph);
}
Compiled from "ParserBuilder.java"
class mi.legacy.parser.ParserBuilder$NontermTable {
  public mi.legacy.parser.Nonterm get(java.lang.String);
  public java.util.Collection<mi.legacy.parser.Nonterm> getAll();
  public int size();
  mi.legacy.parser.ParserBuilder$NontermTable(mi.legacy.parser.ParserBuilder$1);
}
Compiled from "ParserTest.java"
public class mi.legacy.parser.ParserTest {
  public mi.legacy.parser.ParserTest();
  public void testParse1() throws java.lang.Exception;
  public void testParse2() throws java.lang.Exception;
  public void testParse3() throws java.lang.Exception;
  public void testParse4() throws java.lang.Exception;
}
Compiled from "ParserTest.java"
class mi.legacy.parser.ParserTest$1 extends mi.legacy.parser.Grammar {
  final mi.legacy.parser.ParserTest this$0;
  mi.legacy.parser.ParserTest$1(mi.legacy.parser.ParserTest);
  protected mi.legacy.parser.Grammar$Nonterm define();
}
Compiled from "ParserTest.java"
class mi.legacy.parser.ParserTest$2 extends mi.legacy.parser.Grammar {
  final mi.legacy.parser.ParserTest this$0;
  mi.legacy.parser.ParserTest$2(mi.legacy.parser.ParserTest);
  protected mi.legacy.parser.Grammar$Nonterm define();
}
Compiled from "ParserTest.java"
class mi.legacy.parser.ParserTest$3 extends mi.legacy.parser.Grammar {
  final mi.legacy.parser.ParserTest this$0;
  mi.legacy.parser.ParserTest$3(mi.legacy.parser.ParserTest);
  protected mi.legacy.parser.Grammar$Nonterm define();
}
Compiled from "ParserTest.java"
class mi.legacy.parser.ParserTest$4 extends mi.legacy.parser.Grammar {
  final mi.legacy.parser.ParserTest this$0;
  mi.legacy.parser.ParserTest$4(mi.legacy.parser.ParserTest);
  protected mi.legacy.parser.Grammar$Nonterm define();
}
Compiled from "State.java"
public class mi.legacy.parser.State {
  public final int id;
  public void setAcceptedNonterm(int);
  public boolean hasAcceptedNonterm();
  public int getAcceptedNontermId();
  public boolean canConsume();
  public mi.legacy.parser.State getTermTransition(char, int);
  public mi.legacy.parser.State addTermTransition(char, int, mi.legacy.parser.State$StateGenerator);
  public mi.legacy.parser.State addTermTransition(java.lang.String, int, mi.legacy.parser.State$StateGenerator);
  public mi.legacy.parser.State addNontermTransition(int, int, mi.legacy.parser.State$StateGenerator);
  mi.common.CharHashMap<mi.legacy.parser.Transition$TermTransition> getTermTransitions();
  java.util.Collection<mi.legacy.parser.Transition$NontermTransition> getNontermTransitions();
  public java.lang.String toString();
  mi.legacy.parser.State(int, mi.legacy.parser.State$1);
}
Compiled from "State.java"
class mi.legacy.parser.State$1 {
}
Compiled from "State.java"
public class mi.legacy.parser.State$StateGenerator {
  public mi.legacy.parser.State$StateGenerator();
  public mi.legacy.parser.State generate();
  public java.util.ArrayList<mi.legacy.parser.State> getAll();
}
Compiled from "Transition.java"
public abstract class mi.legacy.parser.Transition {
  public final mi.legacy.parser.State target;
  mi.legacy.parser.Transition(mi.legacy.parser.State);
  public void addHeadNonterm(int);
  public boolean containsHeadNonterm(int);
  public java.util.HashSet<java.lang.Integer> getHeadNontermIds();
  public java.lang.String toString();
}
Compiled from "Transition.java"
public class mi.legacy.parser.Transition$CustomizedTransition extends mi.legacy.parser.Transition {
  public mi.legacy.parser.Transition$CustomizedTransition(mi.legacy.parser.Transition$ToAccept, mi.legacy.parser.State);
  public java.lang.String toString();
}
Compiled from "Transition.java"
public class mi.legacy.parser.Transition$NontermTransition extends mi.legacy.parser.Transition {
  public final int nontermId;
  public mi.legacy.parser.Transition$NontermTransition(int, mi.legacy.parser.State);
  public java.lang.String toString();
}
Compiled from "Transition.java"
public class mi.legacy.parser.Transition$TermTransition extends mi.legacy.parser.Transition {
  public final char term;
  public mi.legacy.parser.Transition$TermTransition(char, mi.legacy.parser.State);
  public java.lang.String toString();
}
Compiled from "Transition.java"
public interface mi.legacy.parser.Transition$ToAccept {
  public abstract boolean accept(char);
}
Compiled from "CharPattern.java"
public class mi.legacy.parser.character.CharPattern {
  public mi.legacy.parser.character.CharPattern();
}
Compiled from "ICombiner.java"
public interface mi.legacy.parser.character.ICombiner {
  public abstract mi.legacy.parser.character.ISymbol combine(mi.legacy.parser.character.ISymbol, mi.legacy.parser.character.ISymbol);
}
Compiled from "IParseStream.java"
public interface mi.legacy.parser.character.IParseStream extends mi.stream.ICharStream {
  public abstract void retractTo(int);
  public abstract int tell();
}
Compiled from "IPattern.java"
public interface mi.legacy.parser.character.IPattern {
  public abstract mi.legacy.parser.character.ISymbol match(mi.legacy.parser.character.IParseStream);
}
Compiled from "ISymbol.java"
public interface mi.legacy.parser.character.ISymbol {
  public static final mi.legacy.parser.character.ISymbol EMPTY;
  static {};
}
Compiled from "ISymbol.java"
final class mi.legacy.parser.character.ISymbol$1 implements mi.legacy.parser.character.ISymbol {
  mi.legacy.parser.character.ISymbol$1();
}
Compiled from "LRParseStream.java"
class mi.legacy.parser.character.LRParseStream implements mi.legacy.parser.character.IParseStream {
  public mi.legacy.parser.character.LRParseStream(mi.legacy.parser.character.IParseStream);
  public char peek();
  public char poll();
  public void retract();
  public void retractTo(int);
  public int tell();
  public void lock();
  public void yield();
  static {};
}
Compiled from "LRParseStream.java"
final class mi.legacy.parser.character.LRParseStream$1 implements mi.legacy.parser.character.IParseStream {
  mi.legacy.parser.character.LRParseStream$1();
  public char peek();
  public char poll();
  public void retract();
  public int tell();
  public void retractTo(int);
}
Compiled from "LeftRec.java"
class mi.legacy.parser.character.LeftRec implements mi.legacy.parser.character.IPattern {
  public mi.legacy.parser.character.LeftRec(mi.legacy.parser.character.IPattern);
  public mi.legacy.parser.character.ISymbol match(mi.legacy.parser.character.IParseStream);
}
Compiled from "LeftRec.java"
class mi.legacy.parser.character.LeftRec$1 {
}
Compiled from "LeftRec.java"
class mi.legacy.parser.character.LeftRec$PosEntry {
  public final int pos;
  public boolean isLeftRec;
  public mi.legacy.parser.character.ISymbol value;
  mi.legacy.parser.character.LeftRec$PosEntry(int, mi.legacy.parser.character.LeftRec$1);
}
Compiled from "OrPattern.java"
class mi.legacy.parser.character.OrPattern implements mi.legacy.parser.character.IPattern {
  public mi.legacy.parser.character.OrPattern(mi.legacy.parser.character.IPattern, mi.legacy.parser.character.IPattern);
  public mi.legacy.parser.character.ISymbol match(mi.legacy.parser.character.IParseStream);
}
Compiled from "ParseStream.java"
class mi.legacy.parser.character.ParseStream implements mi.legacy.parser.character.IParseStream {
  public mi.legacy.parser.character.ParseStream(mi.stream.ICharStream);
  public char peek();
  public char poll();
  public void retract();
  public void retractTo(int);
  public int tell();
}
Compiled from "ParserBuilder.java"
public class mi.legacy.parser.character.ParserBuilder {
  public static final mi.legacy.parser.character.ICombiner SELECT_FIRST;
  public static final mi.legacy.parser.character.ICombiner SELECT_SECOND;
  public static final mi.legacy.parser.character.ICombiner SELECT_NONE;
  public mi.legacy.parser.character.ParserBuilder();
  public static mi.legacy.parser.character.IParseStream parseStream(mi.stream.ICharStream);
  public static mi.legacy.parser.character.IPattern or(mi.legacy.parser.character.IPattern, mi.legacy.parser.character.IPattern);
  public static mi.legacy.parser.character.IPattern seq(mi.legacy.parser.character.IPattern, mi.legacy.parser.character.IPattern, mi.legacy.parser.character.ICombiner);
  public static mi.legacy.parser.character.IPattern star(mi.legacy.parser.character.IPattern, mi.legacy.parser.character.IPattern, mi.legacy.parser.character.ICombiner);
  public static mi.legacy.parser.character.IPattern leftRec(mi.legacy.parser.character.IPattern);
  static {};
}
Compiled from "ParserBuilder.java"
final class mi.legacy.parser.character.ParserBuilder$1 implements mi.legacy.parser.character.ICombiner {
  mi.legacy.parser.character.ParserBuilder$1();
  public mi.legacy.parser.character.ISymbol combine(mi.legacy.parser.character.ISymbol, mi.legacy.parser.character.ISymbol);
}
Compiled from "ParserBuilder.java"
final class mi.legacy.parser.character.ParserBuilder$2 implements mi.legacy.parser.character.ICombiner {
  mi.legacy.parser.character.ParserBuilder$2();
  public mi.legacy.parser.character.ISymbol combine(mi.legacy.parser.character.ISymbol, mi.legacy.parser.character.ISymbol);
}
Compiled from "ParserBuilder.java"
final class mi.legacy.parser.character.ParserBuilder$3 implements mi.legacy.parser.character.ICombiner {
  mi.legacy.parser.character.ParserBuilder$3();
  public mi.legacy.parser.character.ISymbol combine(mi.legacy.parser.character.ISymbol, mi.legacy.parser.character.ISymbol);
}
Compiled from "SeqPattern.java"
class mi.legacy.parser.character.SeqPattern implements mi.legacy.parser.character.IPattern {
  public mi.legacy.parser.character.SeqPattern(mi.legacy.parser.character.IPattern, mi.legacy.parser.character.IPattern, mi.legacy.parser.character.ICombiner);
  public mi.legacy.parser.character.ISymbol match(mi.legacy.parser.character.IParseStream);
}
Compiled from "StarPattern.java"
class mi.legacy.parser.character.StarPattern implements mi.legacy.parser.character.IPattern {
  public mi.legacy.parser.character.StarPattern(mi.legacy.parser.character.IPattern, mi.legacy.parser.character.IPattern, mi.legacy.parser.character.ICombiner);
  public mi.legacy.parser.character.ISymbol match(mi.legacy.parser.character.IParseStream);
}
Compiled from "StringPattern.java"
public class mi.legacy.parser.character.StringPattern implements mi.legacy.parser.character.IPattern {
  public mi.legacy.parser.character.StringPattern(java.lang.String);
  public mi.legacy.parser.character.ISymbol match(mi.legacy.parser.character.IParseStream);
}
Compiled from "StringSymbol.java"
public class mi.legacy.parser.character.StringSymbol implements mi.legacy.parser.character.ISymbol {
  public final java.lang.String value;
  public mi.legacy.parser.character.StringSymbol(java.lang.String);
}
Compiled from "ICharHandler.java"
public interface mi.legacy.parser.pattern.ICharHandler {
  public abstract void handle(int, char...);
}
Compiled from "ICharPattern.java"
public interface mi.legacy.parser.pattern.ICharPattern {
  public abstract boolean match(mi.stream.ICharStream, mi.legacy.parser.pattern.IContext);
}
Compiled from "IContext.java"
public interface mi.legacy.parser.pattern.IContext {
}
Compiled from "IHandler.java"
public interface mi.legacy.parser.pattern.IHandler<T> {
  public abstract void handle(int, T...);
}
Compiled from "IPattern.java"
public interface mi.legacy.parser.pattern.IPattern<T> {
  public abstract boolean match(mi.stream.IStream<T>, mi.legacy.parser.pattern.IHandler<T>);
}
Compiled from "AbstractRegex.java"
public abstract class mi.legacy.regex.AbstractRegex {
  protected mi.legacy.regex.AbstractRegex next;
  public mi.legacy.regex.AbstractRegex();
  protected void setNext(mi.legacy.regex.AbstractRegex);
  abstract void print(int);
  protected static void print(int, java.lang.String);
  protected void describe(int);
  protected void describe(int, java.lang.String);
  protected static void printChildren(int, mi.legacy.regex.AbstractRegex);
  public abstract boolean match(mi.legacy.regex.Match, int);
}
Compiled from "AsteriskRegex.java"
public class mi.legacy.regex.AsteriskRegex extends mi.legacy.regex.AbstractRegex {
  protected mi.legacy.regex.AtomRegex clause;
  public mi.legacy.regex.AsteriskRegex(mi.legacy.regex.AtomRegex);
  void print(int);
  public boolean match(mi.legacy.regex.Match, int);
}
Compiled from "AtomRegex.java"
public abstract class mi.legacy.regex.AtomRegex extends mi.legacy.regex.AbstractRegex {
  public mi.legacy.regex.AtomRegex();
}
Compiled from "CharRegex.java"
public class mi.legacy.regex.CharRegex extends mi.legacy.regex.AtomRegex {
  public mi.legacy.regex.CharRegex(char);
  void print(int);
  public boolean match(mi.legacy.regex.Match, int);
}
Compiled from "ClosureRegex.java"
public class mi.legacy.regex.ClosureRegex extends mi.legacy.regex.AbstractRegex {
  public mi.legacy.regex.ClosureRegex(mi.legacy.regex.AtomRegex, int, int);
  void print(int);
  public boolean match(mi.legacy.regex.Match, int);
}
Compiled from "Common.java"
public class mi.legacy.regex.Common {
  public mi.legacy.regex.Common();
  public static void main(java.lang.String[]) throws java.lang.InterruptedException;
}
Compiled from "DollarRegex.java"
public class mi.legacy.regex.DollarRegex extends mi.legacy.regex.AbstractRegex {
  public mi.legacy.regex.DollarRegex();
  void print(int);
  public boolean match(mi.legacy.regex.Match, int);
}
Compiled from "DotRegex.java"
public class mi.legacy.regex.DotRegex extends mi.legacy.regex.AtomRegex {
  public mi.legacy.regex.DotRegex();
  void print(int);
  public boolean match(mi.legacy.regex.Match, int);
}
Compiled from "EndRegex.java"
public class mi.legacy.regex.EndRegex extends mi.legacy.regex.AbstractRegex {
  public mi.legacy.regex.EndRegex();
  void print(int);
  public boolean match(mi.legacy.regex.Match, int);
}
Compiled from "GroupRegex.java"
public class mi.legacy.regex.GroupRegex extends mi.legacy.regex.AbstractRegex {
  public mi.legacy.regex.GroupRegex(int);
  public mi.legacy.regex.AbstractRegex groupEnd();
  public int groupNum();
  void print(int);
  public boolean match(mi.legacy.regex.Match, int);
}
Compiled from "GroupRegex.java"
class mi.legacy.regex.GroupRegex$1 {
}
Compiled from "GroupRegex.java"
class mi.legacy.regex.GroupRegex$GroupEnd extends mi.legacy.regex.AbstractRegex {
  void print(int);
  public boolean match(mi.legacy.regex.Match, int);
  mi.legacy.regex.GroupRegex$GroupEnd(int, mi.legacy.regex.GroupRegex$1);
}
Compiled from "HatRegex.java"
public class mi.legacy.regex.HatRegex extends mi.legacy.regex.AbstractRegex {
  public mi.legacy.regex.HatRegex();
  void print(int);
  public boolean match(mi.legacy.regex.Match, int);
}
Compiled from "Match.java"
public class mi.legacy.regex.Match {
  mi.legacy.regex.Match(java.lang.String, int);
  public boolean succeed();
  public int groupCount();
  public java.lang.String group(int);
  void setSucceed(boolean);
  void setNewOffset(int);
  int newOffset();
  char get(int);
  boolean begin(int);
  boolean end(int);
  void setGroupStart(int, int);
  void setGroupEnd(int, int);
  int groupStart(int);
  int groupEnd(int);
  void dump();
}
Compiled from "OrRegex.java"
public class mi.legacy.regex.OrRegex extends mi.legacy.regex.AbstractRegex {
  public mi.legacy.regex.OrRegex(mi.legacy.regex.AbstractRegex, mi.legacy.regex.AbstractRegex);
  void print(int);
  public boolean match(mi.legacy.regex.Match, int);
}
Compiled from "PlusRegex.java"
public class mi.legacy.regex.PlusRegex extends mi.legacy.regex.AsteriskRegex {
  public mi.legacy.regex.PlusRegex(mi.legacy.regex.AtomRegex);
  public boolean match(mi.legacy.regex.Match, int);
}
Compiled from "QuestionRegex.java"
public class mi.legacy.regex.QuestionRegex extends mi.legacy.regex.AbstractRegex {
  public mi.legacy.regex.QuestionRegex(mi.legacy.regex.AtomRegex);
  void print(int);
  public boolean match(mi.legacy.regex.Match, int);
}
Compiled from "RefRegex.java"
public class mi.legacy.regex.RefRegex extends mi.legacy.regex.AtomRegex {
  public mi.legacy.regex.RefRegex(int);
  void print(int);
  public boolean match(mi.legacy.regex.Match, int);
}
Compiled from "Regex.java"
public class mi.legacy.regex.Regex {
  public mi.legacy.regex.Regex(java.lang.String);
  public mi.legacy.regex.Match match(java.lang.String);
  public mi.legacy.regex.Match search(java.lang.String);
  void dump();
  char peek();
  char poll();
  boolean begin();
  boolean end();
  mi.legacy.regex.AbstractRegex parseOr(mi.legacy.regex.AbstractRegex);
  mi.legacy.regex.AbstractRegex parseSequence(mi.legacy.regex.AbstractRegex);
  mi.legacy.regex.AbstractRegex buildClosure(mi.legacy.regex.AtomRegex);
  mi.legacy.regex.AbstractRegex parseTerm();
  mi.legacy.regex.GroupRegex parseGroup();
  mi.legacy.regex.AtomRegex parseAtom();
  void verify(boolean, java.lang.String);
  static {};
}
Compiled from "RegexException.java"
public class mi.legacy.regex.RegexException extends java.lang.RuntimeException {
  public mi.legacy.regex.RegexException(java.lang.String);
}
Compiled from "LexException.java"
public class mi.lexer.LexException extends java.lang.RuntimeException {
  public mi.lexer.LexException(java.lang.String);
  public mi.lexer.LexException(java.lang.String, java.lang.Throwable);
}
Compiled from "LexStream.java"
public class mi.lexer.LexStream implements mi.stream.ICharStream {
  public mi.lexer.LexStream(mi.stream.ICharStream);
  public char peek();
  public char poll();
  public void retract();
  public int getLineNum();
  public int getColNum();
}
Compiled from "Lexer.java"
public class mi.lexer.Lexer {
  public mi.lexer.Lexer(mi.lexer.LexStream);
  public mi.lexer.Token peek();
  public void forward();
  public mi.lexer.Token poll();
}
Compiled from "Token.java"
public class mi.lexer.Token {
  public final mi.lexer.TokenType type;
  public final java.lang.String value;
  public final int lineNum;
  public final int colNum;
  public static mi.lexer.Token of(mi.lexer.TokenType, java.lang.String, int, int);
}
Compiled from "TokenStream.java"
public class mi.lexer.TokenStream implements mi.stream.IStream<mi.lexer.Token> {
  public mi.lexer.TokenStream(mi.stream.ICharStream);
  public mi.lexer.Token peek();
  public mi.lexer.Token poll();
  public void retract();
  mi.lexer.Token parse();
  public java.lang.Object poll();
  public java.lang.Object peek();
  static {};
}
Compiled from "TokenType.java"
public final class mi.lexer.TokenType extends java.lang.Enum<mi.lexer.TokenType> {
  public static final mi.lexer.TokenType PACKAGE;
  public static final mi.lexer.TokenType IMPORT;
  public static final mi.lexer.TokenType LET;
  public static final mi.lexer.TokenType TEMPLATE;
  public static final mi.lexer.TokenType TYPE;
  public static final mi.lexer.TokenType FUN;
  public static final mi.lexer.TokenType STRUCT;
  public static final mi.lexer.TokenType COLON;
  public static final mi.lexer.TokenType SEMICOLON;
  public static final mi.lexer.TokenType COMMA;
  public static final mi.lexer.TokenType LPAREN;
  public static final mi.lexer.TokenType RPAREN;
  public static final mi.lexer.TokenType RARROW;
  public static final mi.lexer.TokenType ASSIGNMENT;
  public static final mi.lexer.TokenType LT;
  public static final mi.lexer.TokenType GT;
  public static final mi.lexer.TokenType ID;
  public static final mi.lexer.TokenType OPERATOR;
  public static final mi.lexer.TokenType INTEGER;
  public static final mi.lexer.TokenType DOUBLE;
  public static final mi.lexer.TokenType STRING;
  public static final mi.lexer.TokenType COMMENT;
  public final java.lang.String value;
  public static mi.lexer.TokenType[] values();
  public static mi.lexer.TokenType valueOf(java.lang.String);
  public static mi.lexer.TokenType of(java.lang.String);
  public boolean isPredefined();
  static {};
}
Compiled from "ACSearcher.java"
public class mi.match.ACSearcher {
  public mi.match.ACSearcher(java.util.Collection<java.lang.String>);
  public void search(java.lang.String, mi.match.IMatchHandler);
  public static void main(java.lang.String[]);
}
Compiled from "ACSearcher.java"
final class mi.match.ACSearcher$1 implements mi.match.IMatchHandler {
  mi.match.ACSearcher$1();
  public void handle(int, java.lang.String);
}
Compiled from "ACSearcher.java"
class mi.match.ACSearcher$Node {
  mi.match.ACSearcher$Node(mi.match.ACSearcher$1);
  static java.lang.String access$100(mi.match.ACSearcher$Node);
  static mi.match.ACSearcher$Node access$200(mi.match.ACSearcher$Node);
  static mi.common.CharHashMap access$300(mi.match.ACSearcher$Node);
  static java.lang.String access$102(mi.match.ACSearcher$Node, java.lang.String);
  static mi.match.ACSearcher$Node access$202(mi.match.ACSearcher$Node, mi.match.ACSearcher$Node);
}
Compiled from "IMatchHandler.java"
public interface mi.match.IMatchHandler {
  public abstract void handle(int, java.lang.String);
}
Compiled from "KMPSearcher.java"
public class mi.match.KMPSearcher {
  public mi.match.KMPSearcher(java.lang.String);
  public boolean search(mi.stream.ICharStream);
  public boolean search(java.lang.String);
  public static void main(java.lang.String[]);
}
Compiled from "AbstractRegex.java"
public abstract class mi.regex.AbstractRegex {
  protected mi.regex.AbstractRegex next;
  public mi.regex.AbstractRegex();
  protected void setNext(mi.regex.AbstractRegex);
  abstract void print(int);
  protected static void print(int, java.lang.String);
  protected void describe(int);
  protected void describe(int, java.lang.String);
  protected static void printChildren(int, mi.regex.AbstractRegex);
  static void rollback(mi.stream.ICharStream, mi.regex.Match, int);
  public abstract boolean match(mi.stream.ICharStream, mi.regex.Match);
}
Compiled from "AtomRegex.java"
public abstract class mi.regex.AtomRegex extends mi.regex.AbstractRegex {
  public mi.regex.AtomRegex();
}
Compiled from "CharRegex.java"
public class mi.regex.CharRegex extends mi.regex.AtomRegex {
  public mi.regex.CharRegex(char);
  void print(int);
  public boolean match(mi.stream.ICharStream, mi.regex.Match);
}
Compiled from "ClosureRegex.java"
public class mi.regex.ClosureRegex extends mi.regex.AbstractRegex {
  public mi.regex.ClosureRegex(mi.regex.AbstractRegex, int, int);
  public mi.regex.ClosureRegex(mi.regex.AbstractRegex, int);
  protected void setNext(mi.regex.AbstractRegex);
  void print(int);
  public boolean match(mi.stream.ICharStream, mi.regex.Match);
}
Compiled from "ClosureRegex.java"
class mi.regex.ClosureRegex$1 {
}
Compiled from "ClosureRegex.java"
class mi.regex.ClosureRegex$Loop extends mi.regex.AbstractRegex {
  void print(int);
  void reset();
  public boolean match(mi.stream.ICharStream, mi.regex.Match);
  mi.regex.ClosureRegex$Loop(mi.regex.AbstractRegex, int, int, mi.regex.ClosureRegex$1);
  static int access$100(mi.regex.ClosureRegex$Loop);
  static int access$200(mi.regex.ClosureRegex$Loop);
}
Compiled from "Common.java"
public class mi.regex.Common {
  public mi.regex.Common();
  public static void main(java.lang.String[]) throws java.lang.InterruptedException;
  static boolean testMatch(mi.regex.Regex, java.lang.String);
  static boolean testStartWith(mi.regex.Regex, java.lang.String);
  static void verify(boolean);
}
Compiled from "DollarRegex.java"
public class mi.regex.DollarRegex extends mi.regex.AbstractRegex {
  public mi.regex.DollarRegex();
  void print(int);
  public boolean match(mi.stream.ICharStream, mi.regex.Match);
}
Compiled from "DotRegex.java"
public class mi.regex.DotRegex extends mi.regex.AtomRegex {
  public mi.regex.DotRegex();
  void print(int);
  public boolean match(mi.stream.ICharStream, mi.regex.Match);
}
Compiled from "EndRegex.java"
public class mi.regex.EndRegex extends mi.regex.AbstractRegex {
  public mi.regex.EndRegex();
  void print(int);
  public boolean match(mi.stream.ICharStream, mi.regex.Match);
}
Compiled from "GroupRegex.java"
public class mi.regex.GroupRegex extends mi.regex.AbstractRegex {
  public mi.regex.GroupRegex(int);
  public void setClause(mi.regex.AbstractRegex);
  protected void setNext(mi.regex.AbstractRegex);
  public mi.regex.AbstractRegex groupEnd();
  public int groupNum();
  void print(int);
  public boolean match(mi.stream.ICharStream, mi.regex.Match);
}
Compiled from "GroupRegex.java"
class mi.regex.GroupRegex$1 {
}
Compiled from "GroupRegex.java"
class mi.regex.GroupRegex$GroupEnd extends mi.regex.AbstractRegex {
  void print(int);
  public boolean match(mi.stream.ICharStream, mi.regex.Match);
  mi.regex.GroupRegex$GroupEnd(int, mi.regex.GroupRegex$1);
}
Compiled from "HatRegex.java"
public class mi.regex.HatRegex extends mi.regex.AbstractRegex {
  public mi.regex.HatRegex();
  void print(int);
  public boolean match(mi.stream.ICharStream, mi.regex.Match);
}
Compiled from "Match.java"
public class mi.regex.Match {
  mi.regex.Match(int);
  public boolean succeed();
  public int groupCount();
  public java.lang.String group(int);
  void reset();
  void append(char);
  int length();
  void setLength(int);
  char get(int);
  void setSucceed(boolean);
  void setGroupStart(int, int);
  void setGroupEnd(int, int);
  int groupStart(int);
  int groupEnd(int);
  void dump();
}
Compiled from "OrRegex.java"
public class mi.regex.OrRegex extends mi.regex.AbstractRegex {
  public mi.regex.OrRegex(mi.regex.AbstractRegex, mi.regex.AbstractRegex);
  void print(int);
  public boolean match(mi.stream.ICharStream, mi.regex.Match);
}
Compiled from "RefRegex.java"
public class mi.regex.RefRegex extends mi.regex.AtomRegex {
  public mi.regex.RefRegex(int);
  void print(int);
  public boolean match(mi.stream.ICharStream, mi.regex.Match);
}
Compiled from "Regex.java"
public class mi.regex.Regex {
  public mi.regex.Regex(java.lang.String);
  public mi.regex.Match startWith(java.lang.String);
  public mi.regex.Match match(java.lang.String);
  public mi.regex.Match startWith(mi.stream.ICharStream);
  public mi.regex.Match match(mi.stream.ICharStream);
  boolean match(mi.stream.ICharStream, mi.regex.Match);
  void dump();
  mi.regex.AbstractRegex parseOr(mi.stream.StringStream, mi.regex.AbstractRegex, mi.regex.AbstractRegex);
  mi.regex.AbstractRegex parseSequence(mi.stream.StringStream, mi.regex.AbstractRegex);
  mi.regex.AbstractRegex parseClosure(mi.stream.StringStream);
  int parseNumber(mi.stream.StringStream);
  mi.regex.AbstractRegex parseTerm(mi.stream.StringStream);
  mi.regex.GroupRegex parseGroup(mi.stream.StringStream);
  mi.regex.AtomRegex parseAtom(mi.stream.StringStream);
  mi.regex.SetRegex parseSet(mi.stream.StringStream);
  void parseRange(mi.stream.StringStream, mi.regex.SetRegex, char);
  static boolean isRegular(char);
  void verify(boolean, int, java.lang.String);
  static {};
}
Compiled from "RegexException.java"
public class mi.regex.RegexException extends java.lang.RuntimeException {
  public mi.regex.RegexException(java.lang.String);
}
Compiled from "SetRegex.java"
public class mi.regex.SetRegex extends mi.regex.AtomRegex {
  public mi.regex.SetRegex(boolean);
  public void add(char);
  public int count();
  void print(int);
  public boolean match(mi.stream.ICharStream, mi.regex.Match);
}
Compiled from "ArrayForkableStack.java"
public class mi.stack.ArrayForkableStack<T> implements mi.stack.IForkableStack<T> {
  public mi.stack.ArrayForkableStack(mi.stack.ArrayStack<T>, int[], int);
  public mi.stack.ArrayForkableStack(int);
  public T pop();
  public void push(T);
  public mi.stack.ArrayForkableStack<T> fork();
  public boolean isEmpty();
  public void clear();
  public java.lang.Object fork();
}
Compiled from "ArrayStack.java"
public class mi.stack.ArrayStack<T> implements mi.stack.IRandomAccessStack<T> {
  public mi.stack.ArrayStack(int);
  public T get(int);
  public int size();
  public T pop();
  public void push(T);
  public boolean isEmpty();
  public void clear();
}
Compiled from "CombinedStack.java"
public class mi.stack.CombinedStack<T> implements mi.stack.IForkableStack<T> {
  public mi.stack.CombinedStack(mi.stack.IForkableStack<T>, mi.stack.IRandomAccessStack<T>);
  public mi.stack.CombinedStack<T> fork();
  public T pop();
  public void push(T);
  public boolean isEmpty();
  public java.lang.Object fork();
}
Compiled from "CombinedStackTest.java"
public class mi.stack.CombinedStackTest {
  public mi.stack.CombinedStackTest();
  public void testPopPush() throws java.lang.Exception;
}
Compiled from "Forkable.java"
public interface mi.stack.Forkable<T> {
  public abstract T fork();
}
Compiled from "IForkableStack.java"
public interface mi.stack.IForkableStack<T> extends mi.stack.IStack<T>, mi.stack.Forkable<mi.stack.IForkableStack<T>> {
}
Compiled from "IRandomAccessStack.java"
public interface mi.stack.IRandomAccessStack<T> extends mi.stack.IStack<T> {
  public abstract T get(int);
  public abstract int size();
}
Compiled from "IStack.java"
public interface mi.stack.IStack<T> {
  public abstract T pop();
  public abstract void push(T);
  public abstract boolean isEmpty();
}
Compiled from "LinkedStack.java"
public class mi.stack.LinkedStack<T> implements mi.stack.IForkableStack<T> {
  public mi.stack.LinkedStack();
  public mi.stack.LinkedStack<T> fork();
  public T pop();
  public void push(T);
  public boolean isEmpty();
  public java.lang.Object fork();
}
Compiled from "LinkedStack.java"
class mi.stack.LinkedStack$1 {
}
Compiled from "LinkedStack.java"
class mi.stack.LinkedStack$Entry<T> {
  final T data;
  final mi.stack.LinkedStack$Entry<T> parent;
  mi.stack.LinkedStack$Entry(java.lang.Object, mi.stack.LinkedStack$Entry, mi.stack.LinkedStack$1);
}
Compiled from "BufferedCharStream.java"
public class mi.stream.BufferedCharStream implements mi.stream.ICharStream {
  public mi.stream.BufferedCharStream(mi.stream.ICharStream, int);
  public final int move(int, int);
  public final int length(int, int);
  public char peek();
  public char poll();
  public void retract();
}
Compiled from "BufferedStream.java"
public class mi.stream.BufferedStream<T> implements mi.stream.IStream<T> {
  public mi.stream.BufferedStream(mi.stream.IStream<T>, int);
  public final int move(int, int);
  public final int length(int, int);
  public T peek();
  public T poll();
  public void retract();
}
Compiled from "ICharStream.java"
public interface mi.stream.ICharStream {
  public static final char EOF;
  public abstract char peek();
  public abstract char poll();
  public abstract void retract();
}
Compiled from "ISStream.java"
public class mi.stream.ISStream implements mi.stream.ICharStream {
  public mi.stream.ISStream(java.io.InputStream);
  public mi.stream.ISStream(java.io.InputStream, java.lang.String) throws java.io.UnsupportedEncodingException;
  public char peek();
  public char poll();
  public void retract();
}
Compiled from "IStream.java"
public interface mi.stream.IStream<T> {
  public abstract T peek();
  public abstract T poll();
  public abstract void retract();
}
Compiled from "StringStream.java"
public class mi.stream.StringStream implements mi.stream.ICharStream {
  public mi.stream.StringStream(java.lang.String);
  public void reset();
  public int getPos();
  public char peek();
  public char poll();
  public void retract();
}
Compiled from "Action0.java"
public interface mi.task.Action0 {
  public abstract void apply();
}
Compiled from "Action1.java"
public interface mi.task.Action1<T> {
  public abstract void apply(T);
}
Compiled from "CollectTask.java"
public abstract class mi.task.CollectTask<TResult> extends mi.task.Task<TResult> {
  public mi.task.CollectTask(mi.task.ITask<?>[]);
  public mi.task.ITask<?>[] getTasks();
  public void execute(java.lang.Object, mi.task.IContinuation, mi.task.IScheduler);
  protected abstract mi.task.IContinuation newContinuation(mi.task.IContinuation);
  public void onExecute(java.lang.Object, mi.task.IContinuation, mi.task.ITask<?>, mi.task.IScheduler);
}
Compiled from "Context.java"
public class mi.task.Context<AResult, TResult> {
  mi.task.Context(AResult, mi.task.IContinuation, mi.task.ITask<?>, mi.task.IScheduler);
  public AResult getState();
  public void resume(TResult);
  public void resume(TResult, mi.task.IScheduler);
}
Compiled from "ContextCollectTask.java"
public class mi.task.ContextCollectTask<TResult> extends mi.task.CollectTask<TResult> {
  public mi.task.ContextCollectTask(mi.task.Action1<mi.task.Context<?, TResult>>, mi.task.ITask<?>...);
  protected mi.task.IContinuation newContinuation(mi.task.IContinuation);
  static mi.task.Action1 access$000(mi.task.ContextCollectTask);
}
Compiled from "ContextCollectTask.java"
public class mi.task.ContextCollectTask$Continuation<TResult> implements mi.task.IContinuation {
  public mi.task.ContextCollectTask$Continuation(mi.task.IContinuation, mi.task.ContextCollectTask<TResult>);
  public void apply(java.lang.Object, mi.task.ITask<?>, mi.task.IScheduler);
}
Compiled from "ContextSeqTask.java"
public class mi.task.ContextSeqTask<AResult, TResult> extends mi.task.SeqTask<AResult, TResult> {
  public mi.task.ContextSeqTask(mi.task.ITask<AResult>, mi.task.Action1<mi.task.Context<AResult, TResult>>, boolean);
  public void onExecute(java.lang.Object, mi.task.IContinuation, mi.task.ITask<?>, mi.task.IScheduler);
  protected TResult evaluate(java.lang.Object);
}
Compiled from "ContextTask.java"
public class mi.task.ContextTask<T, TResult> extends mi.task.Task<TResult> {
  public mi.task.ContextTask(mi.task.Action1<mi.task.Context<T, TResult>>);
  public void execute(java.lang.Object, mi.task.IContinuation, mi.task.IScheduler);
  public void onExecute(java.lang.Object, mi.task.IContinuation, mi.task.ITask<?>, mi.task.IScheduler);
}
Compiled from "Continuation.java"
public class mi.task.Continuation implements mi.task.IContinuation {
  protected final mi.task.IContinuation next;
  protected final mi.task.ITask<?> task;
  public mi.task.Continuation(mi.task.IContinuation, mi.task.ITask<?>);
  public void apply(java.lang.Object, mi.task.ITask<?>, mi.task.IScheduler);
}
Compiled from "ExecutorScheduler.java"
public class mi.task.ExecutorScheduler extends mi.task.SynchronizedScheduler {
  public mi.task.ExecutorScheduler(java.util.concurrent.Executor);
  public void schedule(mi.task.ITask<?>, java.lang.Object, mi.task.IContinuation, mi.task.ITask<?>);
  static void access$001(mi.task.ExecutorScheduler, mi.task.ITask, java.lang.Object, mi.task.IContinuation, mi.task.ITask);
}
Compiled from "ExecutorScheduler.java"
class mi.task.ExecutorScheduler$1 implements java.lang.Runnable {
  final mi.task.ITask val$task;
  final java.lang.Object val$state;
  final mi.task.IContinuation val$cont;
  final mi.task.ITask val$previous;
  final mi.task.ExecutorScheduler this$0;
  mi.task.ExecutorScheduler$1(mi.task.ExecutorScheduler, mi.task.ITask, java.lang.Object, mi.task.IContinuation, mi.task.ITask);
  public void run();
}
Compiled from "FlattenTask.java"
public class mi.task.FlattenTask<TResult, TTask extends mi.task.ITask<TResult>> extends mi.task.SeqTask<TTask, TResult> {
  public mi.task.FlattenTask(mi.task.ITask<TTask>);
  public void execute(java.lang.Object, mi.task.IContinuation, mi.task.IScheduler);
  protected TResult evaluate(java.lang.Object);
}
Compiled from "FlattenTask.java"
public class mi.task.FlattenTask$Continuation implements mi.task.IContinuation {
  public mi.task.FlattenTask$Continuation(mi.task.IContinuation, mi.task.ITask<?>);
  public void apply(java.lang.Object, mi.task.ITask<?>, mi.task.IScheduler);
}
Compiled from "Func0.java"
public interface mi.task.Func0<TResult> {
  public abstract TResult apply();
}
Compiled from "Func0Task.java"
public class mi.task.Func0Task<TResult> extends mi.task.Task<TResult> {
  public mi.task.Func0Task(mi.task.Func0<TResult>);
  public void onExecute(java.lang.Object, mi.task.IContinuation, mi.task.ITask<?>, mi.task.IScheduler);
  public void execute(java.lang.Object, mi.task.IContinuation, mi.task.IScheduler);
}
Compiled from "Func1.java"
public interface mi.task.Func1<T, TResult> {
  public abstract TResult apply(T);
}
Compiled from "Func1SeqTask.java"
public class mi.task.Func1SeqTask<T, AResult, TResult> extends mi.task.SeqTask<AResult, TResult> {
  public mi.task.Func1SeqTask(mi.task.ITask<AResult>, mi.task.Func1<T, TResult>, boolean);
  public TResult evaluate(java.lang.Object);
}
Compiled from "Func1Task.java"
public class mi.task.Func1Task<T, TResult> extends mi.task.Task<TResult> {
  public mi.task.Func1Task(mi.task.Func1<T, TResult>);
  public void onExecute(java.lang.Object, mi.task.IContinuation, mi.task.ITask<?>, mi.task.IScheduler);
  public void execute(java.lang.Object, mi.task.IContinuation, mi.task.IScheduler);
}
Compiled from "IContinuation.java"
public interface mi.task.IContinuation {
  public static final mi.task.IContinuation END_CONTINUATION;
  public abstract void apply(java.lang.Object, mi.task.ITask<?>, mi.task.IScheduler);
  static {};
}
Compiled from "IContinuation.java"
final class mi.task.IContinuation$1 implements mi.task.IContinuation {
  mi.task.IContinuation$1();
  public void apply(java.lang.Object, mi.task.ITask<?>, mi.task.IScheduler);
  public java.lang.String toString();
}
Compiled from "IScheduler.java"
public interface mi.task.IScheduler {
  public abstract void schedule(mi.task.ITask<?>, java.lang.Object, mi.task.IContinuation, mi.task.ITask<?>);
}
Compiled from "ITask.java"
public interface mi.task.ITask<TResult> {
  public abstract void execute(java.lang.Object, mi.task.IContinuation, mi.task.IScheduler);
  public abstract void onExecute(java.lang.Object, mi.task.IContinuation, mi.task.ITask<?>, mi.task.IScheduler);
}
Compiled from "InitTask.java"
public class mi.task.InitTask<T, TResult> extends mi.task.Task<TResult> {
  public mi.task.InitTask(T, mi.task.ITask<?>);
  public void execute(java.lang.Object, mi.task.IContinuation, mi.task.IScheduler);
  public void onExecute(java.lang.Object, mi.task.IContinuation, mi.task.ITask<?>, mi.task.IScheduler);
}
Compiled from "SeqTask.java"
public abstract class mi.task.SeqTask<AResult, TResult> extends mi.task.Task<TResult> {
  protected final mi.task.ITask<AResult> antecedent;
  public mi.task.SeqTask(mi.task.ITask<AResult>, boolean);
  public void execute(java.lang.Object, mi.task.IContinuation, mi.task.IScheduler);
  public void onExecute(java.lang.Object, mi.task.IContinuation, mi.task.ITask<?>, mi.task.IScheduler);
  protected abstract TResult evaluate(java.lang.Object);
}
Compiled from "SeqTask.java"
public class mi.task.SeqTask$FlattenContinuation extends mi.task.Continuation {
  public mi.task.SeqTask$FlattenContinuation(mi.task.IContinuation, mi.task.ITask<?>);
  public void apply(java.lang.Object, mi.task.ITask<?>, mi.task.IScheduler);
}
Compiled from "SynchronizedScheduler.java"
public class mi.task.SynchronizedScheduler implements mi.task.IScheduler {
  public mi.task.SynchronizedScheduler();
  public void schedule(mi.task.ITask<?>, java.lang.Object, mi.task.IContinuation, mi.task.ITask<?>);
}
Compiled from "Task.java"
public abstract class mi.task.Task<TResult> implements mi.task.ITask<TResult> {
  public mi.task.Task();
  public void execute(mi.task.IScheduler);
  public <SResult> mi.task.Task<SResult> continueWith(mi.task.Func1<TResult, SResult>);
  public <T, SResult> mi.task.Task<SResult> flattenAndContinueWith(mi.task.Func1<T, SResult>);
  public <SResult> mi.task.Task<SResult> continueWith(mi.task.Action1<mi.task.Context<TResult, SResult>>);
  public <SResult> mi.task.Task<SResult> flattenAndContinueWith(mi.task.Action1<mi.task.Context<TResult, SResult>>);
  public mi.task.Waiter<TResult> continueWithWaiter();
  public <T> mi.task.Task<TResult> initWithState(T);
  public <T> mi.task.Task<TResult> initWithState(T...);
  public static <TResult> mi.task.Task<TResult> from(mi.task.Func0<TResult>);
  public static <T, TResult> mi.task.Task<TResult> from(mi.task.Func1<T, TResult>);
  public static <T, TResult> mi.task.Task<TResult> from(mi.task.Action1<mi.task.Context<T, TResult>>);
  public static <TResult> mi.task.CollectTask<TResult> continueWhen(mi.task.Action1<mi.task.Context<?, TResult>>, mi.task.ITask<?>...);
  public static mi.task.WhenAllTask continueWhenAll(mi.task.ITask<?>...);
  public static mi.task.WhenAnyTask continueWhenAny(mi.task.ITask<?>...);
  public static <TResult, TTask extends mi.task.ITask<TResult>> mi.task.Task<TResult> flattenOnce(mi.task.ITask<TTask>);
}
Compiled from "TaskTest.java"
public class mi.task.TaskTest {
  public mi.task.TaskTest();
  public void testTask() throws java.lang.Exception;
  public static void addCallback(int, int, mi.task.Action1<java.lang.Integer>);
  public static mi.task.ITask<java.lang.Integer> addAsync(int, int);
  public mi.task.Task<java.lang.Integer> testAsync(int);
  static {};
}
Compiled from "TaskTest.java"
final class mi.task.TaskTest$1 implements java.lang.Runnable {
  final mi.task.Action1 val$func;
  final int val$a;
  final int val$b;
  mi.task.TaskTest$1(mi.task.Action1, int, int);
  public void run();
}
Compiled from "TaskTest.java"
final class mi.task.TaskTest$2 implements mi.task.Action1<mi.task.Context<int[], java.lang.Integer>> {
  mi.task.TaskTest$2();
  public void apply(mi.task.Context<int[], java.lang.Integer>);
  public void apply(java.lang.Object);
}
Compiled from "TaskTest.java"
class mi.task.TaskTest$2$1 implements mi.task.Action1<java.lang.Integer> {
  final mi.task.Context val$context;
  final mi.task.TaskTest$2 this$0;
  mi.task.TaskTest$2$1(mi.task.TaskTest$2, mi.task.Context);
  public void apply(java.lang.Integer);
  public void apply(java.lang.Object);
}
Compiled from "TaskTest.java"
final class mi.task.TaskTest$3 implements mi.task.Func1<java.lang.Integer, java.lang.Integer> {
  mi.task.TaskTest$3();
  public java.lang.Integer apply(java.lang.Integer);
  public java.lang.Object apply(java.lang.Object);
}
Compiled from "TaskTest.java"
final class mi.task.TaskTest$4 implements mi.task.Func1<java.lang.Integer, mi.task.Task<java.lang.Integer>> {
  mi.task.TaskTest$4();
  public mi.task.Task<java.lang.Integer> apply(java.lang.Integer);
  public java.lang.Object apply(java.lang.Object);
}
Compiled from "TaskTest.java"
class mi.task.TaskTest$4$1 implements mi.task.Func0<java.lang.Integer> {
  final java.lang.Integer val$value;
  final mi.task.TaskTest$4 this$0;
  mi.task.TaskTest$4$1(mi.task.TaskTest$4, java.lang.Integer);
  public java.lang.Integer apply();
  public java.lang.Object apply();
}
Compiled from "TaskTest.java"
class mi.task.TaskTest$4$2 implements mi.task.Func0<java.lang.Integer> {
  final java.lang.Integer val$value;
  final mi.task.TaskTest$4 this$0;
  mi.task.TaskTest$4$2(mi.task.TaskTest$4, java.lang.Integer);
  public java.lang.Integer apply();
  public java.lang.Object apply();
}
Compiled from "TaskTest.java"
class mi.task.TaskTest$4$3 implements mi.task.Func1<java.lang.Object[], java.lang.Integer> {
  final mi.task.TaskTest$4 this$0;
  mi.task.TaskTest$4$3(mi.task.TaskTest$4);
  public java.lang.Integer apply(java.lang.Object[]);
  public java.lang.Object apply(java.lang.Object);
}
Compiled from "TaskTest.java"
final class mi.task.TaskTest$5 implements mi.task.Func1<java.lang.Integer, mi.task.ITask<java.lang.Integer>> {
  mi.task.TaskTest$5();
  public mi.task.ITask<java.lang.Integer> apply(java.lang.Integer);
  public java.lang.Object apply(java.lang.Object);
}
Compiled from "TaskTest.java"
final class mi.task.TaskTest$6 implements mi.task.Action1<mi.task.Context<java.lang.Integer, java.lang.Integer>> {
  mi.task.TaskTest$6();
  public void apply(mi.task.Context<java.lang.Integer, java.lang.Integer>);
  public void apply(java.lang.Object);
}
Compiled from "TaskTest.java"
class mi.task.TaskTest$6$1 implements mi.task.Action1<java.lang.Integer> {
  final mi.task.Context val$context;
  final mi.task.TaskTest$6 this$0;
  mi.task.TaskTest$6$1(mi.task.TaskTest$6, mi.task.Context);
  public void apply(java.lang.Integer);
  public void apply(java.lang.Object);
}
Compiled from "TaskTest.java"
final class mi.task.TaskTest$7 implements mi.task.Func1<java.lang.Integer, java.lang.Integer> {
  mi.task.TaskTest$7();
  public java.lang.Integer apply(java.lang.Integer);
  public java.lang.Object apply(java.lang.Object);
}
Compiled from "Waiter.java"
public class mi.task.Waiter<TResult> extends mi.task.SeqTask<TResult, TResult> {
  public mi.task.Waiter(mi.task.ITask<TResult>);
  public boolean isComplete();
  public TResult getResult();
  protected TResult evaluate(java.lang.Object);
  public void onExecute(java.lang.Object, mi.task.IContinuation, mi.task.ITask<?>, mi.task.IScheduler);
}
Compiled from "WhenAllTask.java"
public class mi.task.WhenAllTask extends mi.task.CollectTask<java.lang.Object[]> {
  public mi.task.WhenAllTask(mi.task.ITask<?>...);
  protected mi.task.IContinuation newContinuation(mi.task.IContinuation);
}
Compiled from "WhenAllTask.java"
public class mi.task.WhenAllTask$Continuation implements mi.task.IContinuation {
  public mi.task.WhenAllTask$Continuation(mi.task.IContinuation, mi.task.WhenAllTask);
  public void apply(java.lang.Object, mi.task.ITask<?>, mi.task.IScheduler);
}
Compiled from "WhenAnyTask.java"
public class mi.task.WhenAnyTask extends mi.task.CollectTask<mi.task.WhenAnyTask$Result> {
  public mi.task.WhenAnyTask(mi.task.ITask<?>...);
  protected mi.task.IContinuation newContinuation(mi.task.IContinuation);
}
Compiled from "WhenAnyTask.java"
public class mi.task.WhenAnyTask$Continuation implements mi.task.IContinuation {
  public mi.task.WhenAnyTask$Continuation(mi.task.IContinuation, mi.task.WhenAnyTask);
  public void apply(java.lang.Object, mi.task.ITask<?>, mi.task.IScheduler);
}
Compiled from "WhenAnyTask.java"
public class mi.task.WhenAnyTask$Result {
  public final mi.task.ITask<?> task;
  public final java.lang.Object result;
  public mi.task.WhenAnyTask$Result(mi.task.ITask<?>, java.lang.Object);
  public java.lang.String toString();
}
