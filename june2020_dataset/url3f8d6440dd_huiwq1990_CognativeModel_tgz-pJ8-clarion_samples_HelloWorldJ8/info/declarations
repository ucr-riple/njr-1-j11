Compiled from "ACSLevelProbabilitySettingEquation.java"
public class clarion.extensions.ACSLevelProbabilitySettingEquation extends clarion.extensions.AbstractEquation {
  public static double GLOBAL_A;
  public static double GLOBAL_B;
  public static double GLOBAL_C;
  public double A;
  public double B;
  public double C;
  public clarion.extensions.ACSLevelProbabilitySettingEquation(java.util.Collection<clarion.system.Dimension>, clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk>);
  public void forwardPass();
  static {};
}
Compiled from "ACSLevelProbabilitySettingModule.java"
public class clarion.extensions.ACSLevelProbabilitySettingModule extends clarion.system.AbstractMetaCognitiveModule implements clarion.system.InterfaceMCSRunsBeforeACS {
  public clarion.extensions.ACSLevelProbabilitySettingModule(clarion.system.DriveStrengthCollection);
  public clarion.extensions.ACSLevelProbabilitySettingModule(clarion.system.AbstractImplicitModule) throws clarion.system.InvalidFormatException;
  public void performMetaCognition(clarion.system.DimensionValueCollection, long) throws clarion.system.MissingACSException;
  public void attachACS(clarion.system.ACS);
  public static clarion.system.DimensionlessOutputChunkCollection generateOutputs();
}
Compiled from "ACSLevelProbabilitySettingModule.java"
public final class clarion.extensions.ACSLevelProbabilitySettingModule$RequiredOutputs extends java.lang.Enum<clarion.extensions.ACSLevelProbabilitySettingModule$RequiredOutputs> {
  public static final clarion.extensions.ACSLevelProbabilitySettingModule$RequiredOutputs TL;
  public static final clarion.extensions.ACSLevelProbabilitySettingModule$RequiredOutputs BL;
  public static clarion.extensions.ACSLevelProbabilitySettingModule$RequiredOutputs[] values();
  public static clarion.extensions.ACSLevelProbabilitySettingModule$RequiredOutputs valueOf(java.lang.String);
  static {};
}
Compiled from "AbstractEquation.java"
public abstract class clarion.extensions.AbstractEquation extends clarion.system.AbstractImplicitModule implements clarion.system.InterfaceHandlesFeedback {
  protected double Feedback;
  public clarion.extensions.AbstractEquation(java.util.Collection<clarion.system.Dimension>, clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk>);
  public double getFeedback();
  public void setFeedback(double);
}
Compiled from "DriveEquation.java"
public class clarion.extensions.DriveEquation extends clarion.extensions.AbstractEquation {
  public clarion.extensions.DriveEquation(java.lang.Object, java.util.Collection<clarion.system.Dimension>, clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk>) throws clarion.system.InvalidFormatException;
  public void forwardPass();
}
Compiled from "GoalSelectionEquation.java"
public class clarion.extensions.GoalSelectionEquation extends clarion.extensions.AbstractEquation {
  public clarion.extensions.GoalSelectionEquation(java.util.Collection<clarion.system.Dimension>, clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk>) throws clarion.system.InvalidFormatException;
  public void forwardPass();
}
Compiled from "GoalSelectionModule.java"
public class clarion.extensions.GoalSelectionModule extends clarion.system.AbstractMetaCognitiveModule implements clarion.system.InterfaceMCSRunsAtPerception {
  public clarion.system.StochasticSelector SELECTOR;
  public clarion.extensions.GoalSelectionModule(clarion.system.DriveStrengthCollection, clarion.system.GoalCollection);
  public clarion.extensions.GoalSelectionModule(clarion.system.AbstractImplicitModule) throws clarion.system.InvalidFormatException;
  public void attachGoalStructure(clarion.system.GoalStructure);
  public void performMetaCognition(clarion.system.DimensionValueCollection, long) throws clarion.system.MissingGoalStructureException;
}
Compiled from "JudgmentCorrectionEquation.java"
public class clarion.extensions.JudgmentCorrectionEquation extends clarion.extensions.AbstractEquation {
  public static double GLOBAL_PHI_1;
  public static double GLOBAL_PHI_2;
  public static double GLOBAL_BETA_1;
  public static double GLOBAL_BETA_2;
  public double PHI_1;
  public double PHI_2;
  public double BETA_1;
  public double BETA_2;
  public static boolean GLOBAL_FORCE_ASSIMILATIVE;
  public static boolean GLOBAL_FORCE_CONTRASTIVE;
  public boolean FORCE_ASSIMILATIVE;
  public boolean FORCE_CONTRASTIVE;
  public clarion.extensions.JudgmentCorrectionEquation(java.util.Collection<clarion.system.Dimension>, clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk>);
  public void forwardPass() throws clarion.system.SettingsConflictException;
  static {};
}
Compiled from "JudgmentCorrectionModule.java"
public class clarion.extensions.JudgmentCorrectionModule extends clarion.system.AbstractMetaCognitiveModule implements clarion.system.InterfaceMCSRunsAfterACS {
  public clarion.system.StochasticSelector Selector;
  public static double GLOBAL_EPSILON;
  public clarion.extensions.JudgmentCorrectionModule(clarion.system.DimensionValueCollection, clarion.system.ActionCollection, clarion.system.Goal);
  public clarion.extensions.JudgmentCorrectionModule(clarion.system.AbstractImplicitModule, clarion.system.Goal);
  public void performMetaCognition(clarion.system.DimensionValueCollection, long) throws clarion.system.MissingGoalStructureException, clarion.system.MissingEpisodicMemoryException;
  public void attachEpisodicMemory(clarion.system.EpisodicMemory);
  public void attachGoalStructure(clarion.system.GoalStructure);
  public boolean checkEligibility();
  static {};
}
Compiled from "JudgmentCorrectionModule.java"
public final class clarion.extensions.JudgmentCorrectionModule$RequiredActionDimensions extends java.lang.Enum<clarion.extensions.JudgmentCorrectionModule$RequiredActionDimensions> {
  public static final clarion.extensions.JudgmentCorrectionModule$RequiredActionDimensions RATING;
  public static clarion.extensions.JudgmentCorrectionModule$RequiredActionDimensions[] values();
  public static clarion.extensions.JudgmentCorrectionModule$RequiredActionDimensions valueOf(java.lang.String);
  static {};
}
Compiled from "JudgmentCorrectionModule.java"
public final class clarion.extensions.JudgmentCorrectionModule$RequiredInputDimensions extends java.lang.Enum<clarion.extensions.JudgmentCorrectionModule$RequiredInputDimensions> {
  public static final clarion.extensions.JudgmentCorrectionModule$RequiredInputDimensions PRIMER;
  public static final clarion.extensions.JudgmentCorrectionModule$RequiredInputDimensions TARGET;
  public static clarion.extensions.JudgmentCorrectionModule$RequiredInputDimensions[] values();
  public static clarion.extensions.JudgmentCorrectionModule$RequiredInputDimensions valueOf(java.lang.String);
  static {};
}
Compiled from "Personality.java"
public class clarion.extensions.Personality {
  public clarion.extensions.Personality();
  public static java.util.EnumMap<clarion.extensions.Personality$BehavioralSystemMembers, clarion.system.DriveCollection> initUserDefinedPersonality(java.util.Collection<clarion.system.Value>);
}
Compiled from "Personality.java"
public final class clarion.extensions.Personality$BehavioralSystemMembers extends java.lang.Enum<clarion.extensions.Personality$BehavioralSystemMembers> {
  public static final clarion.extensions.Personality$BehavioralSystemMembers BAS_ONLY;
  public static final clarion.extensions.Personality$BehavioralSystemMembers BIS_ONLY;
  public static final clarion.extensions.Personality$BehavioralSystemMembers BOTH_SYSTEMS;
  public static final clarion.extensions.Personality$BehavioralSystemMembers NEITHER_SYSTEM;
  public final java.util.ArrayList<clarion.extensions.Personality$PrimaryDrives> Drives;
  public static clarion.extensions.Personality$BehavioralSystemMembers[] values();
  public static clarion.extensions.Personality$BehavioralSystemMembers valueOf(java.lang.String);
  static {};
}
Compiled from "Personality.java"
public final class clarion.extensions.Personality$PersonalityTypes extends java.lang.Enum<clarion.extensions.Personality$PersonalityTypes> {
  public static final clarion.extensions.Personality$PersonalityTypes SOCIABLE;
  public static final clarion.extensions.Personality$PersonalityTypes SHY;
  public static final clarion.extensions.Personality$PersonalityTypes CONFIDENT;
  public static final clarion.extensions.Personality$PersonalityTypes ANXIOUS;
  public static final clarion.extensions.Personality$PersonalityTypes RESPONSIBLE;
  public static final clarion.extensions.Personality$PersonalityTypes LAZY;
  public static final clarion.extensions.Personality$PersonalityTypes GENERIC;
  public java.util.EnumMap<clarion.extensions.Personality$BehavioralSystemMembers, clarion.system.DriveCollection> Drives;
  public static clarion.extensions.Personality$PersonalityTypes[] values();
  public static clarion.extensions.Personality$PersonalityTypes valueOf(java.lang.String);
  static {};
}
Compiled from "Personality.java"
public final class clarion.extensions.Personality$PrimaryDrives extends java.lang.Enum<clarion.extensions.Personality$PrimaryDrives> {
  public static final clarion.extensions.Personality$PrimaryDrives FOOD;
  public static final clarion.extensions.Personality$PrimaryDrives WATER;
  public static final clarion.extensions.Personality$PrimaryDrives REST;
  public static final clarion.extensions.Personality$PrimaryDrives AVOIDING_PHYSICAL_DANGER;
  public static final clarion.extensions.Personality$PrimaryDrives REPRODUCTION;
  public static final clarion.extensions.Personality$PrimaryDrives AVOIDING_THE_UNPLEASANT;
  public static final clarion.extensions.Personality$PrimaryDrives AFFILIATION_AND_BELONGINGNESS;
  public static final clarion.extensions.Personality$PrimaryDrives RECOGNITION_AND_ACHEIVEMENT;
  public static final clarion.extensions.Personality$PrimaryDrives DOMINANCE_AND_POWER;
  public static final clarion.extensions.Personality$PrimaryDrives AUTONOMY;
  public static final clarion.extensions.Personality$PrimaryDrives DEFERENCE;
  public static final clarion.extensions.Personality$PrimaryDrives SIMILANCE;
  public static final clarion.extensions.Personality$PrimaryDrives FAIRNESS;
  public static final clarion.extensions.Personality$PrimaryDrives HONOR;
  public static final clarion.extensions.Personality$PrimaryDrives NURTURANCE;
  public static final clarion.extensions.Personality$PrimaryDrives CONSERVATION;
  public static final clarion.extensions.Personality$PrimaryDrives CURIOSITY;
  public static clarion.extensions.Personality$PrimaryDrives[] values();
  public static clarion.extensions.Personality$PrimaryDrives valueOf(java.lang.String);
  static {};
}
Compiled from "TableLookup.java"
public class clarion.extensions.TableLookup extends clarion.system.AbstractRuntimeTrainableImplicitModule {
  protected double Feedback;
  protected double PM;
  protected double NM;
  public static double GLOBAL_POSITIVE_MATCH_THRESHOLD;
  public double POSITIVE_MATCH_THRESHOLD;
  public clarion.extensions.TableLookup(java.util.Collection<clarion.system.Dimension>, clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk>, java.util.Map<clarion.system.DimensionValueCollection, clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk>>);
  public void backwardPass();
  public void forwardPass();
  public boolean checkExtraction();
  public java.lang.Double getSuccessRate();
  static {};
}
Compiled from "HelloWorld.java"
public class clarion.samples.HelloWorld implements clarion.tools.BaseSimulationTemplate {
  public clarion.system.DimensionValueCollection SensoryInputSpace;
  public clarion.system.DimensionValueCollection CombinedInputSpace;
  public clarion.system.ActionCollection Actions;
  public clarion.system.CLARION Agent;
  public clarion.system.GoalCollection Goals;
  public int CorrectCounter;
  public int NumberTrials;
  public clarion.samples.HelloWorld();
  public static void main(java.lang.String[]);
  public void initializeSensoryInformationSpace();
  public void initializeAgentInternalSpace();
  public void initializeCLARIONAgent(clarion.system.CLARION);
  public void run(clarion.system.CLARION);
  public void reportResults();
  public void updateDeficit(clarion.system.CLARION, clarion.system.AbstractAction);
}
Compiled from "Tutorial.java"
public class clarion.samples.Tutorial implements clarion.tools.BaseSimulationTemplate {
  public java.io.OutputStream Reporter;
  public clarion.samples.Tutorial();
  public clarion.samples.Tutorial(java.io.OutputStream);
  public void initializeAgentInternalSpace();
  public void initializeCLARIONAgent(clarion.system.CLARION);
  public void initializeSensoryInformationSpace();
  public void reportResults();
  public void run(clarion.system.CLARION);
}
Compiled from "XOR.java"
public class clarion.samples.XOR implements clarion.tools.BaseSimulationTemplate {
  public clarion.system.DimensionValueCollection SensoryInputSpace;
  public clarion.system.DimensionValueCollection CombinedInputSpace;
  public clarion.system.ActionCollection Actions;
  public clarion.system.CLARION Agent;
  public double CorrectCounter;
  public int CurrentTest;
  public double NumberTrials;
  public int NumberTestRuns;
  public static int NumberAgents;
  public double Accuracy;
  public int DecimalPlace;
  public double AvgAccuracyNumerator;
  public boolean useVerboseLogging;
  public double Bool1False;
  public double Bool1True;
  public double Bool2False;
  public double Bool2True;
  public clarion.samples.XOR();
  public static void main(java.lang.String[]);
  public void initializeAgentInternalSpace();
  public void initializeCLARIONAgent(clarion.system.CLARION);
  public void initializeSensoryInformationSpace();
  public void reportResults();
  public void reportFinalResults();
  public void run(clarion.system.CLARION);
  static {};
}
Compiled from "ACS.java"
public final class clarion.system.ACS extends clarion.system.AbstractSubsystem {
  protected clarion.system.WorkingMemory WM;
  protected clarion.system.EpisodicMemory EM;
  public clarion.system.StochasticSelector SELECTOR;
  public clarion.system.RuleExtractor EXTRACTOR;
  public clarion.system.RuleRefiner REFINER;
  public clarion.system.AbstractMatchCalculator MatchCalculator;
  public static clarion.system.ACS$LevelSelectionMethods GLOBAL_LEVEL_SELECTION_METHOD;
  public static clarion.system.ACS$LevelSelectionOptions GLOBAL_LEVEL_SELECTION_OPTION;
  public clarion.system.ACS$LevelSelectionMethods LEVEL_SELECTION_METHOD;
  public clarion.system.ACS$LevelSelectionOptions LEVEL_SELECTION_OPTION;
  public static double GLOBAL_VARIABLE_C3;
  public double VARIABLE_C3;
  public static double GLOBAL_VARIABLE_C4;
  public double VARIABLE_C4;
  public double MCS_BL_PROBABILITY;
  public double MCS_BL_WEIGHT;
  public double MCS_TL_PROBABILITY;
  public double MCS_TL_WEIGHT;
  public static double GLOBAL_MCS_A;
  public static double GLOBAL_MCS_B;
  public double MCS_A;
  public double MCS_B;
  public static double GLOBAL_FIXED_BL_PROBABILITY;
  public static double GLOBAL_FIXED_BL_COMB_WEIGHT;
  public double FIXED_BL_PROBABILITY;
  public double FIXED_BL_COMB_WEIGHT;
  public static double GLOBAL_VARIABLE_BL_BETA;
  public static double GLOBAL_VARIABLE_BL_COMB_WEIGHT_BETA;
  public double VARIABLE_BL_BETA;
  public double VARIABLE_BL_COMB_WEIGHT_BETA;
  public static double GLOBAL_FIXED_RER_PROBABILITY;
  public static double GLOBAL_FIXED_RER_COMB_WEIGHT;
  public double FIXED_RER_PROBABILITY;
  public double FIXED_RER_COMB_WEIGHT;
  public static double GLOBAL_VARIABLE_RER_BETA;
  public static double GLOBAL_VARIABLE_RER_COMB_WEIGHT_BETA;
  public double VARIABLE_RER_BETA;
  public double VARIABLE_RER_COMB_WEIGHT_BETA;
  public static double GLOBAL_FIXED_IRL_PROBABILITY;
  public static double GLOBAL_FIXED_IRL_COMB_WEIGHT;
  public double FIXED_IRL_PROBABILITY;
  public double FIXED_IRL_COMB_WEIGHT;
  public static double GLOBAL_VARIABLE_IRL_BETA;
  public static double GLOBAL_VARIABLE_IRL_COMB_WEIGHT_BETA;
  public double VARIABLE_IRL_BETA;
  public double VARIABLE_IRL_COMB_WEIGHT_BETA;
  public static double GLOBAL_FIXED_FR_PROBABILITY;
  public static double GLOBAL_FIXED_FR_COMB_WEIGHT;
  public double FIXED_FR_PROBABILITY;
  public double FIXED_FR_COMB_WEIGHT;
  public static double GLOBAL_VARIABLE_FR_BETA;
  public static double GLOBAL_VARIABLE_FR_COMB_WEIGHT_BETA;
  public double VARIABLE_FR_BETA;
  public double VARIABLE_FR_COMB_WEIGHT_BETA;
  public static double GLOBAL_EXTERNAL_PROBABILITY;
  public static double GLOBAL_GOAL_PROBABILITY;
  public static double GLOBAL_WM_PROBABILITY;
  public double EXTERNAL_PROBABILITY;
  public double GOAL_PROBABILITY;
  public double WM_PROBABILITY;
  public static boolean GLOBAL_PERFORM_EXTRACTION;
  public boolean PERFORM_EXTRACTION;
  public static boolean GLOBAL_PERFORM_BL_LEARNING;
  public boolean PERFORM_BL_LEARNING;
  public static boolean GLOBAL_PERFORM_REFINEMENT_RER;
  public boolean PERFORM_REFINEMENT_RER;
  public static boolean GLOBAL_PERFORM_REFINEMENT_IRL;
  public boolean PERFORM_REFINEMENT_IRL;
  public static double GLOBAL_MATCH_DISCOUNT;
  public static double MATCH_DISCOUNT;
  public clarion.system.ACS(clarion.system.CLARION);
  protected clarion.system.AbstractAction chooseAction(clarion.system.DimensionValueCollection, long);
  protected void learn(clarion.system.DimensionValueCollection, long);
  protected void learn(clarion.system.DimensionValueCollection, double, long);
  protected clarion.system.AbstractAction getChosenAction();
  protected void resetChosenAction();
  public java.util.Collection<clarion.system.AbstractImplicitModule> getBLImplicitModules();
  public clarion.system.ImplicitModuleCollection getBLImplicitModuleStore();
  public clarion.system.ActionCollection getPossibleActions();
  public java.util.Collection<clarion.system.AbstractRule> getRERRules();
  public clarion.system.RuleCollection getRERRuleStore();
  public java.util.Collection<clarion.system.AbstractRule> getIRLRules();
  public clarion.system.RuleCollection getIRLRuleStore();
  public java.util.Collection<clarion.system.AbstractRule> getFixedRules();
  public clarion.system.RuleCollection getFixedRuleStore();
  public void addAction(clarion.system.AbstractAction);
  public void addActions(java.util.Collection<? extends clarion.system.AbstractAction>);
  public void addBLModule(clarion.system.AbstractImplicitModule) throws java.lang.IllegalArgumentException;
  public void addBLModules(java.util.Collection<? extends clarion.system.AbstractImplicitModule>);
  public void addRule(clarion.system.AbstractRule);
  public void addRules(java.util.Collection<? extends clarion.system.AbstractRule>);
  protected void endEpisode(clarion.system.DimensionValueCollection, long);
  protected void attachSelfToAgent(clarion.system.CLARION);
  protected void updateInputSpace(java.util.Collection<clarion.system.Dimension>);
  static {};
}
Compiled from "ACS.java"
public final class clarion.system.ACS$LevelSelectionMethods extends java.lang.Enum<clarion.system.ACS$LevelSelectionMethods> {
  public static final clarion.system.ACS$LevelSelectionMethods STOCHASTIC;
  public static final clarion.system.ACS$LevelSelectionMethods COMBINED;
  public static clarion.system.ACS$LevelSelectionMethods[] values();
  public static clarion.system.ACS$LevelSelectionMethods valueOf(java.lang.String);
  static {};
}
Compiled from "ACS.java"
public final class clarion.system.ACS$LevelSelectionOptions extends java.lang.Enum<clarion.system.ACS$LevelSelectionOptions> {
  public static final clarion.system.ACS$LevelSelectionOptions FIXED;
  public static final clarion.system.ACS$LevelSelectionOptions VARIABLE;
  public static clarion.system.ACS$LevelSelectionOptions[] values();
  public static clarion.system.ACS$LevelSelectionOptions valueOf(java.lang.String);
  static {};
}
Compiled from "ACS.java"
final class clarion.system.ACS$ModuleTypes extends java.lang.Enum<clarion.system.ACS$ModuleTypes> {
  public static final clarion.system.ACS$ModuleTypes BL;
  public static final clarion.system.ACS$ModuleTypes RER;
  public static final clarion.system.ACS$ModuleTypes IRL;
  public static final clarion.system.ACS$ModuleTypes FR;
  public static final clarion.system.ACS$ModuleTypes ALL;
  public static clarion.system.ACS$ModuleTypes[] values();
  public static clarion.system.ACS$ModuleTypes valueOf(java.lang.String);
  static {};
}
Compiled from "AbstractAction.java"
public abstract class clarion.system.AbstractAction extends clarion.system.AbstractOutputChunk {
  public clarion.system.AbstractAction(java.lang.Object);
  public clarion.system.AbstractAction(java.lang.Object, java.util.Collection<? extends clarion.system.Dimension>);
  public clarion.system.AbstractAction(java.lang.Object, java.util.Map<? extends java.lang.Object, ? extends clarion.system.Dimension>);
  public clarion.system.Dimension put(java.lang.Object, clarion.system.Dimension) throws java.lang.IllegalArgumentException;
  public void putAll(java.util.Map<? extends java.lang.Object, ? extends clarion.system.Dimension>);
  public abstract clarion.system.AbstractAction clone();
  public clarion.system.AbstractChunk clone();
  public clarion.system.DimensionValueCollection clone();
  public java.lang.Object put(java.lang.Object, java.lang.Object);
  public java.lang.Object clone();
}
Compiled from "AbstractChunk.java"
public abstract class clarion.system.AbstractChunk extends clarion.system.DimensionValueCollection {
  protected java.lang.Object ID;
  public static double GLOBAL_INITIAL_BLA;
  public static double GLOBAL_C;
  public static double GLOBAL_D;
  public double INITIAL_BLA;
  public double C;
  public double D;
  protected clarion.system.TimeStampCollection T;
  protected java.lang.Long LatestTimeStamp;
  public clarion.system.AbstractChunk(java.lang.Object);
  public clarion.system.AbstractChunk(java.lang.Object, java.util.Collection<? extends clarion.system.Dimension>);
  public clarion.system.AbstractChunk(java.lang.Object, java.util.Map<? extends java.lang.Object, ? extends clarion.system.Dimension>);
  public java.lang.Object getID();
  public double getBLA(long);
  public double getNormalizedBLA(long);
  public void addTimeStamp(long);
  public java.lang.Long getLatestTimeStamp();
  public boolean equalsID(java.lang.Object);
  public boolean equals(java.lang.Object);
  public abstract clarion.system.AbstractChunk clone();
  public java.lang.String toString();
  public clarion.system.DimensionValueCollection clone();
  public java.lang.Object clone();
  static {};
}
Compiled from "AbstractChunkCollection.java"
public abstract class clarion.system.AbstractChunkCollection<C extends clarion.system.AbstractChunk> extends java.util.LinkedHashMap<java.lang.Object, C> {
  public clarion.system.AbstractChunkCollection();
  public clarion.system.AbstractChunkCollection(java.util.Collection<? extends C>);
  public clarion.system.AbstractChunkCollection(java.util.Map<? extends java.lang.Object, ? extends C>);
  public C put(java.lang.Object, C) throws java.lang.IllegalArgumentException;
  public void putAll(java.util.Map<? extends java.lang.Object, ? extends C>);
  public abstract clarion.system.DimensionValueCollection toDimensionValueCollection();
  public abstract boolean equals(java.lang.Object);
  public abstract boolean containsKeys(java.lang.Object);
  public java.lang.Object put(java.lang.Object, java.lang.Object);
}
Compiled from "AbstractExplicitModule.java"
public abstract class clarion.system.AbstractExplicitModule {
  public static double GLOBAL_INITIAL_BLA;
  public double INITIAL_BLA;
  protected clarion.system.TimeStampCollection T;
  protected java.lang.Long LatestTimeStamp;
  public static double GLOBAL_C;
  public static double GLOBAL_D;
  public static double GLOBAL_WEIGHT;
  public double C;
  public double D;
  public double WEIGHT;
  public static double GLOBAL_PERCEPTION_TIME;
  public double PERCEPTION_TIME;
  public static double GLOBAL_DECISION_TIME;
  public double DECISION_TIME;
  public static double GLOBAL_ACTUATION_TIME;
  public double ACTUATION_TIME;
  public static boolean GLOBAL_DEFAULT_ELIGIBILITY;
  public boolean DEFAULT_ELIGIBILITY;
  public clarion.system.AbstractExplicitModule();
  public double getBLA(long);
  public double getNormalizedBLA(long);
  public void addTimeStamp(long);
  public java.lang.Long getLatestTimeStamp();
  public double getResponseTime();
  public boolean checkEligibility();
  public boolean checkEligibility(long);
  public abstract double getUtility();
  public abstract double getSupport(clarion.system.DimensionValueCollection);
  public abstract boolean equals(java.lang.Object);
  static {};
}
Compiled from "AbstractFixedRule.java"
public abstract class clarion.system.AbstractFixedRule extends clarion.system.AbstractRule {
  public static double GLOBAL_DEFAULT_UTILITY;
  public double DEFAULT_UTILITY;
  public clarion.system.AbstractFixedRule(clarion.system.AbstractAction);
  public clarion.system.AbstractFixedRule(clarion.system.GeneralizedConditionChunk, clarion.system.AbstractAction);
  public abstract double getSupport(clarion.system.DimensionValueCollection);
  public double getUtility();
  public abstract boolean equals(java.lang.Object);
  public abstract boolean covers(java.lang.Object);
  static {};
}
Compiled from "AbstractIRLRule.java"
public abstract class clarion.system.AbstractIRLRule extends clarion.system.RefineableRule {
  public clarion.system.AbstractIRLRule(clarion.system.GeneralizedConditionChunk, clarion.system.AbstractAction);
  public abstract double getSupport(clarion.system.DimensionValueCollection);
}
Compiled from "AbstractImplicitModule.java"
public abstract class clarion.system.AbstractImplicitModule {
  protected clarion.system.DimensionValueCollection InputAsCollection;
  protected clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk> Output;
  protected clarion.system.AbstractOutputChunk ChosenOutput;
  public static double GLOBAL_PERCEPTION_TIME;
  public double PERCEPTION_TIME;
  public static double GLOBAL_DECISION_TIME;
  public double DECISION_TIME;
  public static double GLOBAL_ACTUATION_TIME;
  public double ACTUATION_TIME;
  public static boolean GLOBAL_DEFAULT_ELIGIBILITY;
  public boolean DEFAULT_ELIGIBILITY;
  public clarion.system.AbstractImplicitModule(java.util.Collection<clarion.system.Dimension>, clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk>) throws clarion.system.InvalidFormatException;
  public java.util.Collection<clarion.system.Dimension> getInput();
  public void setInput(clarion.system.DimensionValueCollection);
  public void setInput(clarion.system.Value);
  public void setInput(java.lang.Object, clarion.system.Value);
  public int getNumInput();
  public int getNumOutput();
  public clarion.system.AbstractOutputChunk getOutput(java.lang.Object);
  public java.util.Collection<? extends clarion.system.AbstractOutputChunk> getOutput();
  public clarion.system.AbstractOutputChunk getChosenOutput();
  public void setChosenOutput(clarion.system.AbstractOutputChunk);
  public double getResponseTime();
  public boolean checkEligibility();
  public boolean checkEligibility(long);
  public abstract void forwardPass();
  static {};
}
Compiled from "AbstractIntermediateModule.java"
public abstract class clarion.system.AbstractIntermediateModule<K extends java.lang.Enum<K>, V> extends java.util.HashMap<java.lang.Long, java.util.EnumMap<K, V>> {
  protected clarion.system.DimensionValueCollection InputSpace;
  public clarion.system.AbstractIntermediateModule(clarion.system.CLARION);
  protected abstract void attachSelfToAgent(clarion.system.CLARION);
  protected void updateInputSpace(java.util.Collection<clarion.system.Dimension>);
  public abstract void add(V, java.lang.Long, K);
  public abstract V remove(java.lang.Long);
  public abstract void remove(V, K);
  public abstract V get(java.lang.Long);
  public abstract V get(java.lang.Long, K);
  public abstract java.util.Collection<V> get(K);
  public abstract java.util.Collection<? extends V> getAll();
}
Compiled from "AbstractMatchCalculator.java"
public abstract class clarion.system.AbstractMatchCalculator {
  public clarion.system.AbstractMatchCalculator();
  public abstract boolean isPositive(double, double);
}
Compiled from "AbstractMetaCognitiveModule.java"
public abstract class clarion.system.AbstractMetaCognitiveModule {
  protected clarion.system.AbstractImplicitModule ImplicitModule;
  public static boolean GLOBAL_DEFAULT_ELIGIBILITY;
  public boolean DEFAULT_ELIGIBILITY;
  public clarion.system.AbstractMetaCognitiveModule(clarion.system.AbstractImplicitModule);
  public abstract void performMetaCognition(clarion.system.DimensionValueCollection, long);
  public clarion.system.AbstractImplicitModule getImplicitModule();
  public boolean checkEligibility();
  public boolean checkEligibility(long);
  static {};
}
Compiled from "AbstractNeuralNet.java"
public abstract class clarion.system.AbstractNeuralNet extends clarion.system.AbstractTrainableImplicitModule {
  protected java.util.ArrayList<java.lang.Double> Hidden;
  protected java.util.ArrayList<java.lang.Double> HiddenThresholds;
  protected java.util.ArrayList<java.lang.Double> OutputThresholds;
  protected java.util.ArrayList<java.util.ArrayList<java.lang.Double>> InputToHiddenWeights;
  protected java.util.ArrayList<java.util.ArrayList<java.lang.Double>> HiddenToOutputWeights;
  public static double GLOBAL_UPPER_INIT_WEIGHT;
  public static double GLOBAL_LOWER_INIT_WEIGHT;
  public static double GLOBAL_UPPER_INIT_THRESHOLD;
  public static double GLOBAL_LOWER_INIT_THRESHOLD;
  public double UPPER_INIT_WEIGHT;
  public double LOWER_INIT_WEIGHT;
  public double UPPER_INIT_THRESHOLD;
  public double LOWER_INIT_THRESHOLD;
  public clarion.system.AbstractNeuralNet(java.util.Collection<clarion.system.Dimension>, int, clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk>);
  public int getNumHidden();
  public java.util.List<java.util.List<java.lang.Double>> getItoHWeightMatrix();
  public java.util.List<java.util.List<java.lang.Double>> getHtoOWeightMatrix();
  public java.util.List<java.lang.Double> getHiddenThresholds();
  public java.util.List<java.lang.Double> getOutputThresholds();
  public void hardcodeWeights(java.util.List<? extends java.util.List<java.lang.Double>>, java.util.List<? extends java.util.List<java.lang.Double>>, java.util.List<java.lang.Double>, java.util.Collection<java.lang.Double>);
  public void forwardPass();
  protected abstract void computeHiddenActivation();
  protected abstract void computeOutputActivation();
  protected abstract void modifyHiddenToOutput();
  protected abstract void modifyInputToHidden();
  public abstract void backwardPass();
  static {};
}
Compiled from "AbstractOutputChunk.java"
public abstract class clarion.system.AbstractOutputChunk extends clarion.system.AbstractChunk implements clarion.system.InterfaceTracksTime,clarion.system.InterfaceStochasticallySelectable {
  public static double GLOBAL_FINAL_SELECTION_MEASURE_EPSILON;
  public static double GLOBAL_MINIMUM_ACTIVATION_THRESHOLD;
  public double MINIMUM_ACTIVATION_THRESHOLD;
  public static double GLOBAL_FULL_ACTIVATION_LEVEL;
  public double FULL_ACTIVATION_LEVEL;
  public static double GLOBAL_PERSISTENCE;
  public double PERSISTENCE;
  public clarion.system.AbstractOutputChunk(java.lang.Object);
  public clarion.system.AbstractOutputChunk(java.lang.Object, java.util.Collection<? extends clarion.system.Dimension>);
  public clarion.system.AbstractOutputChunk(java.lang.Object, java.util.Map<? extends java.lang.Object, ? extends clarion.system.Dimension>);
  public double getActivation();
  public void setActivation(double);
  public double getBLSelectionMeasure();
  public void setBLSelectionMeasure(double);
  public double getTLSelectionMeasure();
  public void setTLSelectionMeasure(double);
  public double getFinalSelectionMeasure();
  public void setFinalSelectionMeasure(double);
  public void resetActivation();
  public double adjustSelectionMeasure(double, double);
  public boolean equals(java.lang.Object);
  public int compareTo(clarion.system.InterfaceStochasticallySelectable);
  public int compareTo(java.lang.Object);
  static {};
}
Compiled from "AbstractOutputChunkCollection.java"
public abstract class clarion.system.AbstractOutputChunkCollection<C extends clarion.system.AbstractOutputChunk> extends clarion.system.AbstractChunkCollection<C> {
  public clarion.system.AbstractOutputChunkCollection();
  public clarion.system.AbstractOutputChunkCollection(java.util.Collection<? extends C>);
  public clarion.system.AbstractOutputChunkCollection(java.util.Map<? extends java.lang.Object, ? extends C>);
  public abstract clarion.system.AbstractOutputChunkCollection<? extends C> clone();
  public java.lang.Object clone();
}
Compiled from "AbstractRule.java"
public abstract class clarion.system.AbstractRule extends clarion.system.AbstractExplicitModule implements clarion.system.InterfaceTracksMatchStatistics,clarion.system.InterfaceHandlesFeedback,clarion.system.InterfaceTracksTime {
  protected clarion.system.GeneralizedConditionChunk rCondition;
  protected clarion.system.AbstractAction rAction;
  protected java.util.HashSet<clarion.system.AbstractRule> Children;
  protected clarion.system.DimensionValueCollection CurrentInput;
  public static double DEFAULT_PARTIAL_MATCH_OFF;
  public static double DEAFUALT_PARTIAL_MATCH_ON;
  public static double GLOBAL_PARTIAL_MATCH_THRESHOLD;
  public double PARTIAL_MATCH_THRESHOLD;
  public static double GLOBAL_SUPPORT_EPSILON;
  public static double GLOBAL_DENSITY;
  public double DENSITY;
  public static clarion.system.AbstractRule$UtilityOptions GLOBAL_UTILITY_OPTION;
  public clarion.system.AbstractRule$UtilityOptions UTILITY_OPTION;
  public static double GLOBAL_BENEFIT_CONSTANT;
  public double BENEFIT_CONSTANT;
  public static double GLOBAL_COST_CONSTANT;
  public double COST_CONSTANT;
  public static double GLOBAL_V;
  public double V;
  public static double GLOBAL_C7;
  public static double GLOBAL_C8;
  public double C7;
  public double C8;
  protected double PM;
  protected double NM;
  public static double GLOBAL_POSITIVE_MATCH_THRESHOLD;
  public double POSITIVE_MATCH_THRESHOLD;
  public static clarion.system.AbstractRule$SelectionTypes GLOBAL_SELECTION_TYPE;
  public clarion.system.AbstractRule$SelectionTypes SELECTION_TYPE;
  protected long LastMatch;
  public clarion.system.AbstractRule(clarion.system.GeneralizedConditionChunk, clarion.system.AbstractAction) throws java.lang.IllegalArgumentException;
  public double getUtility();
  public double getUtility(double);
  public double getSupport(clarion.system.DimensionValueCollection);
  public clarion.system.GeneralizedConditionChunk getCondition();
  public clarion.system.AbstractAction getAction();
  public void setCurrentInput(clarion.system.DimensionValueCollection);
  public boolean checkEligibility(long);
  public boolean checkEligibility();
  public boolean covers(clarion.system.AbstractRule);
  public boolean covers(clarion.system.GeneralizedConditionChunk, clarion.system.AbstractAction);
  public boolean equals(java.lang.Object);
  public boolean equals(clarion.system.GeneralizedConditionChunk, clarion.system.AbstractAction);
  public double getPM();
  public double getNM();
  public void setPM(double);
  public void setNM(double);
  public double getFeedback();
  public void setFeedback(double);
  public void updateMatchStatistics(clarion.system.AbstractMatchCalculator);
  public void resetMatchStatistics();
  public void incrementPM();
  public void incrementNM();
  public static void turnPartialMatchON();
  public int getNumChildren();
  public java.util.Collection<clarion.system.AbstractRule> getChildren();
  public void initChildren();
  public void resetChildren();
  public abstract clarion.system.AbstractRule clone();
  public java.lang.String toString();
  public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
  static {};
}
Compiled from "AbstractRule.java"
public final class clarion.system.AbstractRule$SelectionTypes extends java.lang.Enum<clarion.system.AbstractRule$SelectionTypes> {
  public static final clarion.system.AbstractRule$SelectionTypes SUPPORT;
  public static final clarion.system.AbstractRule$SelectionTypes UTILITY;
  public static clarion.system.AbstractRule$SelectionTypes[] values();
  public static clarion.system.AbstractRule$SelectionTypes valueOf(java.lang.String);
  static {};
}
Compiled from "AbstractRule.java"
public final class clarion.system.AbstractRule$UtilityOptions extends java.lang.Enum<clarion.system.AbstractRule$UtilityOptions> {
  public static final clarion.system.AbstractRule$UtilityOptions CONSTANT;
  public static final clarion.system.AbstractRule$UtilityOptions EQUATION;
  public static clarion.system.AbstractRule$UtilityOptions[] values();
  public static clarion.system.AbstractRule$UtilityOptions valueOf(java.lang.String);
  static {};
}
Compiled from "AbstractRuntimeTrainableBPNet.java"
public abstract class clarion.system.AbstractRuntimeTrainableBPNet extends clarion.system.BPNet implements clarion.system.InterfaceRuntimeTrainable,clarion.system.InterfaceTracksMatchStatistics {
  protected double Feedback;
  protected double PM;
  protected double NM;
  public static double GLOBAL_POSITIVE_MATCH_THRESHOLD;
  public double POSITIVE_MATCH_THRESHOLD;
  public clarion.system.AbstractRuntimeTrainableBPNet(java.util.Collection<clarion.system.Dimension>, int, clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk>) throws clarion.system.InvalidFormatException;
  public double getPM();
  public double getNM();
  public void setPM(double);
  public void setNM(double);
  public double getFeedback();
  public void setFeedback(double);
  public void updateMatchStatistics(clarion.system.AbstractMatchCalculator);
  public void resetMatchStatistics();
  public void incrementPM();
  public void incrementNM();
  static {};
}
Compiled from "AbstractRuntimeTrainableImplicitModule.java"
public abstract class clarion.system.AbstractRuntimeTrainableImplicitModule extends clarion.system.AbstractTrainableImplicitModule implements clarion.system.InterfaceRuntimeTrainable,clarion.system.InterfaceTracksMatchStatistics {
  protected double Feedback;
  protected double PM;
  protected double NM;
  public static double GLOBAL_POSITIVE_MATCH_THRESHOLD;
  public double POSITIVE_MATCH_THRESHOLD;
  public clarion.system.AbstractRuntimeTrainableImplicitModule(java.util.Collection<clarion.system.Dimension>, clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk>);
  public double getPM();
  public double getNM();
  public void setPM(double);
  public void setNM(double);
  public double getFeedback();
  public void setFeedback(double);
  public void updateMatchStatistics(clarion.system.AbstractMatchCalculator);
  public void resetMatchStatistics();
  public void incrementPM();
  public void incrementNM();
  static {};
}
Compiled from "AbstractSubsystem.java"
public abstract class clarion.system.AbstractSubsystem {
  protected clarion.system.DimensionValueCollection InputSpace;
  public clarion.system.AbstractSubsystem(clarion.system.CLARION);
  protected abstract void attachSelfToAgent(clarion.system.CLARION);
  protected abstract void endEpisode(clarion.system.DimensionValueCollection, long);
  protected void updateInputSpace(java.util.Collection<clarion.system.Dimension>);
}
Compiled from "AbstractTrainableImplicitModule.java"
public abstract class clarion.system.AbstractTrainableImplicitModule extends clarion.system.AbstractImplicitModule implements clarion.system.InterfaceTrainable {
  protected clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk> DesiredOutput;
  public clarion.system.AbstractTrainableImplicitModule(java.util.Collection<clarion.system.Dimension>, clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk>);
  public void setDesiredOutput(java.util.Collection<? extends clarion.system.AbstractOutputChunk>);
  public void setDesiredOutput(clarion.system.AbstractOutputChunk);
  public abstract void backwardPass();
  public double getSumSqErrors();
}
Compiled from "ActionCollection.java"
public class clarion.system.ActionCollection extends clarion.system.AbstractOutputChunkCollection<clarion.system.AbstractAction> {
  protected boolean USE_DO_NOTHING_EXTERNAL;
  protected boolean USE_DO_NOTHING_WM;
  protected boolean USE_DO_NOTHING_GOAL;
  public clarion.system.ActionCollection();
  public clarion.system.ActionCollection(java.util.Collection<? extends clarion.system.AbstractAction>);
  public clarion.system.ActionCollection(java.util.Map<? extends java.lang.Object, ? extends clarion.system.AbstractAction>);
  public java.util.Collection<clarion.system.AbstractAction> getExternalActions();
  public java.util.Collection<clarion.system.AbstractAction> getWMActions();
  public java.util.Collection<clarion.system.AbstractAction> getGoalActions();
  public clarion.system.DimensionValueCollection toDimensionValueCollection();
  public boolean containsKeys(java.lang.Object);
  public boolean equals(java.lang.Object);
  public int hashCode();
  public clarion.system.ActionCollection clone();
  public clarion.system.AbstractOutputChunkCollection clone();
  public java.lang.Object clone();
}
Compiled from "BPNet.java"
public class clarion.system.BPNet extends clarion.system.AbstractNeuralNet {
  public static double GLOBAL_MOMENTUM;
  public double MOMENTUM;
  public static double GLOBAL_LEARNING_RATE;
  public double LEARNING_RATE;
  public static double GLOBAL_RZERO;
  public double RZERO;
  public clarion.system.BPNet(java.util.Collection<clarion.system.Dimension>, int, clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk>);
  public void backwardPass();
  protected void computeHiddenActivation();
  protected void computeOutputActivation();
  protected void modifyHiddenToOutput();
  protected void modifyInputToHidden();
  static {};
}
Compiled from "BehavioralApproachSystem.java"
public class clarion.system.BehavioralApproachSystem extends clarion.system.DriveCollection {
  public static double GLOBAL_GAIN;
  public double GAIN;
  public clarion.system.BehavioralApproachSystem();
  public clarion.system.BehavioralApproachSystem(java.util.Collection<clarion.system.Drive>);
  static {};
}
Compiled from "BehavioralInhibitionSystem.java"
public class clarion.system.BehavioralInhibitionSystem extends clarion.system.DriveCollection {
  public static double GLOBAL_GAIN;
  public double GAIN;
  public clarion.system.BehavioralInhibitionSystem();
  public clarion.system.BehavioralInhibitionSystem(java.util.Collection<clarion.system.Drive>);
  static {};
}
Compiled from "CLARION.java"
public class clarion.system.CLARION {
  protected clarion.system.DimensionValueCollection InputSpace;
  public clarion.system.CLARION(clarion.system.DimensionValueCollection);
  public void perceive(clarion.system.DimensionValueCollection) throws clarion.system.MissingACSException;
  public void perceive(clarion.system.DimensionValueCollection, double) throws clarion.system.MissingACSException;
  public clarion.system.AbstractAction act() throws clarion.system.MissingACSException, clarion.system.MissingSensoryInformationException;
  protected void attachGoalStructure(clarion.system.GoalStructure);
  protected void attachWorkingMemory(clarion.system.WorkingMemory);
  protected void attachEpisodicMemory(clarion.system.EpisodicMemory);
  protected void attachACS(clarion.system.ACS);
  protected void attachMS(clarion.system.MS);
  protected void attachMCS(clarion.system.MCS);
  protected void attachNACS(clarion.system.NACS);
  public clarion.system.ACS getACS();
  public clarion.system.MS getMS();
  public clarion.system.MCS getMCS();
  public clarion.system.NACS getNACS();
  public clarion.system.GoalStructure getGoalStructure();
  public clarion.system.WorkingMemory getWorkingMemory();
  public clarion.system.EpisodicMemory getEpisodicMemory();
  protected clarion.system.DimensionValueCollection getInputSpace();
  public java.util.Collection<clarion.system.Dimension> getInternalInputSpace();
  public clarion.system.AbstractAction getLastAction();
  public clarion.system.Goal getCurrentGoal();
  public void resetLastAction();
  public void resetGoal();
  public long getAge();
  public long getBirthdate();
  public void endEpisode();
  protected void updateInputSpace(java.util.Collection<clarion.system.Dimension>);
}
Compiled from "DefaultMatchCalculator.java"
public class clarion.system.DefaultMatchCalculator extends clarion.system.AbstractMatchCalculator {
  public clarion.system.DefaultMatchCalculator();
  public boolean isPositive(double, double);
}
Compiled from "Dimension.java"
public final class clarion.system.Dimension extends java.util.LinkedHashMap<java.lang.Object, clarion.system.Value> implements clarion.system.InterfaceTracksTime {
  public static double GLOBAL_INITIAL_BLA;
  public static double GLOBAL_C;
  public static double GLOBAL_D;
  public double INITIAL_BLA;
  public double C;
  public double D;
  public clarion.system.Dimension(java.lang.Object);
  public clarion.system.Dimension(java.lang.Object, java.util.Collection<? extends clarion.system.Value>);
  public clarion.system.Dimension(java.lang.Object, java.util.Map<? extends java.lang.Object, ? extends clarion.system.Value>);
  public java.lang.Object getID();
  public int getNumFullyActivatedVals();
  public int getNumActivatedVals();
  public boolean checkMatchAll();
  public double getMaxActivation();
  public clarion.system.Value put(java.lang.Object, clarion.system.Value) throws java.lang.IllegalArgumentException;
  public void putAll(java.util.Map<? extends java.lang.Object, ? extends clarion.system.Value>);
  public boolean equalsID(java.lang.Object);
  public boolean equals(java.lang.Object);
  public double getBLA(long);
  public double getNormalizedBLA(long);
  public void addTimeStamp(long);
  public java.lang.Long getLatestTimeStamp();
  public int hashCode();
  public clarion.system.Dimension clone();
  public int size();
  public java.lang.String toString();
  public java.lang.Object put(java.lang.Object, java.lang.Object);
  public java.lang.Object clone();
  static {};
}
Compiled from "DimensionValueCollection.java"
public class clarion.system.DimensionValueCollection extends java.util.LinkedHashMap<java.lang.Object, clarion.system.Dimension> {
  public clarion.system.DimensionValueCollection();
  public clarion.system.DimensionValueCollection(java.util.Collection<? extends clarion.system.Dimension>);
  public clarion.system.DimensionValueCollection(java.util.Map<? extends java.lang.Object, ? extends clarion.system.Dimension>);
  public int getNumDVPairs();
  public clarion.system.Dimension put(java.lang.Object, clarion.system.Dimension) throws java.lang.IllegalArgumentException;
  public void putAll(java.util.Map<? extends java.lang.Object, ? extends clarion.system.Dimension>);
  public boolean equals(java.lang.Object);
  public boolean equalsKeys(java.lang.Object);
  public java.util.Collection<clarion.system.Value> getValueCollection();
  public int hashCode();
  public clarion.system.DimensionValueCollection clone();
  public int size();
  public java.lang.String toString();
  public java.lang.Object put(java.lang.Object, java.lang.Object);
  public java.lang.Object clone();
}
Compiled from "DimensionlessOutputChunk.java"
public class clarion.system.DimensionlessOutputChunk extends clarion.system.AbstractOutputChunk {
  public clarion.system.DimensionlessOutputChunk(java.lang.Object);
  public int hashCode();
  public clarion.system.DimensionlessOutputChunk clone();
  public clarion.system.AbstractChunk clone();
  public clarion.system.DimensionValueCollection clone();
  public java.lang.Object clone();
}
Compiled from "DimensionlessOutputChunkCollection.java"
public class clarion.system.DimensionlessOutputChunkCollection extends clarion.system.AbstractOutputChunkCollection<clarion.system.DimensionlessOutputChunk> {
  public clarion.system.DimensionlessOutputChunkCollection();
  public clarion.system.DimensionlessOutputChunkCollection(java.util.Collection<? extends clarion.system.DimensionlessOutputChunk>);
  public clarion.system.DimensionlessOutputChunkCollection(java.util.Map<? extends java.lang.Object, ? extends clarion.system.DimensionlessOutputChunk>);
  public clarion.system.DimensionValueCollection toDimensionValueCollection();
  public boolean containsKeys(java.lang.Object);
  public boolean equals(java.lang.Object);
  public int hashCode();
  public clarion.system.DimensionlessOutputChunkCollection clone();
  public clarion.system.AbstractOutputChunkCollection clone();
  public java.lang.Object clone();
}
Compiled from "Drive.java"
public class clarion.system.Drive {
  protected clarion.system.DriveStrength DS;
  public static double GLOBAL_UNIVERSAL_GAIN;
  public static double GLOBAL_DEFICIT_CHANGE_RATE;
  public double UNIVERSAL_GAIN;
  public static double GLOBAL_GAIN;
  public static double GLOBAL_BASELINE;
  public double GAIN;
  public double BASELINE;
  public clarion.system.Drive(java.lang.Object, double, clarion.system.AbstractImplicitModule) throws clarion.system.InvalidFormatException;
  public clarion.system.DriveStrength calculateDriveStrength(clarion.system.DimensionValueCollection) throws clarion.system.InvalidFormatException;
  public java.lang.Object getID();
  public clarion.system.AbstractImplicitModule getImplicitModule();
  public void setImplicitModule(clarion.system.AbstractImplicitModule) throws clarion.system.InvalidFormatException;
  public clarion.system.DriveStrength getDriveStrength();
  public double getDeficit();
  public double getInitialDeficit();
  public void setDeficit(double);
  public void setDeficitChangeRate(double);
  protected void updateDeficit();
  public static clarion.system.DriveStrengthCollection generateOutput(java.lang.Object);
  public static clarion.system.DimensionValueCollection generateTypicalInput(java.lang.Object);
  public boolean equals(java.lang.Object);
  public int hashCode();
  public clarion.system.Drive clone();
  public java.lang.String toString();
  public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
  static {};
}
Compiled from "Drive.java"
public final class clarion.system.Drive$TypicalInputs extends java.lang.Enum<clarion.system.Drive$TypicalInputs> {
  public static final clarion.system.Drive$TypicalInputs DRIVE_GAIN;
  public static final clarion.system.Drive$TypicalInputs SYSTEM_GAIN;
  public static final clarion.system.Drive$TypicalInputs UNIVERSAL_GAIN;
  public static final clarion.system.Drive$TypicalInputs STIMULUS;
  public static final clarion.system.Drive$TypicalInputs DEFICIT;
  public static final clarion.system.Drive$TypicalInputs BASELINE;
  public static clarion.system.Drive$TypicalInputs[] values();
  public static clarion.system.Drive$TypicalInputs valueOf(java.lang.String);
  static {};
}
Compiled from "DriveCollection.java"
public class clarion.system.DriveCollection extends java.util.LinkedHashMap<java.lang.Object, clarion.system.Drive> {
  public clarion.system.DriveCollection();
  public clarion.system.DriveCollection(java.util.Collection<? extends clarion.system.Drive>);
  public clarion.system.DriveCollection(java.util.Map<? extends java.lang.Object, ? extends clarion.system.Drive>);
  public clarion.system.DriveStrengthCollection getDriveStrengths();
  public clarion.system.Drive put(java.lang.Object, clarion.system.Drive) throws java.lang.IllegalArgumentException;
  public void putAll(java.util.Map<? extends java.lang.Object, ? extends clarion.system.Drive>);
  public int size();
  public java.lang.Object put(java.lang.Object, java.lang.Object);
}
Compiled from "DriveStrength.java"
public class clarion.system.DriveStrength extends clarion.system.DimensionlessOutputChunk {
  public clarion.system.DriveStrength(java.lang.Object);
  public int hashCode();
  public clarion.system.DriveStrength clone();
  public java.lang.String toString();
  public clarion.system.DimensionlessOutputChunk clone();
  public clarion.system.AbstractChunk clone();
  public clarion.system.DimensionValueCollection clone();
  public java.lang.Object clone();
}
Compiled from "DriveStrengthCollection.java"
public class clarion.system.DriveStrengthCollection extends clarion.system.AbstractOutputChunkCollection<clarion.system.DriveStrength> {
  public clarion.system.DriveStrengthCollection();
  public clarion.system.DriveStrengthCollection(java.util.Collection<? extends clarion.system.DriveStrength>);
  public clarion.system.DriveStrengthCollection(java.util.Map<? extends java.lang.Object, ? extends clarion.system.DriveStrength>);
  public clarion.system.DimensionValueCollection toDimensionValueCollection();
  public boolean containsKeys(java.lang.Object);
  public boolean equals(java.lang.Object);
  public int hashCode();
  public clarion.system.DriveStrengthCollection clone();
  public clarion.system.AbstractOutputChunkCollection clone();
  public java.lang.Object clone();
}
Compiled from "EpisodicMemory.java"
public class clarion.system.EpisodicMemory extends clarion.system.AbstractIntermediateModule<clarion.system.EpisodicMemory$InfoStored, clarion.system.DimensionValueCollection> {
  public static int GLOBAL_CAPACITY;
  public int CAPACITY;
  public clarion.system.EpisodicMemory(clarion.system.CLARION);
  public clarion.system.DimensionValueCollection get(java.lang.Long);
  public clarion.system.DimensionValueCollection get(java.lang.Long, clarion.system.EpisodicMemory$InfoStored);
  public java.util.Collection<clarion.system.DimensionValueCollection> get(clarion.system.EpisodicMemory$InfoStored);
  public clarion.system.AbstractAction getPerformedAction(java.lang.Long);
  public double getFeedback(java.lang.Long);
  public java.util.Collection<? extends clarion.system.DimensionValueCollection> getAll();
  public clarion.system.DimensionValueCollection getAllAsDimensionValueCollection();
  public void add(clarion.system.DimensionValueCollection, java.lang.Long, clarion.system.EpisodicMemory$InfoStored);
  public void addFeedback(double, java.lang.Long);
  public clarion.system.DimensionValueCollection remove(java.lang.Long);
  public void remove(clarion.system.DimensionValueCollection, clarion.system.EpisodicMemory$InfoStored);
  protected void attachSelfToAgent(clarion.system.CLARION);
  public java.util.Collection get(java.lang.Enum);
  public java.lang.Object get(java.lang.Long, java.lang.Enum);
  public java.lang.Object get(java.lang.Long);
  public void remove(java.lang.Object, java.lang.Enum);
  public java.lang.Object remove(java.lang.Long);
  public void add(java.lang.Object, java.lang.Long, java.lang.Enum);
  static {};
}
Compiled from "EpisodicMemory.java"
class clarion.system.EpisodicMemory$1 {
  static final int[] $SwitchMap$clarion$system$EpisodicMemory$InfoStored;
  static {};
}
Compiled from "EpisodicMemory.java"
public final class clarion.system.EpisodicMemory$InfoStored extends java.lang.Enum<clarion.system.EpisodicMemory$InfoStored> {
  public static final clarion.system.EpisodicMemory$InfoStored CURRENT_STATE;
  public static final clarion.system.EpisodicMemory$InfoStored PERFORMED_ACTION;
  public static final clarion.system.EpisodicMemory$InfoStored FEEDBACK;
  public static final clarion.system.EpisodicMemory$InfoStored NEW_STATE;
  public static clarion.system.EpisodicMemory$InfoStored[] values();
  public static clarion.system.EpisodicMemory$InfoStored valueOf(java.lang.String);
  static {};
}
Compiled from "ExternalAction.java"
public class clarion.system.ExternalAction extends clarion.system.AbstractAction {
  public clarion.system.ExternalAction(java.lang.Object);
  public clarion.system.ExternalAction(java.lang.Object, java.util.Collection<? extends clarion.system.Dimension>);
  public clarion.system.ExternalAction(java.lang.Object, java.util.Map<? extends java.lang.Object, ? extends clarion.system.Dimension>);
  public int hashCode();
  public clarion.system.ExternalAction clone();
  public clarion.system.AbstractAction clone();
  public clarion.system.AbstractChunk clone();
  public clarion.system.DimensionValueCollection clone();
  public java.lang.Object clone();
}
Compiled from "FullContainerException.java"
public class clarion.system.FullContainerException extends java.lang.RuntimeException {
  public clarion.system.FullContainerException(java.lang.String);
  public clarion.system.FullContainerException();
}
Compiled from "GeneralizedConditionChunk.java"
public class clarion.system.GeneralizedConditionChunk extends clarion.system.DimensionValueCollection {
  public clarion.system.GeneralizedConditionChunk();
  public clarion.system.GeneralizedConditionChunk(java.util.Collection<? extends clarion.system.Dimension>);
  public clarion.system.GeneralizedConditionChunk(java.util.Map<? extends java.lang.Object, ? extends clarion.system.Dimension>);
  public double getWeight();
  public double getStrength(java.util.Collection<? extends clarion.system.Dimension>);
  public boolean covers(clarion.system.GeneralizedConditionChunk);
  public boolean checkMatchAll();
  public int hashCode();
  public clarion.system.GeneralizedConditionChunk clone();
  public clarion.system.DimensionValueCollection clone();
  public java.lang.Object clone();
}
Compiled from "GenericChunkCollection.java"
public class clarion.system.GenericChunkCollection extends clarion.system.AbstractChunkCollection<clarion.system.AbstractChunk> {
  public clarion.system.GenericChunkCollection();
  public clarion.system.GenericChunkCollection(java.util.Collection<? extends clarion.system.AbstractChunk>);
  public clarion.system.GenericChunkCollection(java.util.Map<? extends java.lang.Object, ? extends clarion.system.AbstractChunk>);
  public clarion.system.DimensionValueCollection toDimensionValueCollection();
  public boolean containsKeys(java.lang.Object);
  public boolean equals(java.lang.Object);
  public int hashCode();
  public clarion.system.GenericChunkCollection clone();
  public java.lang.Object clone();
}
Compiled from "GenericStochasticObject.java"
public class clarion.system.GenericStochasticObject implements clarion.system.InterfaceStochasticallySelectable {
  public static double GLOBAL_FINAL_SELECTION_MEASURE_EPSILON;
  public clarion.system.GenericStochasticObject(double);
  public void setFinalSelectionMeasure(double);
  public double getFinalSelectionMeasure();
  public int compareTo(clarion.system.InterfaceStochasticallySelectable);
  public boolean equals(java.lang.Object);
  public int compareTo(java.lang.Object);
  static {};
}
Compiled from "Goal.java"
public class clarion.system.Goal extends clarion.system.AbstractOutputChunk {
  public clarion.system.Goal(java.lang.Object);
  public clarion.system.Goal(java.lang.Object, java.util.Collection<? extends clarion.system.Dimension>);
  public clarion.system.Goal(java.lang.Object, java.util.Map<? extends java.lang.Object, ? extends clarion.system.Dimension>);
  public clarion.system.Dimension put(java.lang.Object, clarion.system.Dimension) throws java.lang.IllegalArgumentException;
  public void putAll(java.util.Map<? extends java.lang.Object, ? extends clarion.system.Dimension>);
  public clarion.system.Value getRelevance(java.lang.Object);
  public void setRelevances(java.util.Collection<clarion.system.Value>);
  public java.util.Collection<clarion.system.Goal> getSubGoals();
  public void setSubGoals(java.util.Collection<clarion.system.Goal>);
  public void activateGoal();
  public void deactivateGoal();
  public int hashCode();
  public clarion.system.Goal clone();
  public clarion.system.AbstractChunk clone();
  public clarion.system.DimensionValueCollection clone();
  public java.lang.Object put(java.lang.Object, java.lang.Object);
  public java.lang.Object clone();
}
Compiled from "GoalAction.java"
public class clarion.system.GoalAction extends clarion.system.AbstractAction {
  public clarion.system.GoalAction(java.lang.Object);
  public clarion.system.GoalAction(java.lang.Object, java.util.Collection<? extends clarion.system.Dimension>);
  public clarion.system.GoalAction(java.lang.Object, java.util.Map<? extends java.lang.Object, ? extends clarion.system.Dimension>);
  public int hashCode();
  public clarion.system.GoalAction clone();
  public clarion.system.AbstractAction clone();
  public clarion.system.AbstractChunk clone();
  public clarion.system.DimensionValueCollection clone();
  public java.lang.Object clone();
}
Compiled from "GoalCollection.java"
public class clarion.system.GoalCollection extends clarion.system.AbstractOutputChunkCollection<clarion.system.Goal> {
  public clarion.system.GoalCollection();
  public clarion.system.GoalCollection(java.util.Collection<? extends clarion.system.Goal>);
  public clarion.system.GoalCollection(java.util.Map<? extends java.lang.Object, ? extends clarion.system.Goal>);
  public clarion.system.DimensionValueCollection toDimensionValueCollection();
  public boolean containsKeys(java.lang.Object);
  public boolean equals(java.lang.Object);
  public int hashCode();
  public clarion.system.GoalCollection clone();
  public clarion.system.AbstractOutputChunkCollection clone();
  public java.lang.Object clone();
}
Compiled from "GoalStructure.java"
public class clarion.system.GoalStructure extends clarion.system.AbstractIntermediateModule<clarion.system.GoalStructure$InfoStored, clarion.system.Goal> {
  public static int GLOBAL_CAPACITY;
  public int CAPACITY;
  public clarion.system.GoalStructure(clarion.system.CLARION);
  public java.util.Collection<clarion.system.Goal> getAll();
  public clarion.system.Goal getCurrentGoal();
  public clarion.system.Goal get(java.lang.Long);
  public clarion.system.Goal get(java.lang.Long, clarion.system.GoalStructure$InfoStored);
  public java.util.Collection<clarion.system.Goal> get(clarion.system.GoalStructure$InfoStored);
  public void add(clarion.system.Goal, java.lang.Long) throws clarion.system.FullContainerException;
  public void add(clarion.system.Goal, java.lang.Long, clarion.system.GoalStructure$InfoStored) throws clarion.system.FullContainerException;
  public clarion.system.Goal remove(java.lang.Long);
  public void remove(clarion.system.Goal);
  public void remove(clarion.system.Goal, clarion.system.GoalStructure$InfoStored);
  public int getNumPossibleGoals();
  public clarion.system.GoalCollection getPossibleGoals();
  public boolean addPossibleGoal(clarion.system.Goal);
  public boolean addPossibleGoals(java.util.Collection<clarion.system.Goal>);
  protected void attachSelfToAgent(clarion.system.CLARION);
  public java.util.Collection get(java.lang.Enum);
  public java.lang.Object get(java.lang.Long, java.lang.Enum);
  public java.lang.Object get(java.lang.Long);
  public void remove(java.lang.Object, java.lang.Enum);
  public java.lang.Object remove(java.lang.Long);
  public void add(java.lang.Object, java.lang.Long, java.lang.Enum);
  static {};
}
Compiled from "GoalStructure.java"
public final class clarion.system.GoalStructure$InfoStored extends java.lang.Enum<clarion.system.GoalStructure$InfoStored> {
  public static final clarion.system.GoalStructure$InfoStored GOAL;
  public static clarion.system.GoalStructure$InfoStored[] values();
  public static clarion.system.GoalStructure$InfoStored valueOf(java.lang.String);
  static {};
}
Compiled from "HiddenRuleCollection.java"
public class clarion.system.HiddenRuleCollection extends java.util.HashMap<java.lang.Object, java.util.HashMap<java.lang.Object, java.util.HashMap<java.lang.Object, java.util.LinkedList<clarion.system.AbstractRule>>>> {
  public clarion.system.HiddenRuleCollection();
  public clarion.system.HiddenRuleCollection(java.util.Collection<? extends clarion.system.AbstractRule>);
  public clarion.system.AbstractRule get(clarion.system.GeneralizedConditionChunk, clarion.system.AbstractAction);
  public boolean contains(clarion.system.AbstractRule);
  public boolean add(clarion.system.AbstractRule);
  public void addAll(java.util.Collection<? extends clarion.system.AbstractRule>);
  public boolean remove(clarion.system.AbstractRule);
  public java.util.Collection<clarion.system.AbstractRule> getRules();
  public java.util.Collection<clarion.system.AbstractRule> getRules(clarion.system.AbstractAction);
  public void discountMatchStatistics(double);
  public void updateMatchStatistics(clarion.system.DimensionValueCollection, clarion.system.AbstractAction, double, clarion.system.AbstractMatchCalculator, long);
  public int size();
  public void clear();
  public java.lang.String toString();
}
Compiled from "ImplicitModuleCollection.java"
public class clarion.system.ImplicitModuleCollection extends java.util.LinkedHashSet<clarion.system.AbstractImplicitModule> implements clarion.system.InterfaceTracksMatchStatistics, clarion.system.InterfaceHandlesFeedback {
  public static double GLOBAL_MATCH_DISCOUNT;
  public static double MATCH_DISCOUNT;
  protected double PM;
  protected double NM;
  public static double GLOBAL_POSITIVE_MATCH_THRESHOLD;
  public double POSITIVE_MATCH_THRESHOLD;
  public clarion.system.ImplicitModuleCollection();
  public clarion.system.ImplicitModuleCollection(java.util.Collection<? extends clarion.system.AbstractImplicitModule>);
  public boolean add(clarion.system.AbstractImplicitModule) throws java.lang.IllegalArgumentException;
  public boolean addAll(java.util.Collection<? extends clarion.system.AbstractImplicitModule>);
  public void discountMatchStatistics();
  public double getPM();
  public double getNM();
  public void setPM(double);
  public void setNM(double);
  public double getFeedback();
  public void setFeedback(double);
  public void updateMatchStatistics(clarion.system.AbstractMatchCalculator);
  public void resetMatchStatistics();
  public void incrementPM();
  public void incrementNM();
  public boolean checkMatchCriterion();
  public boolean contains(java.lang.Object);
  public int size();
  public boolean add(java.lang.Object);
  static {};
}
Compiled from "InterfaceDeleteable.java"
public interface clarion.system.InterfaceDeleteable {
  public abstract boolean checkDeletion();
}
Compiled from "InterfaceDeleteableByDensity.java"
public interface clarion.system.InterfaceDeleteableByDensity extends clarion.system.InterfaceDeleteable {
  public abstract boolean checkDeletionByDensity(long);
}
Compiled from "InterfaceExtractsRules.java"
public interface clarion.system.InterfaceExtractsRules {
  public abstract boolean checkExtraction();
}
Compiled from "InterfaceHandlesFeedback.java"
public interface clarion.system.InterfaceHandlesFeedback {
  public abstract double getFeedback();
  public abstract void setFeedback(double);
}
Compiled from "InterfaceHandlesNewInput.java"
public interface clarion.system.InterfaceHandlesNewInput {
  public abstract java.util.Collection<clarion.system.Dimension> getNewInput();
  public abstract void setNewInput(java.util.Collection<clarion.system.Dimension>);
}
Compiled from "InterfaceHasMatchCalculator.java"
public interface clarion.system.InterfaceHasMatchCalculator {
  public abstract clarion.system.AbstractMatchCalculator getMatchCalculator();
  public abstract void setMatchCalculator(clarion.system.AbstractMatchCalculator);
}
Compiled from "InterfaceMCSRunTimes.java"
public interface clarion.system.InterfaceMCSRunTimes {
}
Compiled from "InterfaceMCSRunsAfterACS.java"
public interface clarion.system.InterfaceMCSRunsAfterACS extends clarion.system.InterfaceMCSRunTimes {
}
Compiled from "InterfaceMCSRunsAfterEarlyPerceptionStage.java"
public interface clarion.system.InterfaceMCSRunsAfterEarlyPerceptionStage extends clarion.system.InterfaceMCSRunTimes {
}
Compiled from "InterfaceMCSRunsAfterLearning.java"
public interface clarion.system.InterfaceMCSRunsAfterLearning extends clarion.system.InterfaceMCSRunTimes {
}
Compiled from "InterfaceMCSRunsAfterNACS.java"
public interface clarion.system.InterfaceMCSRunsAfterNACS extends clarion.system.InterfaceMCSRunTimes {
}
Compiled from "InterfaceMCSRunsAtEpisodeEnd.java"
public interface clarion.system.InterfaceMCSRunsAtEpisodeEnd extends clarion.system.InterfaceMCSRunTimes {
}
Compiled from "InterfaceMCSRunsAtEpisodeStart.java"
public interface clarion.system.InterfaceMCSRunsAtEpisodeStart extends clarion.system.InterfaceMCSRunTimes {
}
Compiled from "InterfaceMCSRunsAtPerception.java"
public interface clarion.system.InterfaceMCSRunsAtPerception extends clarion.system.InterfaceMCSRunTimes {
}
Compiled from "InterfaceMCSRunsBeforeACS.java"
public interface clarion.system.InterfaceMCSRunsBeforeACS extends clarion.system.InterfaceMCSRunTimes {
}
Compiled from "InterfaceMCSRunsBeforeNACS.java"
public interface clarion.system.InterfaceMCSRunsBeforeNACS extends clarion.system.InterfaceMCSRunTimes {
}
Compiled from "InterfaceRuntimeTrainable.java"
public interface clarion.system.InterfaceRuntimeTrainable extends clarion.system.InterfaceTrainable,clarion.system.InterfaceHandlesFeedback,clarion.system.InterfaceExtractsRules {
}
Compiled from "InterfaceStochasticallySelectable.java"
public interface clarion.system.InterfaceStochasticallySelectable extends java.lang.Comparable<clarion.system.InterfaceStochasticallySelectable> {
  public abstract double getFinalSelectionMeasure();
  public abstract void setFinalSelectionMeasure(double);
  public abstract boolean equals(java.lang.Object);
}
Compiled from "InterfaceTracksMatchStatistics.java"
public interface clarion.system.InterfaceTracksMatchStatistics {
  public abstract void updateMatchStatistics(clarion.system.AbstractMatchCalculator);
  public abstract double getPM();
  public abstract double getNM();
  public abstract void setPM(double);
  public abstract void setNM(double);
  public abstract void incrementPM();
  public abstract void incrementNM();
  public abstract void resetMatchStatistics();
}
Compiled from "InterfaceTracksTime.java"
public interface clarion.system.InterfaceTracksTime {
  public abstract double getBLA(long);
  public abstract double getNormalizedBLA(long);
  public abstract void addTimeStamp(long);
}
Compiled from "InterfaceTrainable.java"
public interface clarion.system.InterfaceTrainable {
  public abstract void setDesiredOutput(java.util.Collection<? extends clarion.system.AbstractOutputChunk>);
  public abstract void setDesiredOutput(clarion.system.AbstractOutputChunk);
  public abstract void backwardPass();
  public abstract double getSumSqErrors();
}
Compiled from "InterfaceUsesQLearning.java"
public interface clarion.system.InterfaceUsesQLearning extends clarion.system.InterfaceRuntimeTrainable {
  public abstract double getMaxQ();
  public abstract double getDiscount();
  public abstract clarion.system.AbstractOutputChunk getChosenOutput();
}
Compiled from "InvalidFormatException.java"
public class clarion.system.InvalidFormatException extends java.lang.RuntimeException {
  public clarion.system.InvalidFormatException(java.lang.String);
  public clarion.system.InvalidFormatException();
}
Compiled from "MCS.java"
public class clarion.system.MCS extends clarion.system.AbstractSubsystem {
  public clarion.system.MCS(clarion.system.CLARION);
  public void addModule(clarion.system.AbstractMetaCognitiveModule);
  public void addModules(java.util.Collection<? extends clarion.system.AbstractMetaCognitiveModule>);
  public java.util.Collection<clarion.system.AbstractMetaCognitiveModule> getModules();
  public java.util.Collection<clarion.system.AbstractMetaCognitiveModule> getModules(java.lang.Class<? extends clarion.system.InterfaceMCSRunTimes>);
  protected void attachSelfToAgent(clarion.system.CLARION);
  protected void endEpisode(clarion.system.DimensionValueCollection, long);
}
Compiled from "MS.java"
public final class clarion.system.MS extends clarion.system.AbstractSubsystem {
  public clarion.system.MS(clarion.system.CLARION);
  public clarion.system.DriveStrength calculateDriveStrength(java.lang.Object, clarion.system.DimensionValueCollection);
  public clarion.system.DriveStrengthCollection calculateBASDriveStrengths(clarion.system.DimensionValueCollection);
  public clarion.system.DriveStrengthCollection calculateBISDriveStrengths(clarion.system.DimensionValueCollection);
  public clarion.system.DriveStrengthCollection calculateBothDriveStrengths(clarion.system.DimensionValueCollection);
  public clarion.system.DriveStrengthCollection calculateNeitherDriveStrengths(clarion.system.DimensionValueCollection);
  public clarion.system.DriveStrengthCollection calculateAllDriveStrengths(clarion.system.DimensionValueCollection);
  public int getNumDrives();
  public clarion.system.Drive getDrive(java.lang.Object);
  public java.util.Collection<clarion.system.Drive> getAllDrives();
  public java.util.Collection<clarion.system.Drive> getBASDrives();
  public java.util.Collection<clarion.system.Drive> getBISDrives();
  public java.util.Collection<clarion.system.Drive> getBothDrives();
  public java.util.Collection<clarion.system.Drive> getNeitherDrives();
  public clarion.system.DriveStrength getDriveStrength(java.lang.Object);
  public clarion.system.DriveStrengthCollection getAllDriveStrengths();
  public clarion.system.DriveStrengthCollection getBASDriveStrengths();
  public clarion.system.DriveStrengthCollection getBISDriveStrengths();
  public clarion.system.DriveStrengthCollection getBothDriveStrengths();
  public clarion.system.DriveStrengthCollection getNeitherDriveStrengths();
  public void addDriveToBAS(clarion.system.Drive) throws java.lang.IllegalArgumentException;
  public void addDrivesToBAS(java.util.Collection<clarion.system.Drive>);
  public void addDriveToBIS(clarion.system.Drive) throws java.lang.IllegalArgumentException;
  public void addDrivesToBIS(java.util.Collection<clarion.system.Drive>);
  public void addDriveToBothSystems(clarion.system.Drive) throws java.lang.IllegalArgumentException;
  public void addDrivesToBothSystems(java.util.Collection<clarion.system.Drive>);
  public void addDriveToNeither(clarion.system.Drive) throws java.lang.IllegalArgumentException;
  public void addDrivesToNeither(java.util.Collection<clarion.system.Drive>);
  public clarion.system.BehavioralApproachSystem getBAS();
  public clarion.system.BehavioralInhibitionSystem getBIS();
  public clarion.system.NeitherBehavioralSystem getNeitherSystem();
  protected void attachSelfToAgent(clarion.system.CLARION);
  protected void endEpisode(clarion.system.DimensionValueCollection, long);
}
Compiled from "MissingACSException.java"
public class clarion.system.MissingACSException extends java.lang.RuntimeException {
  public clarion.system.MissingACSException(java.lang.String);
  public clarion.system.MissingACSException();
}
Compiled from "MissingEpisodicMemoryException.java"
public class clarion.system.MissingEpisodicMemoryException extends java.lang.RuntimeException {
  public clarion.system.MissingEpisodicMemoryException(java.lang.String);
  public clarion.system.MissingEpisodicMemoryException();
}
Compiled from "MissingGoalStructureException.java"
public class clarion.system.MissingGoalStructureException extends java.lang.RuntimeException {
  public clarion.system.MissingGoalStructureException(java.lang.String);
  public clarion.system.MissingGoalStructureException();
}
Compiled from "MissingSensoryInformationException.java"
public class clarion.system.MissingSensoryInformationException extends java.lang.RuntimeException {
  public clarion.system.MissingSensoryInformationException(java.lang.String);
  public clarion.system.MissingSensoryInformationException();
}
Compiled from "NACS.java"
public class clarion.system.NACS extends clarion.system.AbstractSubsystem {
  public clarion.system.NACS(clarion.system.CLARION);
  protected void attachSelfToAgent(clarion.system.CLARION);
  protected void endEpisode(clarion.system.DimensionValueCollection, long);
}
Compiled from "NeitherBehavioralSystem.java"
public class clarion.system.NeitherBehavioralSystem extends clarion.system.DriveCollection {
  public static double GLOBAL_GAIN;
  public double GAIN;
  public clarion.system.NeitherBehavioralSystem();
  public clarion.system.NeitherBehavioralSystem(java.util.Collection<clarion.system.Drive>);
  static {};
}
Compiled from "QBPNet.java"
public class clarion.system.QBPNet extends clarion.system.AbstractRuntimeTrainableBPNet implements clarion.system.InterfaceHandlesNewInput,clarion.system.InterfaceUsesQLearning,clarion.system.InterfaceHasMatchCalculator {
  public static double GLOBAL_DISCOUNT;
  public double DISCOUNT;
  protected clarion.system.DimensionValueCollection NewInput;
  public clarion.system.QBPNet(java.util.Collection<clarion.system.Dimension>, int, clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk>);
  public void backwardPass();
  public java.util.Collection<clarion.system.Dimension> getNewInput();
  public void setNewInput(java.util.Collection<clarion.system.Dimension>);
  public boolean checkExtraction();
  public double getMaxQ();
  public double getDiscount();
  public clarion.system.AbstractMatchCalculator getMatchCalculator();
  public void setMatchCalculator(clarion.system.AbstractMatchCalculator);
  static {};
}
Compiled from "QLearningMatchCalculator.java"
public class clarion.system.QLearningMatchCalculator extends clarion.system.AbstractMatchCalculator {
  public clarion.system.QLearningMatchCalculator(clarion.system.InterfaceUsesQLearning);
  public boolean isPositive(double, double);
}
Compiled from "RefineableRule.java"
public class clarion.system.RefineableRule extends clarion.system.AbstractRule implements clarion.system.InterfaceDeleteableByDensity {
  protected clarion.system.AbstractRule MatchAll;
  protected java.util.HashSet<clarion.system.AbstractRule> Variations;
  public clarion.system.RefineableRule(clarion.system.GeneralizedConditionChunk, clarion.system.AbstractAction);
  public int getNumVariations();
  public java.util.Collection<clarion.system.AbstractRule> getVariations();
  public void initVariations();
  public void resetVariations();
  public clarion.system.AbstractRule getMaxVariationPlusOne(clarion.system.RuleRefiner);
  public clarion.system.AbstractRule getMaxVariationMinusOne(clarion.system.RuleRefiner);
  public clarion.system.AbstractRule getMatchAll();
  public void setMatchAll(clarion.system.AbstractRule);
  public boolean checkDeletionByDensity(long);
  public boolean checkDeletion();
  public int hashCode();
  public clarion.system.RefineableRule clone();
  public clarion.system.AbstractRule clone();
  public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
}
Compiled from "RuleCollection.java"
public class clarion.system.RuleCollection extends java.util.HashMap<java.lang.Object, java.util.HashMap<java.lang.Object, java.util.HashMap<java.lang.Object, java.util.LinkedList<clarion.system.AbstractRule>>>> implements clarion.system.InterfaceTracksMatchStatistics, clarion.system.InterfaceHandlesFeedback {
  protected clarion.system.HiddenRuleCollection Variations;
  protected clarion.system.HiddenRuleCollection Children;
  protected double PM;
  protected double NM;
  public static double GLOBAL_POSITIVE_MATCH_THRESHOLD;
  public double POSITIVE_MATCH_THRESHOLD;
  public clarion.system.RuleCollection();
  public clarion.system.RuleCollection(java.util.Collection<? extends clarion.system.AbstractRule>);
  public clarion.system.AbstractRule get(clarion.system.GeneralizedConditionChunk, clarion.system.AbstractAction);
  public java.util.Collection<clarion.system.AbstractRule> getCover(clarion.system.AbstractRule);
  public boolean contains(clarion.system.AbstractRule);
  public boolean containsCover(clarion.system.AbstractRule);
  public boolean add(clarion.system.AbstractRule);
  public void addAll(java.util.Collection<? extends clarion.system.AbstractRule>);
  public boolean remove(clarion.system.AbstractRule);
  public java.util.Collection<clarion.system.AbstractRule> getRules();
  public java.util.Collection<clarion.system.AbstractRule> getRules(clarion.system.AbstractAction);
  public void discountMatchStatistics(double);
  public double getPM();
  public double getNM();
  public void setPM(double);
  public void setNM(double);
  public double getFeedback();
  public void setFeedback(double);
  public void updateMatchStatistics(clarion.system.AbstractMatchCalculator);
  public void resetMatchStatistics();
  public void incrementPM();
  public void incrementNM();
  public boolean checkMatchCriterion();
  public int size();
  public void clear();
  public int numVariations();
  public int numChildren();
  public java.util.Collection<clarion.system.AbstractRule> getVariations();
  public java.util.Collection<clarion.system.AbstractRule> getChildren();
  public java.lang.String toString();
  static {};
}
Compiled from "RuleExtractor.java"
public final class clarion.system.RuleExtractor {
  public static double GLOBAL_EXTRACTION_PROBABILITY;
  public double EXTRACTION_PROBABILITY;
  public clarion.system.RuleExtractor();
  public boolean checkExtractionCriterion(clarion.system.AbstractImplicitModule);
  public static clarion.system.AbstractRule extractRule(clarion.system.AbstractImplicitModule, clarion.system.AbstractAction);
  static {};
}
Compiled from "RuleRefiner.java"
public final class clarion.system.RuleRefiner {
  public static clarion.system.RuleRefiner$IG_OPTIONS GLOBAL_IG_OPTION;
  public clarion.system.RuleRefiner$IG_OPTIONS IG_OPTION;
  public static double GLOBAL_GENERALIZATION_THRESHOLD1;
  public double GENERALIZATION_THRESHOLD1;
  public static double GLOBAL_GENERALIZATION_THRESHOLD2;
  public double GENERALIZATION_THRESHOLD2;
  public static double GLOBAL_SPECIALIZATION_THRESHOLD1;
  public double SPECIALIZATION_THRESHOLD1;
  public static double GLOBAL_SPECIALIZATION_THRESHOLD2;
  public double SPECIALIZATION_THRESHOLD2;
  public static double GLOBAL_C1;
  public static double GLOABAL_C2;
  public double C1;
  public double C2;
  public clarion.system.RuleRefiner();
  public clarion.system.AbstractRule generalize(clarion.system.AbstractRule);
  public clarion.system.AbstractRule specialize(clarion.system.AbstractRule);
  public double calculateInformationGain(clarion.system.AbstractRule, clarion.system.AbstractRule);
  public double calculateInformationGain(clarion.system.AbstractRule);
  static {};
}
Compiled from "RuleRefiner.java"
public final class clarion.system.RuleRefiner$IG_OPTIONS extends java.lang.Enum<clarion.system.RuleRefiner$IG_OPTIONS> {
  public static final clarion.system.RuleRefiner$IG_OPTIONS MATCH_ALL;
  public static final clarion.system.RuleRefiner$IG_OPTIONS PERFECT;
  public static clarion.system.RuleRefiner$IG_OPTIONS[] values();
  public static clarion.system.RuleRefiner$IG_OPTIONS valueOf(java.lang.String);
  static {};
}
Compiled from "SettingsConflictException.java"
public class clarion.system.SettingsConflictException extends java.lang.RuntimeException {
  public clarion.system.SettingsConflictException(java.lang.String);
  public clarion.system.SettingsConflictException();
}
Compiled from "SimplifiedQBPNet.java"
public class clarion.system.SimplifiedQBPNet extends clarion.system.AbstractRuntimeTrainableBPNet {
  public clarion.system.SimplifiedQBPNet(java.util.Collection<clarion.system.Dimension>, int, clarion.system.AbstractOutputChunkCollection<? extends clarion.system.AbstractOutputChunk>);
  public void backwardPass();
  public boolean checkExtraction();
}
Compiled from "StochasticSelector.java"
public final class clarion.system.StochasticSelector {
  public static double GLOBAL_THRESHOLD;
  public double THRESHOLD;
  public static double GLOBAL_TEMPERATURE;
  public double TEMPERATURE;
  public clarion.system.StochasticSelector();
  public clarion.system.InterfaceStochasticallySelectable select(java.util.Collection<? extends clarion.system.InterfaceStochasticallySelectable>);
  public java.util.Collection<? extends clarion.system.InterfaceStochasticallySelectable> performBoltzmannDistribution(java.util.Collection<? extends clarion.system.InterfaceStochasticallySelectable>);
  public double getBoltzmannProbability(java.util.Collection<? extends clarion.system.InterfaceStochasticallySelectable>, clarion.system.InterfaceStochasticallySelectable) throws java.lang.IllegalArgumentException;
  static {};
}
Compiled from "TimeStampCollection.java"
public class clarion.system.TimeStampCollection extends java.util.LinkedList<java.lang.Long> {
  public static int GLOBAL_CAPACITY;
  public int CAPACITY;
  public clarion.system.TimeStampCollection();
  public boolean add(java.lang.Long);
  public boolean addAll(java.util.Collection<? extends java.lang.Long>);
  public clarion.system.TimeStampCollection clone();
  public java.lang.Object clone();
  public boolean add(java.lang.Object);
  static {};
}
Compiled from "Value.java"
public class clarion.system.Value implements java.lang.Cloneable, java.lang.Comparable<clarion.system.Value>, clarion.system.InterfaceTracksTime {
  protected java.lang.Object ID;
  protected int hash;
  protected double Activation;
  public static double GLOBAL_MINIMUM_ACTIVATION_THRESHOLD;
  public static double GLOBAL_FULL_ACTIVATION_THRESHOLD;
  public static double GLOBAL_ACTIVATION_EPSILON;
  public double MINIMUM_ACTIVATION_THRESHOLD;
  public double FULL_ACTIVATION_THRESHOLD;
  public static double GLOBAL_INITIAL_BLA;
  public static double GLOBAL_C;
  public static double GLOBAL_D;
  public double INITIAL_BLA;
  public double C;
  public double D;
  public clarion.system.Value(java.lang.Object);
  public clarion.system.Value(java.lang.Object, double);
  public java.lang.Object getID();
  public double getActivation();
  public void setActivation(double);
  public void resetActivation();
  public boolean isActivated();
  public boolean isFullyActivated();
  public boolean equalsID(java.lang.Object);
  public boolean equals(java.lang.Object);
  public double getBLA(long);
  public double getNormalizedBLA(long);
  public void addTimeStamp(long);
  public java.lang.Long getLatestTimeStamp();
  public int hashCode();
  public clarion.system.Value clone();
  public int compareTo(clarion.system.Value) throws java.lang.ClassCastException;
  public java.lang.String toString();
  public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
  public int compareTo(java.lang.Object);
  static {};
}
Compiled from "WorkingMemory.java"
public class clarion.system.WorkingMemory extends clarion.system.AbstractIntermediateModule<clarion.system.WorkingMemory$InfoStored, clarion.system.GenericChunkCollection> {
  public static int GLOBAL_CAPACITY;
  public int CAPACITY;
  public clarion.system.WorkingMemory(clarion.system.CLARION);
  public void add(clarion.system.AbstractChunk, java.lang.Long, clarion.system.WorkingMemory$InfoStored) throws clarion.system.FullContainerException;
  public void add(clarion.system.GenericChunkCollection, java.lang.Long, clarion.system.WorkingMemory$InfoStored);
  public clarion.system.GenericChunkCollection remove(java.lang.Long);
  public void remove(clarion.system.AbstractChunk, clarion.system.WorkingMemory$InfoStored);
  public void remove(clarion.system.GenericChunkCollection, clarion.system.WorkingMemory$InfoStored);
  public clarion.system.GenericChunkCollection get(java.lang.Long);
  public clarion.system.GenericChunkCollection get(java.lang.Long, clarion.system.WorkingMemory$InfoStored);
  public java.util.Collection<clarion.system.GenericChunkCollection> get(clarion.system.WorkingMemory$InfoStored);
  public java.util.Collection<clarion.system.GenericChunkCollection> getAll();
  public int size();
  protected void attachSelfToAgent(clarion.system.CLARION);
  public java.util.Collection get(java.lang.Enum);
  public java.lang.Object get(java.lang.Long, java.lang.Enum);
  public java.lang.Object get(java.lang.Long);
  public void remove(java.lang.Object, java.lang.Enum);
  public java.lang.Object remove(java.lang.Long);
  public void add(java.lang.Object, java.lang.Long, java.lang.Enum);
  static {};
}
Compiled from "WorkingMemory.java"
class clarion.system.WorkingMemory$1 {
  static final int[] $SwitchMap$clarion$system$WorkingMemory$InfoStored;
  static {};
}
Compiled from "WorkingMemory.java"
public final class clarion.system.WorkingMemory$InfoStored extends java.lang.Enum<clarion.system.WorkingMemory$InfoStored> {
  public static final clarion.system.WorkingMemory$InfoStored TO_NACS;
  public static final clarion.system.WorkingMemory$InfoStored FROM_NACS;
  public static final clarion.system.WorkingMemory$InfoStored GENERIC_CHUNKS;
  public static clarion.system.WorkingMemory$InfoStored[] values();
  public static clarion.system.WorkingMemory$InfoStored valueOf(java.lang.String);
  static {};
}
Compiled from "WorkingMemoryAction.java"
public class clarion.system.WorkingMemoryAction extends clarion.system.AbstractAction {
  public clarion.system.WorkingMemoryAction(java.lang.Object);
  public clarion.system.WorkingMemoryAction(java.lang.Object, java.util.Collection<? extends clarion.system.Dimension>);
  public clarion.system.WorkingMemoryAction(java.lang.Object, java.util.Map<? extends java.lang.Object, ? extends clarion.system.Dimension>);
  public int hashCode();
  public clarion.system.WorkingMemoryAction clone();
  public clarion.system.AbstractAction clone();
  public clarion.system.AbstractChunk clone();
  public clarion.system.DimensionValueCollection clone();
  public java.lang.Object clone();
}
Compiled from "BaseSimulationTemplate.java"
public interface clarion.tools.BaseSimulationTemplate {
  public abstract void initializeSensoryInformationSpace();
  public abstract void initializeAgentInternalSpace();
  public abstract void initializeCLARIONAgent(clarion.system.CLARION);
  public abstract void run(clarion.system.CLARION);
  public abstract void reportResults();
}
Compiled from "Range.java"
public class clarion.tools.Range extends clarion.system.Value {
  public static double GLOBAL_INCREMENT;
  public double INCREMENT;
  public clarion.tools.Range(java.lang.Object, double, double) throws java.lang.IllegalArgumentException;
  public double getLowerBound();
  public void setLowerBound(double) throws java.lang.IllegalArgumentException;
  public double getUpperBound();
  public void setUpperBound(double) throws java.lang.IllegalArgumentException;
  public clarion.tools.Range clone();
  public java.lang.String toString();
  public clarion.system.Value clone();
  public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
  static {};
}
Compiled from "TrainableImplicitModulePreTrainer.java"
public class clarion.tools.TrainableImplicitModulePreTrainer {
  public static int GLOBAL_NUM_TRAINING_REPEATS;
  public static double GLOBAL_SUM_SQ_ERRORS_THRESHOLD;
  public static clarion.tools.TrainableImplicitModulePreTrainer$TerminationConditions GLOBAL_TERMINATION_CONDITION;
  public int NUM_TRAINING_REPEATS;
  public double SUM_SQ_ERRORS_THRESHOLD;
  public clarion.tools.TrainableImplicitModulePreTrainer$TerminationConditions TERMINATION_CONDITION;
  public static boolean GLOBAL_PRINT_PROGRESS_TO_SYSTEM_OUT;
  public boolean PRINT_PROGRESS_TO_SYSTEM_OUT;
  public clarion.system.StochasticSelector SELECTOR;
  public clarion.tools.TrainableImplicitModulePreTrainer();
  public void trainModule(clarion.system.AbstractTrainableImplicitModule, clarion.system.AbstractImplicitModule, java.util.Collection<? extends clarion.system.DimensionValueCollection>);
  static {};
}
Compiled from "TrainableImplicitModulePreTrainer.java"
class clarion.tools.TrainableImplicitModulePreTrainer$1 {
}
Compiled from "TrainableImplicitModulePreTrainer.java"
class clarion.tools.TrainableImplicitModulePreTrainer$SumSquaredErrorTracker {
  double sumsqerr;
  int sumsqerrcounter;
  final clarion.tools.TrainableImplicitModulePreTrainer this$0;
  public double getMeanSumOfSquaredErrors();
  clarion.tools.TrainableImplicitModulePreTrainer$SumSquaredErrorTracker(clarion.tools.TrainableImplicitModulePreTrainer, clarion.tools.TrainableImplicitModulePreTrainer$1);
}
Compiled from "TrainableImplicitModulePreTrainer.java"
public final class clarion.tools.TrainableImplicitModulePreTrainer$TerminationConditions extends java.lang.Enum<clarion.tools.TrainableImplicitModulePreTrainer$TerminationConditions> {
  public static final clarion.tools.TrainableImplicitModulePreTrainer$TerminationConditions FIXED;
  public static final clarion.tools.TrainableImplicitModulePreTrainer$TerminationConditions SUM_SQ_ERROR;
  public static final clarion.tools.TrainableImplicitModulePreTrainer$TerminationConditions BOTH;
  public static clarion.tools.TrainableImplicitModulePreTrainer$TerminationConditions[] values();
  public static clarion.tools.TrainableImplicitModulePreTrainer$TerminationConditions valueOf(java.lang.String);
  static {};
}
Compiled from "Hello.java"
public class sim.Hello implements clarion.tools.BaseSimulationTemplate {
  public clarion.system.DimensionValueCollection SensoryInputSpace;
  public clarion.system.DimensionValueCollection CombinedInputSpace;
  public clarion.system.ActionCollection Actions;
  public clarion.system.CLARION Agent;
  public clarion.system.GoalCollection Goals;
  public int CorrectCounter;
  public int NumberTrials;
  public sim.Hello();
  public static void main(java.lang.String[]);
  public void initializeSensoryInformationSpace();
  public void initializeAgentInternalSpace();
  public void initializeCLARIONAgent(clarion.system.CLARION);
  public void run(clarion.system.CLARION);
  public void reportResults();
  public void updateDeficit(clarion.system.CLARION, clarion.system.AbstractAction);
}
