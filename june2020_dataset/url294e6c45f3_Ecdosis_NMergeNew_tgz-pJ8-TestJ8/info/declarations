Compiled from "Commands.java"
public final class Commands extends java.lang.Enum<Commands> {
  public static final Commands ADD;
  public static final Commands ARCHIVE;
  public static final Commands COMPARE;
  public static final Commands CREATE;
  public static final Commands DELETE;
  public static final Commands DESCRIPTION;
  public static final Commands EXPORT;
  public static final Commands FIND;
  public static final Commands HELP;
  public static final Commands IMPORT;
  public static final Commands LIST;
  public static final Commands READ;
  public static final Commands UNARCHIVE;
  public static final Commands UPDATE;
  public static final Commands USAGE;
  public static final Commands VARIANTS;
  public static final Commands TREE;
  public static final Commands WORDS;
  public static Commands[] values();
  public static Commands valueOf(java.lang.String);
  static {};
}
Compiled from "EmptyOutputStream.java"
public class EmptyOutputStream extends java.io.OutputStream {
  int received;
  public EmptyOutputStream();
  public int printedBytes();
  public void close();
  public void clear();
  public void flush();
  public void write(byte[]);
  public void write(byte[], int, int);
  public void write(int);
}
Compiled from "KMPSearch.java"
public class KMPSearch {
  static int n;
  public KMPSearch();
  public static int search(byte[], int, byte[]);
  static {};
}
Compiled from "MvdTool.java"
public class MvdTool {
  static int backup;
  static Commands command;
  static java.lang.String description;
  static java.lang.String encoding;
  static java.lang.String findString;
  static java.lang.String groupName;
  static int variantLen;
  static java.lang.String longName;
  static java.lang.String mvdFile;
  static java.lang.String archiveName;
  static int fromOffset;
  static boolean partial;
  static java.lang.String shortName;
  static java.lang.String textFile;
  static short version;
  static short with;
  static java.lang.String dbConn;
  static java.lang.String xmlFile;
  static java.lang.String helpCommand;
  static final java.lang.String ALPHABET;
  static byte[] BREAK_BEFORE;
  static byte[] BREAK_AFTER;
  static java.io.PrintStream out;
  static edu.luc.nmerge.mvd.ChunkState uniqueState;
  static int folderId;
  static boolean mergeSharedVersions;
  static boolean directAlignOnly;
  static final byte[] UTF8_BOM;
  public MvdTool();
  public static void main(java.lang.String[]);
  static boolean testJavaVersion();
  static edu.luc.nmerge.mvd.MVD loadMVD() throws java.lang.Exception;
  public static void run(java.lang.String[], java.io.PrintStream) throws edu.luc.nmerge.exception.MVDException;
  static {};
}
Compiled from "MvdTool.java"
class MvdTool$1 {
  static final int[] $SwitchMap$Commands;
  static {};
}
Compiled from "Test.java"
public class Test {
  static boolean printStackTrace;
  static int testsPassed;
  static int testsFailed;
  static java.io.PrintStream out;
  static EmptyOutputStream emptyStream;
  static java.lang.String TEST_FOLDER;
  static java.lang.String TEST_DATA;
  static java.lang.String TEMP_OUT;
  static java.lang.String BLESSED_DAMOZEL;
  static java.lang.String RENAISSANCE;
  static java.util.HashSet<java.lang.String> testMVDs;
  public Test();
  public static void main(java.lang.String[]);
  static void testHelpCommand(java.lang.String[]) throws edu.luc.nmerge.exception.MVDException;
  static {};
}
Compiled from "Utilities.java"
public class edu.luc.nmerge.Utilities {
  public edu.luc.nmerge.Utilities();
  public static java.util.Properties loadDBProperties(java.lang.String);
  public static char[] bytesToChars(byte[], java.lang.String);
}
Compiled from "MVDException.java"
public class edu.luc.nmerge.exception.MVDException extends java.lang.Exception {
  static final long serialVersionUID;
  public edu.luc.nmerge.exception.MVDException(java.lang.Exception);
  public edu.luc.nmerge.exception.MVDException(java.lang.String);
}
Compiled from "MVDTestException.java"
public class edu.luc.nmerge.exception.MVDTestException extends edu.luc.nmerge.exception.MVDException {
  static final long serialVersionUID;
  public edu.luc.nmerge.exception.MVDTestException(java.lang.Exception);
  public edu.luc.nmerge.exception.MVDTestException(java.lang.String);
}
Compiled from "MVDToolException.java"
public class edu.luc.nmerge.exception.MVDToolException extends edu.luc.nmerge.exception.MVDException {
  static final long serialVersionUID;
  public edu.luc.nmerge.exception.MVDToolException(java.lang.Exception);
  public edu.luc.nmerge.exception.MVDToolException(java.lang.String);
}
Compiled from "FastME.java"
public class edu.luc.nmerge.fastme.FastME {
  double[][] D;
  double[][] A;
  int numSpecies;
  edu.luc.nmerge.fastme.set species;
  edu.luc.nmerge.fastme.balance btype;
  edu.luc.nmerge.fastme.balance ntype;
  edu.luc.nmerge.fastme.balance wtype;
  public edu.luc.nmerge.fastme.tree T;
  public edu.luc.nmerge.fastme.FastME();
  void setBalance(edu.luc.nmerge.fastme.balance);
  void parseRow(int, int, java.lang.String);
  void initDoubleMatrix(int);
  public void buildTree(double[][], java.lang.String[]);
  public void refineTree() throws java.lang.Exception;
}
Compiled from "FastME.java"
class edu.luc.nmerge.fastme.FastME$1 {
  static final int[] $SwitchMap$edu$luc$nmerge$fastme$balance;
  static {};
}
Compiled from "balance.java"
public final class edu.luc.nmerge.fastme.balance extends java.lang.Enum<edu.luc.nmerge.fastme.balance> {
  public static final edu.luc.nmerge.fastme.balance OLS;
  public static final edu.luc.nmerge.fastme.balance BAL;
  public static final edu.luc.nmerge.fastme.balance NONE;
  public static edu.luc.nmerge.fastme.balance[] values();
  public static edu.luc.nmerge.fastme.balance valueOf(java.lang.String);
  static {};
}
Compiled from "direction.java"
public final class edu.luc.nmerge.fastme.direction extends java.lang.Enum<edu.luc.nmerge.fastme.direction> {
  public static final edu.luc.nmerge.fastme.direction NONE;
  public static final edu.luc.nmerge.fastme.direction UP;
  public static final edu.luc.nmerge.fastme.direction DOWN;
  public static final edu.luc.nmerge.fastme.direction LEFT;
  public static final edu.luc.nmerge.fastme.direction RIGHT;
  public static final edu.luc.nmerge.fastme.direction SKEW;
  public static edu.luc.nmerge.fastme.direction[] values();
  public static edu.luc.nmerge.fastme.direction valueOf(java.lang.String);
  static {};
}
Compiled from "edge.java"
public class edu.luc.nmerge.fastme.edge {
  java.lang.String label;
  edu.luc.nmerge.fastme.node tail;
  edu.luc.nmerge.fastme.node head;
  int bottomsize;
  int topsize;
  double distance;
  double totalweight;
  edu.luc.nmerge.fastme.edge(java.lang.String, edu.luc.nmerge.fastme.node, edu.luc.nmerge.fastme.node, double);
  edu.luc.nmerge.fastme.edge findBottomLeft();
  edu.luc.nmerge.fastme.edge moveUpRight();
  edu.luc.nmerge.fastme.edge moveRight();
  edu.luc.nmerge.fastme.edge siblingEdge();
  void updateSizes(edu.luc.nmerge.fastme.direction);
  void assignBottomsize();
  void assignTopsize(int);
  void OLSext(double[][]);
  double wf(double, double, double, double, double, double, double);
  void OLSint(double[][]);
  void WFext(double[][]);
  void WFint(double[][]);
  void BalWFext(double[][]);
  void BalWFint(double[][]);
}
Compiled from "edge.java"
class edu.luc.nmerge.fastme.edge$1 {
  static final int[] $SwitchMap$edu$luc$nmerge$fastme$direction;
  static {};
}
Compiled from "heap.java"
public class edu.luc.nmerge.fastme.heap {
  int[] p;
  edu.luc.nmerge.fastme.heap(int);
  int makeThreshHeap(edu.luc.nmerge.fastme.heap, double[], int, double);
  void pushHeap(edu.luc.nmerge.fastme.heap, double[], int, int);
  void swap(edu.luc.nmerge.fastme.heap, int, int);
  void reHeapElement(edu.luc.nmerge.fastme.heap, double[], int, int);
  void heapify(edu.luc.nmerge.fastme.heap, double[], int, int);
  void permInverse(edu.luc.nmerge.fastme.heap, int);
  void popHeap(edu.luc.nmerge.fastme.heap, double[], int, int);
}
Compiled from "node.java"
public class edu.luc.nmerge.fastme.node {
  java.lang.String label;
  edu.luc.nmerge.fastme.edge parentEdge;
  edu.luc.nmerge.fastme.edge leftEdge;
  edu.luc.nmerge.fastme.edge middleEdge;
  edu.luc.nmerge.fastme.edge rightEdge;
  int index;
  int index2;
  edu.luc.nmerge.fastme.node(java.lang.String, edu.luc.nmerge.fastme.edge, int);
  boolean leaf();
}
Compiled from "set.java"
class edu.luc.nmerge.fastme.set {
  edu.luc.nmerge.fastme.node node;
  edu.luc.nmerge.fastme.set next;
  edu.luc.nmerge.fastme.set(edu.luc.nmerge.fastme.node);
  void addToSet(edu.luc.nmerge.fastme.node);
}
Compiled from "tree.java"
public class edu.luc.nmerge.fastme.tree {
  java.lang.String name;
  edu.luc.nmerge.fastme.node root;
  int size;
  double weight;
  static int DOUBLE_PRECISION;
  edu.luc.nmerge.fastme.tree();
  edu.luc.nmerge.fastme.edge topFirstTraverse(edu.luc.nmerge.fastme.edge);
  edu.luc.nmerge.fastme.edge depthFirstTraverse(edu.luc.nmerge.fastme.edge);
  void GMEcalcUpAverage(edu.luc.nmerge.fastme.node, edu.luc.nmerge.fastme.edge, double[][], double[][]);
  void GMEcalcNewvAverages(edu.luc.nmerge.fastme.node, double[][], double[][]);
  void testEdge(edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.node, double[][]);
  void GMEupdateAveragesMatrix(double[][], edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.node, edu.luc.nmerge.fastme.node);
  void updatePair(double[][], edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.node, edu.luc.nmerge.fastme.node, double, edu.luc.nmerge.fastme.direction);
  void updateSubTree(double[][], edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.node, edu.luc.nmerge.fastme.node, edu.luc.nmerge.fastme.node, double, edu.luc.nmerge.fastme.direction);
  double wf2(double, double, double, double, double, double, double);
  void BMEaddSpecies(edu.luc.nmerge.fastme.node, double[][], double[][]);
  void GMEaddSpecies(edu.luc.nmerge.fastme.node, double[][], double[][]);
  void assignAllSizeFields();
  void makeOLSAveragesTable(double[][], double[][]);
  void fillTableUp(edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.edge, double[][], double[][]);
  int NNI(double[][], int);
  int NNIRetestEdge(edu.luc.nmerge.fastme.heap, edu.luc.nmerge.fastme.heap, edu.luc.nmerge.fastme.edge, double[][], double[], edu.luc.nmerge.fastme.direction[], int);
  edu.luc.nmerge.fastme.direction NNIEdgeTest(edu.luc.nmerge.fastme.edge, double[][], double[], int);
  void NNItopSwitch(edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.direction, double[][]);
  void NNIupdateAverages(double[][], edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.edge);
  void assignOLSWeights(double[][]);
  void makeBMEAveragesTable(double[][], double[][]);
  void calcUpAverages(double[][], double[][], edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.edge);
  int bNNI(double[][], int);
  edu.luc.nmerge.fastme.direction bNNIEdgeTest(edu.luc.nmerge.fastme.edge, double[][], double[], int);
  void bNNItopSwitch(edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.direction, double[][]);
  int bNNIRetestEdge(edu.luc.nmerge.fastme.heap, edu.luc.nmerge.fastme.heap, edu.luc.nmerge.fastme.edge, double[][], double[], edu.luc.nmerge.fastme.direction[], int);
  void assignBalWeights(double[][]);
  void assignBMEWeights(double[][]);
  void bNNIupdateAverages(double[][], edu.luc.nmerge.fastme.node, edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.edge);
  void updateSubTreeAfterNNI(double[][], edu.luc.nmerge.fastme.node, edu.luc.nmerge.fastme.edge, edu.luc.nmerge.fastme.node, edu.luc.nmerge.fastme.node, double, edu.luc.nmerge.fastme.direction);
  double wf5(double, double, double, double, double, double);
  public void NewickPrintTree(java.io.PrintStream) throws java.lang.Exception;
  void NewickPrintBinaryTree(java.io.PrintStream) throws java.lang.Exception;
  void NewickPrintTrinaryTree(java.io.PrintStream) throws java.lang.Exception;
  void NewickPrintSubtree(edu.luc.nmerge.fastme.edge, java.io.PrintStream) throws java.lang.Exception;
  static {};
}
Compiled from "tree.java"
class edu.luc.nmerge.fastme.tree$1 {
  static final int[] $SwitchMap$edu$luc$nmerge$fastme$direction;
  static {};
}
Compiled from "Arc.java"
public class edu.luc.nmerge.graph.Arc {
  static int MOD_ADLER;
  static java.lang.String alphabet;
  public java.util.BitSet versions;
  edu.luc.nmerge.graph.Node from;
  public edu.luc.nmerge.graph.Node to;
  char[] data;
  java.util.LinkedList<edu.luc.nmerge.graph.Arc> children;
  edu.luc.nmerge.graph.Arc parent;
  int id;
  static int arcId;
  static final boolean $assertionsDisabled;
  public edu.luc.nmerge.graph.Arc(java.util.BitSet, edu.luc.nmerge.graph.Arc);
  java.util.ListIterator<edu.luc.nmerge.graph.Arc> childIterator() throws edu.luc.nmerge.exception.MVDException;
  public edu.luc.nmerge.graph.Arc(java.util.BitSet, char[]);
  public void setTo(edu.luc.nmerge.graph.Node);
  public void setFrom(edu.luc.nmerge.graph.Node);
  public char[] getData();
  public int dataLen();
  public void addVersion(int);
  public void addChild(edu.luc.nmerge.graph.Arc);
  public java.lang.String toString();
  edu.luc.nmerge.graph.Arc[] split(int) throws edu.luc.nmerge.exception.MVDException;
  public boolean equals(java.lang.Object);
  boolean isHint();
  edu.luc.nmerge.mvd.Pair toPair(java.util.HashMap<edu.luc.nmerge.graph.Arc, edu.luc.nmerge.mvd.Pair>, java.util.HashMap<edu.luc.nmerge.graph.Arc, edu.luc.nmerge.mvd.Pair>) throws edu.luc.nmerge.exception.MVDException;
  public boolean isEmpty();
  boolean unattached();
  public edu.luc.nmerge.graph.Node getFrom();
  public edu.luc.nmerge.graph.Node getTo();
  public void removeChild(edu.luc.nmerge.graph.Arc);
  int numChildren();
  boolean isParent();
  boolean isChild();
  public void passOnData();
  void setParent(edu.luc.nmerge.graph.Arc);
  void verify() throws edu.luc.nmerge.exception.MVDException;
  void checkForData(java.lang.String);
  boolean hasChildInVersion(short);
  static {};
}
Compiled from "Converter.java"
public class edu.luc.nmerge.graph.Converter {
  static int numParents;
  java.util.HashSet<edu.luc.nmerge.graph.Node> incomplete;
  edu.luc.nmerge.graph.UnattachedSet unattached;
  int origSize;
  java.util.BitSet allVersions;
  int nArcs;
  int nNodes;
  edu.luc.nmerge.graph.Graph graph;
  java.util.HashMap<edu.luc.nmerge.graph.Arc, edu.luc.nmerge.mvd.Pair> parents;
  java.util.HashMap<edu.luc.nmerge.graph.Arc, edu.luc.nmerge.mvd.Pair> orphans;
  public edu.luc.nmerge.graph.Converter();
  public edu.luc.nmerge.graph.Graph create(java.util.ArrayList<edu.luc.nmerge.mvd.Pair>, int) throws java.lang.Exception;
  public java.util.ArrayList<edu.luc.nmerge.mvd.Pair> serialise() throws edu.luc.nmerge.exception.MVDException;
  public boolean isIsomorphic(edu.luc.nmerge.graph.Graph);
  public void report();
}
Compiled from "Graph.java"
public class edu.luc.nmerge.graph.Graph {
  edu.luc.nmerge.graph.Node start;
  edu.luc.nmerge.graph.Node end;
  int position;
  java.util.BitSet constraint;
  int maxLen;
  int totalLen;
  static int MIN_OVERLAP_LEN;
  static final boolean $assertionsDisabled;
  public edu.luc.nmerge.graph.Graph();
  public edu.luc.nmerge.graph.Graph(edu.luc.nmerge.graph.Node, edu.luc.nmerge.graph.Node, java.util.BitSet, int);
  edu.luc.nmerge.graph.Node splitArcAt(edu.luc.nmerge.graph.Node, short, int, int, boolean) throws java.lang.Exception;
  public edu.luc.nmerge.graph.Graph getMiniGraph(edu.luc.nmerge.mvd.diff.Diff, short, int, edu.luc.nmerge.graph.Node) throws java.lang.Exception;
  public java.util.BitSet getSharedVersions(short);
  public edu.luc.nmerge.graph.SpecialArc addSpecialArc(char[], int, int) throws edu.luc.nmerge.exception.MVDException;
  public edu.luc.nmerge.graph.SpecialArc addSpecialArc(char[], java.util.BitSet, int) throws edu.luc.nmerge.exception.MVDException;
  char[] getVersion(int);
  int length();
  int totalLen();
  public void adopt(int) throws java.lang.Exception;
  public void verify() throws edu.luc.nmerge.exception.MVDException;
  public void printAndVerify(java.lang.String);
  public java.lang.String toString();
  void clearPrinted();
  public edu.luc.nmerge.graph.Node getStart();
  public edu.luc.nmerge.graph.Node getEnd();
  public void removeVersions(java.util.BitSet);
  public void removeVersion(int);
  static {};
}
Compiled from "MUM.java"
public class edu.luc.nmerge.graph.MUM implements java.lang.Comparable<edu.luc.nmerge.graph.MUM> {
  static int PRINTED_HASH_SIZE;
  edu.luc.nmerge.graph.SpecialArc arc;
  edu.luc.nmerge.graph.Graph graph;
  edu.luc.nmerge.graph.Graph leftSubGraph;
  edu.luc.nmerge.graph.Graph rightSubGraph;
  edu.luc.nmerge.graph.Match match;
  short version;
  java.util.HashMap<edu.luc.nmerge.graph.Match, edu.luc.nmerge.graph.Match> table;
  boolean transposed;
  boolean transposeLeft;
  static final int MIN_LEN;
  static final int INITIAL_QUEUE_LEN;
  static final double PHI;
  static final boolean $assertionsDisabled;
  edu.luc.nmerge.graph.MUM(edu.luc.nmerge.graph.SpecialArc, edu.luc.nmerge.graph.Graph, boolean);
  void update(edu.luc.nmerge.graph.Node, int, java.util.BitSet, int, int, int);
  int length();
  public edu.luc.nmerge.graph.Match getMatch();
  public edu.luc.nmerge.graph.Graph getLeftSubgraph();
  public edu.luc.nmerge.graph.Graph getRightSubgraph();
  public edu.luc.nmerge.graph.SpecialArc getLeftSubarc() throws java.lang.Exception;
  public edu.luc.nmerge.graph.SpecialArc getRightSubarc() throws java.lang.Exception;
  boolean withinThreshold(int, int, int);
  public static edu.luc.nmerge.graph.MUM findDirectMUM(edu.luc.nmerge.graph.SpecialArc, edu.luc.nmerge.graph.suffixtree.SuffixTree, edu.luc.nmerge.graph.Graph) throws edu.luc.nmerge.exception.MVDException;
  static void checkForCycle(edu.luc.nmerge.graph.SimpleQueue<edu.luc.nmerge.graph.Node>, edu.luc.nmerge.graph.Arc, int) throws edu.luc.nmerge.exception.MVDException;
  static boolean compareBytes(byte[], int, java.lang.String);
  public static edu.luc.nmerge.graph.MUM findLeftTransposeMUM(edu.luc.nmerge.graph.SpecialArc, edu.luc.nmerge.graph.suffixtree.SuffixTree, edu.luc.nmerge.graph.Graph);
  static void findLeftPositions(edu.luc.nmerge.graph.MUM, edu.luc.nmerge.graph.suffixtree.SuffixTree, edu.luc.nmerge.graph.Node, int);
  static void clearPrintedArcs(java.util.HashSet<edu.luc.nmerge.graph.Node>);
  public static edu.luc.nmerge.graph.MUM findRightTransposeMUM(edu.luc.nmerge.graph.SpecialArc, edu.luc.nmerge.graph.suffixtree.SuffixTree, edu.luc.nmerge.graph.Graph);
  static void findRightPositions(edu.luc.nmerge.graph.MUM, edu.luc.nmerge.graph.suffixtree.SuffixTree, edu.luc.nmerge.graph.Node, int);
  public void merge() throws edu.luc.nmerge.exception.MVDException;
  public edu.luc.nmerge.graph.SimpleQueue<edu.luc.nmerge.graph.SpecialArc> getLeftSpecialArcs();
  public edu.luc.nmerge.graph.SimpleQueue<edu.luc.nmerge.graph.SpecialArc> getRightSpecialArcs();
  public edu.luc.nmerge.graph.SpecialArc getArc();
  public edu.luc.nmerge.graph.Graph getGraph();
  edu.luc.nmerge.graph.SpecialArc splitOffLeftArc();
  edu.luc.nmerge.graph.SpecialArc splitOffRightArc();
  void createLeftSubGraph() throws edu.luc.nmerge.exception.MVDException;
  java.util.BitSet getConstraint(edu.luc.nmerge.graph.Node, edu.luc.nmerge.graph.Node);
  public boolean isTransposition();
  public int compareTo(edu.luc.nmerge.graph.MUM);
  public boolean verify();
  public int compareTo(java.lang.Object);
  static {};
}
Compiled from "Match.java"
public class edu.luc.nmerge.graph.Match {
  int graphOffset;
  int dataOffset;
  int length;
  char[] data;
  short version;
  edu.luc.nmerge.graph.Node start;
  edu.luc.nmerge.graph.Arc[] path;
  int freq;
  static int MOD_ADLER;
  static final boolean $assertionsDisabled;
  edu.luc.nmerge.graph.Match(edu.luc.nmerge.graph.Node, int, short, int, int, char[]);
  public void setStart(edu.luc.nmerge.graph.Node);
  public boolean equals(java.lang.Object);
  void addVersion(int) throws edu.luc.nmerge.exception.MVDException;
  public java.lang.String toString();
  public int hashCode();
  edu.luc.nmerge.graph.Arc[] getMatchPath() throws edu.luc.nmerge.exception.MVDException;
  int findParentArc(java.util.Vector<edu.luc.nmerge.graph.Arc>, edu.luc.nmerge.graph.Arc);
  edu.luc.nmerge.graph.Node getLeftNode() throws edu.luc.nmerge.exception.MVDException;
  edu.luc.nmerge.graph.Node getRightNode() throws edu.luc.nmerge.exception.MVDException;
  void verify(edu.luc.nmerge.graph.Node);
  boolean checkPath(short);
  public int getLength();
  public boolean overlaps(edu.luc.nmerge.graph.Match);
  static {};
}
Compiled from "MatchThreadDirect.java"
public class edu.luc.nmerge.graph.MatchThreadDirect implements java.lang.Runnable {
  protected edu.luc.nmerge.graph.MUM mum;
  protected edu.luc.nmerge.graph.Graph graph;
  protected edu.luc.nmerge.graph.suffixtree.SuffixTree st;
  edu.luc.nmerge.graph.Node start;
  int offset;
  int first;
  protected int travelled;
  edu.luc.nmerge.graph.Arc arc;
  protected edu.luc.nmerge.graph.suffixtree.Pos pos;
  protected java.util.BitSet versions;
  protected int pathLen;
  protected edu.luc.nmerge.graph.PrevChar[] prevChars;
  edu.luc.nmerge.graph.Node forbidden;
  boolean extended;
  public edu.luc.nmerge.graph.MatchThreadDirect();
  public edu.luc.nmerge.graph.MatchThreadDirect(edu.luc.nmerge.graph.MUM, edu.luc.nmerge.graph.Graph, edu.luc.nmerge.graph.suffixtree.SuffixTree, edu.luc.nmerge.graph.Arc, edu.luc.nmerge.graph.Node, int, edu.luc.nmerge.graph.PrevChar[], edu.luc.nmerge.graph.Node);
  protected edu.luc.nmerge.graph.MatchThreadDirect(edu.luc.nmerge.graph.MatchThreadDirect);
  boolean extended();
  public void run();
  protected void mismatch();
  protected boolean isMaximal();
  protected void updateArc();
  protected void addToPath(edu.luc.nmerge.graph.Arc);
}
Compiled from "MatchThreadTransposeLeft.java"
public class edu.luc.nmerge.graph.MatchThreadTransposeLeft extends edu.luc.nmerge.graph.MatchThreadDirect {
  edu.luc.nmerge.graph.MatchThreadTransposeLeft(edu.luc.nmerge.graph.MUM, edu.luc.nmerge.graph.suffixtree.SuffixTree, edu.luc.nmerge.graph.Arc, int, edu.luc.nmerge.graph.PrevChar[], int, edu.luc.nmerge.graph.Node);
  protected edu.luc.nmerge.graph.MatchThreadTransposeLeft(edu.luc.nmerge.graph.MatchThreadTransposeLeft);
  protected void updateArc();
}
Compiled from "MatchThreadTransposeRight.java"
public class edu.luc.nmerge.graph.MatchThreadTransposeRight extends edu.luc.nmerge.graph.MatchThreadDirect {
  edu.luc.nmerge.graph.MatchThreadTransposeRight(edu.luc.nmerge.graph.MUM, edu.luc.nmerge.graph.suffixtree.SuffixTree, edu.luc.nmerge.graph.Arc, int, edu.luc.nmerge.graph.PrevChar[], int, edu.luc.nmerge.graph.Node);
  protected edu.luc.nmerge.graph.MatchThreadTransposeRight(edu.luc.nmerge.graph.MatchThreadTransposeRight);
  protected void updateArc();
}
Compiled from "Node.java"
public class edu.luc.nmerge.graph.Node {
  java.util.BitSet printed;
  java.util.BitSet printedOutgoing;
  int shortestPathToNode;
  java.util.LinkedList<edu.luc.nmerge.graph.Match> matches;
  static int id;
  int nodeId;
  static final boolean $assertionsDisabled;
  public edu.luc.nmerge.graph.Node();
  public void addMatch(edu.luc.nmerge.graph.Match);
  boolean isIncomingEmpty();
  boolean isOutgoingEmpty();
  public void addOutgoing(edu.luc.nmerge.graph.Arc) throws edu.luc.nmerge.exception.MVDException;
  public boolean hasOutgoingArc(edu.luc.nmerge.graph.Arc);
  public void addIncoming(edu.luc.nmerge.graph.Arc) throws edu.luc.nmerge.exception.MVDException;
  public void reset();
  public int getShortestPath();
  public void setShortestPath(int);
  public edu.luc.nmerge.graph.Node split() throws java.lang.Exception;
  public void printArc(edu.luc.nmerge.graph.Arc);
  public void printArc(edu.luc.nmerge.graph.Arc, int);
  public boolean isPrintedIncoming(java.util.BitSet);
  public boolean isPrintedOutgoing(java.util.BitSet);
  public void printOutgoingArc(edu.luc.nmerge.graph.Arc);
  public void printOutgoingArc(edu.luc.nmerge.graph.Arc, int);
  boolean allPrintedOutgoing();
  boolean allPrintedIncoming(java.util.BitSet);
  public boolean allPrintedIncoming();
  public int indegree();
  public void moveMatches(edu.luc.nmerge.graph.Node);
  public int numIncomingVersions();
  public int numOutgoingVersions();
  public int outdegree();
  public int cardinality();
  public java.util.BitSet getVersions();
  public java.util.ListIterator<edu.luc.nmerge.graph.Arc> outgoingArcs(edu.luc.nmerge.graph.Graph);
  public java.util.ListIterator<edu.luc.nmerge.graph.Arc> outgoingArcs();
  public java.util.ListIterator<edu.luc.nmerge.graph.Arc> incomingArcs();
  public edu.luc.nmerge.graph.Arc pickIncomingArc(int);
  public edu.luc.nmerge.graph.Arc pickOutgoingArc(int);
  public void replaceOutgoing(edu.luc.nmerge.graph.Arc, edu.luc.nmerge.graph.Arc) throws edu.luc.nmerge.exception.MVDException;
  public boolean removeIncoming(edu.luc.nmerge.graph.Arc);
  public void removeIncomingVersion(int);
  public void removeOutgoingVersion(int);
  void removeOutgoingVersions(java.util.BitSet);
  public boolean removeOutgoing(edu.luc.nmerge.graph.Arc);
  public edu.luc.nmerge.graph.Arc removeIncoming(int);
  public void addIncomingVersion(int);
  public void addOutgoingVersion(int);
  public edu.luc.nmerge.graph.Arc removeOutgoing(int);
  public void replaceIncoming(edu.luc.nmerge.graph.Arc, edu.luc.nmerge.graph.Arc) throws edu.luc.nmerge.exception.MVDException;
  void verify() throws edu.luc.nmerge.exception.MVDException;
  edu.luc.nmerge.graph.PrevChar[] getPrevChars();
  edu.luc.nmerge.graph.PrevChar[] getPrevChars(java.util.BitSet, edu.luc.nmerge.graph.Node);
  java.util.BitSet getIncomingSet();
  java.util.BitSet getOutgoingSet();
  public boolean equals(java.lang.Object);
  boolean isIncomplete();
  edu.luc.nmerge.graph.Arc pickOutgoingArc(java.util.BitSet);
  boolean wants(edu.luc.nmerge.graph.Arc);
  java.util.BitSet getOverhang();
  java.util.BitSet getClique(edu.luc.nmerge.graph.Arc);
  void optimise(edu.luc.nmerge.graph.UnattachedSet) throws edu.luc.nmerge.exception.MVDException;
  static {};
}
Compiled from "NodeQueue.java"
class edu.luc.nmerge.graph.NodeQueue extends java.util.Vector<edu.luc.nmerge.graph.Node> {
  static final long serialVersionUID;
  edu.luc.nmerge.graph.NodeQueue();
  void push(edu.luc.nmerge.graph.Node);
  edu.luc.nmerge.graph.Node pop();
}
Compiled from "PrevChar.java"
public class edu.luc.nmerge.graph.PrevChar {
  char previous;
  java.util.BitSet versions;
  edu.luc.nmerge.graph.PrevChar(java.util.BitSet, char);
}
Compiled from "SimpleQueue.java"
public class edu.luc.nmerge.graph.SimpleQueue<E> {
  edu.luc.nmerge.graph.SimpleQueue<E>.Item head;
  edu.luc.nmerge.graph.SimpleQueue<E>.Item tail;
  int size;
  public edu.luc.nmerge.graph.SimpleQueue();
  public E poll();
  public void add(E);
  public boolean isEmpty();
  public boolean contains(E);
  public int size();
}
Compiled from "SimpleQueue.java"
class edu.luc.nmerge.graph.SimpleQueue$Item {
  edu.luc.nmerge.graph.SimpleQueue<E>.Item next;
  E item;
  final edu.luc.nmerge.graph.SimpleQueue this$0;
  edu.luc.nmerge.graph.SimpleQueue$Item(E);
}
Compiled from "SpecialArc.java"
public class edu.luc.nmerge.graph.SpecialArc extends edu.luc.nmerge.graph.Arc {
  edu.luc.nmerge.graph.MUM best;
  int position;
  public edu.luc.nmerge.graph.SpecialArc(java.util.BitSet, char[], int);
  public edu.luc.nmerge.graph.MUM getBest();
  public void setBest(edu.luc.nmerge.graph.MUM);
  public void reset();
  public boolean equals(java.lang.Object);
  java.lang.String printout();
  public java.lang.String toString();
}
Compiled from "SpecialComparator.java"
public class edu.luc.nmerge.graph.SpecialComparator implements java.util.Comparator<edu.luc.nmerge.graph.SpecialArc> {
  public edu.luc.nmerge.graph.SpecialComparator();
  public int compare(edu.luc.nmerge.graph.SpecialArc, edu.luc.nmerge.graph.SpecialArc);
  public int compare(java.lang.Object, java.lang.Object);
}
Compiled from "UnattachedSet.java"
public class edu.luc.nmerge.graph.UnattachedSet extends java.util.HashSet<edu.luc.nmerge.graph.Arc> {
  static final long serialVersionUID;
  java.util.BitSet versions;
  edu.luc.nmerge.graph.UnattachedSet();
  void addAllAsIncoming(edu.luc.nmerge.graph.Node) throws edu.luc.nmerge.exception.MVDException;
  void addAsIncoming(edu.luc.nmerge.graph.Node, java.util.BitSet) throws edu.luc.nmerge.exception.MVDException;
  public boolean add(edu.luc.nmerge.graph.Arc);
  edu.luc.nmerge.graph.Arc getIntersectingArc(edu.luc.nmerge.graph.Arc);
  boolean removeEmptyArc(edu.luc.nmerge.graph.Arc, java.util.BitSet) throws java.lang.Exception;
  public boolean add(java.lang.Object);
}
Compiled from "Entry.java"
class edu.luc.nmerge.graph.suffixtree.Entry {
  java.lang.String file;
  int size;
  long time;
  long space;
  edu.luc.nmerge.graph.suffixtree.Entry next;
  public edu.luc.nmerge.graph.suffixtree.Entry(java.lang.String, int, long, long);
}
Compiled from "Node.java"
public class edu.luc.nmerge.graph.suffixtree.Node {
  edu.luc.nmerge.graph.suffixtree.Node sons;
  edu.luc.nmerge.graph.suffixtree.Node rightSibling;
  edu.luc.nmerge.graph.suffixtree.Node leftSibling;
  edu.luc.nmerge.graph.suffixtree.Node father;
  edu.luc.nmerge.graph.suffixtree.Node suffixLink;
  int pathPosition;
  int edgeLabelStart;
  int edgeLabelEnd;
  public edu.luc.nmerge.graph.suffixtree.Node();
  public edu.luc.nmerge.graph.suffixtree.Node(edu.luc.nmerge.graph.suffixtree.Node, int, int, int) throws edu.luc.nmerge.exception.MVDException;
  public boolean isLeaf();
}
Compiled from "Pos.java"
public class edu.luc.nmerge.graph.suffixtree.Pos {
  public edu.luc.nmerge.graph.suffixtree.Node node;
  public int edgePos;
  public edu.luc.nmerge.graph.suffixtree.Pos(edu.luc.nmerge.graph.suffixtree.Node, int);
}
Compiled from "SuffixTree.java"
public class edu.luc.nmerge.graph.suffixtree.SuffixTree {
  int stError;
  edu.luc.nmerge.graph.suffixtree.Node suffixless;
  int e;
  char[] treeString;
  public edu.luc.nmerge.graph.suffixtree.Node root;
  boolean debug;
  int length;
  static edu.luc.nmerge.graph.suffixtree.Entry entries;
  public edu.luc.nmerge.graph.suffixtree.SuffixTree(char[], boolean) throws edu.luc.nmerge.exception.MVDException;
  edu.luc.nmerge.graph.suffixtree.Node findSon(edu.luc.nmerge.graph.suffixtree.Node, char);
  int getNodeLabelLength(edu.luc.nmerge.graph.suffixtree.Node);
  boolean isLastCharInEdge(edu.luc.nmerge.graph.suffixtree.Node, int);
  void connectSiblings(edu.luc.nmerge.graph.suffixtree.Node, edu.luc.nmerge.graph.suffixtree.Node);
  edu.luc.nmerge.graph.suffixtree.Node applyExtensionRule2(edu.luc.nmerge.graph.suffixtree.Node, int, int, int, int, edu.luc.nmerge.graph.suffixtree.SuffixTree$Rule2Type) throws edu.luc.nmerge.exception.MVDException;
  public edu.luc.nmerge.graph.suffixtree.Pos getStartPos(char);
  public boolean advance(edu.luc.nmerge.graph.suffixtree.Pos, char);
  int getMatchLength(edu.luc.nmerge.graph.suffixtree.Pos);
  public int findSubstring(char[]);
  edu.luc.nmerge.graph.suffixtree.Pos followSuffixLink(edu.luc.nmerge.graph.suffixtree.Pos);
  int SEA(edu.luc.nmerge.graph.suffixtree.Pos, edu.luc.nmerge.graph.suffixtree.SuffixTree$Path, char, int) throws edu.luc.nmerge.exception.MVDException;
  void SPA(edu.luc.nmerge.graph.suffixtree.Pos, int, edu.luc.nmerge.graph.suffixtree.SuffixTree$ExtensionParam) throws edu.luc.nmerge.exception.MVDException;
  void printTree();
  void deleteSubTree(edu.luc.nmerge.graph.suffixtree.Node);
  void deleteTree();
  void printNode(edu.luc.nmerge.graph.suffixtree.Node, int);
  void printFullNode(edu.luc.nmerge.graph.suffixtree.Node);
  boolean selfTest();
  static void appendEntry(edu.luc.nmerge.graph.suffixtree.Entry);
  public static void main(java.lang.String[]) throws edu.luc.nmerge.exception.MVDException;
  void verify(char[]);
  void reportWord(char[], int, int);
  static {};
}
Compiled from "SuffixTree.java"
class edu.luc.nmerge.graph.suffixtree.SuffixTree$ExtensionParam {
  int extension;
  char repeatedExtension;
  final edu.luc.nmerge.graph.suffixtree.SuffixTree this$0;
  edu.luc.nmerge.graph.suffixtree.SuffixTree$ExtensionParam(edu.luc.nmerge.graph.suffixtree.SuffixTree);
}
Compiled from "SuffixTree.java"
final class edu.luc.nmerge.graph.suffixtree.SuffixTree$LastPosType extends java.lang.Enum<edu.luc.nmerge.graph.suffixtree.SuffixTree$LastPosType> {
  public static final edu.luc.nmerge.graph.suffixtree.SuffixTree$LastPosType lastCharInEdge;
  public static final edu.luc.nmerge.graph.suffixtree.SuffixTree$LastPosType otherChar;
  public static edu.luc.nmerge.graph.suffixtree.SuffixTree$LastPosType[] values();
  public static edu.luc.nmerge.graph.suffixtree.SuffixTree$LastPosType valueOf(java.lang.String);
  static {};
}
Compiled from "SuffixTree.java"
class edu.luc.nmerge.graph.suffixtree.SuffixTree$Path {
  int begin;
  int end;
  final edu.luc.nmerge.graph.suffixtree.SuffixTree this$0;
  edu.luc.nmerge.graph.suffixtree.SuffixTree$Path(edu.luc.nmerge.graph.suffixtree.SuffixTree);
}
Compiled from "SuffixTree.java"
final class edu.luc.nmerge.graph.suffixtree.SuffixTree$Rule2Type extends java.lang.Enum<edu.luc.nmerge.graph.suffixtree.SuffixTree$Rule2Type> {
  public static final edu.luc.nmerge.graph.suffixtree.SuffixTree$Rule2Type newSon;
  public static final edu.luc.nmerge.graph.suffixtree.SuffixTree$Rule2Type split;
  public static edu.luc.nmerge.graph.suffixtree.SuffixTree$Rule2Type[] values();
  public static edu.luc.nmerge.graph.suffixtree.SuffixTree$Rule2Type valueOf(java.lang.String);
  static {};
}
Compiled from "SuffixTree.java"
final class edu.luc.nmerge.graph.suffixtree.SuffixTree$SkipType extends java.lang.Enum<edu.luc.nmerge.graph.suffixtree.SuffixTree$SkipType> {
  public static final edu.luc.nmerge.graph.suffixtree.SuffixTree$SkipType skip;
  public static final edu.luc.nmerge.graph.suffixtree.SuffixTree$SkipType noSkip;
  public static edu.luc.nmerge.graph.suffixtree.SuffixTree$SkipType[] values();
  public static edu.luc.nmerge.graph.suffixtree.SuffixTree$SkipType valueOf(java.lang.String);
  static {};
}
Compiled from "SuffixTree.java"
class edu.luc.nmerge.graph.suffixtree.SuffixTree$TraceReturnValue {
  int edgePos;
  int charsFound;
  boolean searchDone;
  final edu.luc.nmerge.graph.suffixtree.SuffixTree this$0;
  edu.luc.nmerge.graph.suffixtree.SuffixTree$TraceReturnValue(edu.luc.nmerge.graph.suffixtree.SuffixTree);
}
Compiled from "Base64.java"
public class edu.luc.nmerge.mvd.Base64 {
  public static final int NO_OPTIONS;
  public static final int ENCODE;
  public static final int DECODE;
  public static final int GZIP;
  public static final int DONT_BREAK_LINES;
  public static final int URL_SAFE;
  public static final int ORDERED;
  public static final void main(java.lang.String[]);
  public static java.lang.String encodeObject(java.io.Serializable);
  public static java.lang.String encodeObject(java.io.Serializable, int);
  public static java.lang.String encodeBytes(byte[]);
  public static java.lang.String encodeBytes(byte[], int);
  public static java.lang.String encodeBytes(byte[], int, int);
  public static java.lang.String encodeBytes(byte[], int, int, int);
  public static byte[] decode(byte[], int, int, int);
  public static byte[] decode(java.lang.String);
  public static byte[] decode(java.lang.String, int);
  public static java.lang.Object decodeToObject(java.lang.String);
  public static boolean encodeToFile(byte[], java.lang.String);
  public static boolean decodeToFile(java.lang.String, java.lang.String);
  public static byte[] decodeFromFile(java.lang.String);
  public static java.lang.String encodeFromFile(java.lang.String);
  public static void encodeFileToFile(java.lang.String, java.lang.String);
  public static void decodeFileToFile(java.lang.String, java.lang.String);
  static byte[] access$000(int);
  static byte[] access$100(byte[], int, int, byte[], int, int);
  static int access$200(byte[], int, byte[], int, int);
  static byte[] access$300(byte[], byte[], int, int);
  static {};
}
Compiled from "Base64.java"
public class edu.luc.nmerge.mvd.Base64$InputStream extends java.io.FilterInputStream {
  public edu.luc.nmerge.mvd.Base64$InputStream(java.io.InputStream);
  public edu.luc.nmerge.mvd.Base64$InputStream(java.io.InputStream, int);
  public int read() throws java.io.IOException;
  public int read(byte[], int, int) throws java.io.IOException;
}
Compiled from "Base64.java"
public class edu.luc.nmerge.mvd.Base64$OutputStream extends java.io.FilterOutputStream {
  public edu.luc.nmerge.mvd.Base64$OutputStream(java.io.OutputStream);
  public edu.luc.nmerge.mvd.Base64$OutputStream(java.io.OutputStream, int);
  public void write(int) throws java.io.IOException;
  public void write(byte[], int, int) throws java.io.IOException;
  public void flushBase64() throws java.io.IOException;
  public void close() throws java.io.IOException;
  public void suspendEncoding() throws java.io.IOException;
  public void resumeEncoding();
}
Compiled from "BracketedData.java"
public abstract class edu.luc.nmerge.mvd.BracketedData {
  protected char[] realData;
  protected char[] escapedData;
  protected int srcLen;
  protected java.lang.String encoding;
  public edu.luc.nmerge.mvd.BracketedData(java.lang.String);
  public edu.luc.nmerge.mvd.BracketedData(java.lang.String, char[]);
  protected int readData(char[], int);
  protected char[] escapeData(char[]);
  public void addData(char[]);
  protected abstract java.lang.String createHeader();
  public char[] getChars();
  public int getSrcLen();
  public char[] getData();
}
Compiled from "Chunk.java"
public class edu.luc.nmerge.mvd.Chunk extends edu.luc.nmerge.mvd.BracketedData {
  edu.luc.nmerge.mvd.ChunkStateSet states;
  short version;
  int id;
  static int chunkId;
  public edu.luc.nmerge.mvd.Chunk(java.lang.String, short);
  public edu.luc.nmerge.mvd.Chunk(java.lang.String, int, edu.luc.nmerge.mvd.ChunkState[], char[], short);
  public edu.luc.nmerge.mvd.Chunk(char[], int, short);
  public void addState(edu.luc.nmerge.mvd.ChunkState);
  public edu.luc.nmerge.mvd.ChunkStateSet getStates();
  public void setVersion(short);
  public static edu.luc.nmerge.mvd.Chunk[] overlay(edu.luc.nmerge.mvd.Match, edu.luc.nmerge.mvd.Chunk[]);
  edu.luc.nmerge.mvd.Chunk[] split(int);
  public void setId(int);
  public int getId();
  public int getSrcLen();
  public char[] getData();
  public short getVersion();
  public int getLength();
  public java.lang.String toString();
  protected java.lang.String createHeader();
}
Compiled from "ChunkState.java"
public final class edu.luc.nmerge.mvd.ChunkState extends java.lang.Enum<edu.luc.nmerge.mvd.ChunkState> {
  public static final edu.luc.nmerge.mvd.ChunkState none;
  public static final edu.luc.nmerge.mvd.ChunkState merged;
  public static final edu.luc.nmerge.mvd.ChunkState deleted;
  public static final edu.luc.nmerge.mvd.ChunkState added;
  public static final edu.luc.nmerge.mvd.ChunkState found;
  public static final edu.luc.nmerge.mvd.ChunkState partial;
  public static final edu.luc.nmerge.mvd.ChunkState backup;
  public static final edu.luc.nmerge.mvd.ChunkState parent;
  public static final edu.luc.nmerge.mvd.ChunkState child;
  public static edu.luc.nmerge.mvd.ChunkState[] values();
  public static edu.luc.nmerge.mvd.ChunkState valueOf(java.lang.String);
  static {};
}
Compiled from "ChunkStateSet.java"
public class edu.luc.nmerge.mvd.ChunkStateSet {
  public edu.luc.nmerge.mvd.ChunkStateSet();
  public edu.luc.nmerge.mvd.ChunkStateSet(short, edu.luc.nmerge.mvd.ChunkState);
  public edu.luc.nmerge.mvd.ChunkStateSet(short);
  public edu.luc.nmerge.mvd.ChunkStateSet(edu.luc.nmerge.mvd.ChunkStateSet);
  public edu.luc.nmerge.mvd.ChunkStateSet(edu.luc.nmerge.mvd.ChunkState[], short);
  public void add(edu.luc.nmerge.mvd.ChunkState);
  public boolean isFound();
  public boolean isParent();
  public boolean isChild();
  public boolean containsState(edu.luc.nmerge.mvd.ChunkState);
  public boolean isBackup();
  public boolean isMerged();
  public boolean isEmpty();
  edu.luc.nmerge.mvd.ChunkStateSet next(edu.luc.nmerge.mvd.Pair, edu.luc.nmerge.mvd.ChunkState, short);
  edu.luc.nmerge.mvd.ChunkState[] getStates();
  public boolean equals(edu.luc.nmerge.mvd.ChunkStateSet);
  public java.lang.String toString();
  public short getBackup();
}
Compiled from "CompactNode.java"
public class edu.luc.nmerge.mvd.CompactNode {
  java.util.BitSet incoming;
  java.util.BitSet outgoing;
  int index;
  edu.luc.nmerge.mvd.CompactNode(int);
  java.util.BitSet getOutgoing();
  java.util.BitSet getIncoming();
  java.util.BitSet getWantsIncoming();
  java.util.BitSet getWantsOutgoing();
  int getIndex();
  void addIncoming(edu.luc.nmerge.mvd.Pair);
  void addOutgoing(edu.luc.nmerge.mvd.Pair);
  public java.lang.String toString();
}
Compiled from "Group.java"
public class edu.luc.nmerge.mvd.Group extends edu.luc.nmerge.mvd.Serialiser {
  static final long serialVersionUID;
  static final short TOP_LEVEL;
  short parent;
  public java.lang.String name;
  int groupSize;
  public edu.luc.nmerge.mvd.Group(short, java.lang.String);
  int dataSize() throws java.io.UnsupportedEncodingException;
  void serialise(byte[], int) throws java.lang.Exception;
  public short getParent();
  public void setParent(short);
  public boolean isOpen();
  public void setOpen(boolean);
  public void setName(java.lang.String);
  public java.lang.String toString();
}
Compiled from "KMPSearchState.java"
public class edu.luc.nmerge.mvd.KMPSearchState {
  char[] pattern;
  java.util.BitSet v;
  edu.luc.nmerge.mvd.KMPSearchState following;
  int[] next;
  int pos;
  public edu.luc.nmerge.mvd.KMPSearchState(char[], java.util.BitSet);
  void append(edu.luc.nmerge.mvd.KMPSearchState);
  public boolean equals(java.lang.Object);
  boolean isSubset(java.util.BitSet);
  void merge(edu.luc.nmerge.mvd.KMPSearchState);
  edu.luc.nmerge.mvd.KMPSearchState remove(edu.luc.nmerge.mvd.KMPSearchState) throws edu.luc.nmerge.exception.MVDException;
  edu.luc.nmerge.mvd.KMPSearchState split(java.util.BitSet);
  boolean update(char);
}
Compiled from "MVD.java"
public class edu.luc.nmerge.mvd.MVD extends edu.luc.nmerge.mvd.Serialiser implements java.io.Serializable {
  boolean timing;
  boolean directAlignOnly;
  static final int DUFF_PID;
  static final int NULL_PID;
  public static java.lang.String UNTITLED_NAME;
  java.util.ArrayList<edu.luc.nmerge.mvd.Group> groups;
  java.util.ArrayList<edu.luc.nmerge.mvd.Version> versions;
  java.util.ArrayList<edu.luc.nmerge.mvd.Pair> pairs;
  java.lang.String description;
  int headerSize;
  int groupTableSize;
  int versionTableSize;
  int pairsTableSize;
  int dataTableSize;
  int versionSetSize;
  int bestScore;
  long startTime;
  java.util.HashSet<edu.luc.nmerge.mvd.Pair> parents;
  java.util.BitSet partialVersions;
  java.lang.String encoding;
  static final boolean $assertionsDisabled;
  public edu.luc.nmerge.mvd.MVD();
  public edu.luc.nmerge.mvd.MVD(java.lang.String);
  public edu.luc.nmerge.mvd.MVD(java.lang.String, java.lang.String);
  public void setEncoding(java.lang.String);
  public void setDirectAlign(boolean);
  void setVersionSetSize(int);
  public java.lang.String getDescription();
  public java.lang.String getEncoding();
  public void addVersion(int, short) throws edu.luc.nmerge.exception.MVDException;
  void addVersion(edu.luc.nmerge.mvd.Version) throws edu.luc.nmerge.exception.MVDException;
  public int numVersions();
  public int numGroups();
  public void addGroup(short, short);
  void addGroup(edu.luc.nmerge.mvd.Group);
  public java.lang.String[] getSubGroups(short);
  public java.lang.String[] getSubVersions(short);
  void addPair(edu.luc.nmerge.mvd.Pair) throws java.lang.Exception;
  public java.util.ArrayList<edu.luc.nmerge.mvd.Pair> getPairs();
  edu.luc.nmerge.mvd.Pair getPair(int) throws java.lang.Exception;
  void initPartialVersions();
  public edu.luc.nmerge.mvd.Chunk[] compare(short, short, edu.luc.nmerge.mvd.ChunkState) throws edu.luc.nmerge.exception.MVDException;
  public void nextChunkState(edu.luc.nmerge.mvd.Chunk, edu.luc.nmerge.mvd.Pair, short);
  int next(int, short);
  int previous(int, short);
  public java.util.BitSet find(java.lang.String, int, java.lang.String);
  public edu.luc.nmerge.mvd.Match[] search(char[], java.util.BitSet, boolean) throws java.lang.Exception;
  public int newVersion(java.lang.String, java.lang.String, java.lang.String, short, boolean);
  public short getGroupParent(short);
  public java.lang.String getGroupName(short);
  public short getBackupForVersion(int);
  public short getGroupForVersion(int);
  public short getGroupId(java.lang.String);
  public int getVersionId(edu.luc.nmerge.mvd.Version);
  public void setDescription(java.lang.String);
  public void setGroupName(short, java.lang.String);
  public java.lang.String getGroupPath(short);
  public void setGroupParent(short, short);
  public void setVersionShortName(int, java.lang.String);
  public void setVersionLongName(int, java.lang.String);
  public void setVersionBackup(int, short);
  public void setVersionGroup(int, short);
  public void setOpen(short, boolean);
  public java.lang.String getDefaultGroup();
  void mergeSpecial(edu.luc.nmerge.graph.Graph, edu.luc.nmerge.graph.MUM) throws java.lang.Exception;
  public float update(short, char[], boolean) throws java.lang.Exception;
  public float getUniquePercentage(short);
  edu.luc.nmerge.graph.MUM recomputeMUM(edu.luc.nmerge.graph.MUM) throws edu.luc.nmerge.exception.MVDException;
  public void removeVersion(int) throws java.lang.Exception;
  public void removeGroup(short) throws java.lang.Exception;
  public int getNextVersionId(short);
  public java.lang.String getLongNameForVersion(int);
  int getVersionByShortName(java.lang.String);
  public int[] getVersionsForGroup(short);
  int getHighestVersion();
  int countTabs(java.lang.String);
  public java.lang.String getVersionTable();
  public java.lang.String getContentsForGroup(int, short) throws edu.luc.nmerge.exception.MVDException;
  public java.lang.String[] getVersionDescriptions();
  public java.lang.String[] getGroupDescriptions();
  public char[] getVersion(int);
  public int getVersionByNameAndGroup(java.lang.String, java.lang.String);
  public short getVersionByLongName(java.lang.String);
  public java.lang.String getVersionLongName(int);
  public java.lang.String getVersionShortName(int);
  public int[] getVersionLengths();
  int dataSize() throws java.io.UnsupportedEncodingException;
  int serialise(byte[]) throws java.lang.Exception;
  public edu.luc.nmerge.mvd.Variant[] getApparatus(short, int, int) throws edu.luc.nmerge.exception.MVDException;
  public java.lang.String getVersionId(short);
  public java.util.BitSet getVersionSetOfRange(short, int, int);
  public java.lang.String[] getVersionsOfRange(short, int, int);
  edu.luc.nmerge.mvd.Variant[] getVariants(int, int, short);
  boolean isPunctuation(char);
  void wordExtendBackwards(edu.luc.nmerge.mvd.Variant);
  void wordExtendForwards(edu.luc.nmerge.mvd.Variant);
  boolean isSubset(java.util.BitSet, java.util.BitSet);
  java.util.BitSet getVersionsLeading(int);
  java.util.BitSet getVersionsTrailing(int);
  int extendFirst(int);
  int extendLast(int);
  edu.luc.nmerge.mvd.PairPos getPairPos(edu.luc.nmerge.mvd.PairPos, int);
  public java.lang.String toString();
  public double[][] computeDiffMatrix();
  java.lang.String getShortNames(java.util.BitSet);
  public java.util.BitSet convertVersions(java.lang.String);
  java.util.BitSet constrainVersions(java.util.BitSet, java.util.BitSet);
  java.util.BitSet getSelectedVersions(java.lang.String);
  public int[] measureTable(short);
  public static java.lang.String versionsToString(java.util.BitSet);
  boolean isAlmost(java.util.BitSet, java.util.BitSet);
  edu.luc.nmerge.mvd.table.TableView buildDefaultTableView(short, java.util.BitSet, int, int);
  public java.lang.String getTable(short, int, int, java.lang.String);
  public java.lang.String getTableView(short, int, int, boolean, boolean, boolean, java.lang.String, int, java.lang.String);
  public static void main(java.lang.String[]);
  static {};
}
Compiled from "MVDError.java"
public class edu.luc.nmerge.mvd.MVDError {
  public edu.luc.nmerge.mvd.MVDError();
  public static void log(java.lang.String);
}
Compiled from "MVDFile.java"
public class edu.luc.nmerge.mvd.MVDFile {
  public static boolean debug;
  static byte[] MVD_MAGIC;
  static final boolean $assertionsDisabled;
  public edu.luc.nmerge.mvd.MVDFile();
  public static void externalise(edu.luc.nmerge.mvd.MVD, java.io.File, int, java.util.Properties) throws java.lang.Exception;
  public static java.lang.String externalise(edu.luc.nmerge.mvd.MVD) throws java.lang.Exception;
  public static edu.luc.nmerge.mvd.MVD internalise(java.lang.String);
  public static edu.luc.nmerge.mvd.MVD internalise(java.io.File, java.util.Properties) throws java.lang.Exception;
  static {};
}
Compiled from "MVDXMLFile.java"
public class edu.luc.nmerge.mvd.MVDXMLFile {
  public edu.luc.nmerge.mvd.MVDXMLFile();
  public static edu.luc.nmerge.mvd.MVD internalise(java.io.File) throws java.lang.Exception;
  public static void externalise(edu.luc.nmerge.mvd.MVD, java.io.File, java.lang.String, java.lang.String, boolean) throws java.lang.Exception;
}
Compiled from "Match.java"
public class edu.luc.nmerge.mvd.Match extends edu.luc.nmerge.mvd.BracketedData {
  int offset;
  int length;
  short version;
  java.lang.String shortName;
  boolean found;
  edu.luc.nmerge.mvd.ChunkState state;
  edu.luc.nmerge.mvd.Match(short, int, int, java.lang.String, edu.luc.nmerge.mvd.ChunkState);
  public edu.luc.nmerge.mvd.Match(int, int, short, java.lang.String);
  public edu.luc.nmerge.mvd.Match(byte[], int);
  static edu.luc.nmerge.mvd.Match[] makeMatches(int, java.util.BitSet, edu.luc.nmerge.mvd.MVD, int, int, boolean, edu.luc.nmerge.mvd.ChunkState) throws java.lang.Exception;
  int getStartOffset();
  int getLength();
  public short getVersion();
  static edu.luc.nmerge.mvd.Match[] merge(edu.luc.nmerge.mvd.Match[], edu.luc.nmerge.mvd.Match[]);
  public void setFound(boolean);
  public boolean isFound();
  public boolean equals(edu.luc.nmerge.mvd.Match);
  protected java.lang.String createHeader();
  public java.lang.String toString();
}
Compiled from "Node.java"
public class edu.luc.nmerge.mvd.Node {
  edu.luc.nmerge.mvd.Pair pair;
  int aOffset;
  edu.luc.nmerge.mvd.Node next;
  edu.luc.nmerge.mvd.Node(edu.luc.nmerge.mvd.Pair);
  edu.luc.nmerge.mvd.Node prune(int);
  edu.luc.nmerge.mvd.Node append(edu.luc.nmerge.mvd.Node);
  void setAOffset(int);
}
Compiled from "Pair.java"
public class edu.luc.nmerge.mvd.Pair extends edu.luc.nmerge.mvd.Serialiser {
  static final long serialVersionUID;
  static final int PARENT_FLAG;
  static final int CHILD_FLAG;
  static final int TRANSPOSE_MASK;
  static final int INVERSE_MASK;
  edu.luc.nmerge.mvd.Pair parent;
  java.util.LinkedList<edu.luc.nmerge.mvd.Pair> children;
  public java.util.BitSet versions;
  public static int pairId;
  int id;
  static final boolean $assertionsDisabled;
  public edu.luc.nmerge.mvd.Pair(java.util.BitSet, char[]);
  public void setId(int);
  public int getId();
  public int ensureId();
  public int numChildren();
  public java.util.ListIterator<edu.luc.nmerge.mvd.Pair> getChildIterator();
  public void addChild(edu.luc.nmerge.mvd.Pair);
  public void removeChild(edu.luc.nmerge.mvd.Pair);
  public void setParent(edu.luc.nmerge.mvd.Pair);
  public int length();
  public int byteLength() throws java.io.UnsupportedEncodingException;
  int dataSize() throws java.io.UnsupportedEncodingException;
  static void fixDataOffset(byte[], int, int, int, int);
  int pairSize(int);
  int serialisePair(byte[], int, int, int, int, int) throws edu.luc.nmerge.exception.MVDException;
  public boolean contains(short);
  public boolean isHint();
  public boolean isChild();
  public boolean isParent();
  public boolean isEmpty();
  public boolean startsWith(char[]);
  public boolean startsWithLetter();
  public java.lang.String toString();
  public edu.luc.nmerge.mvd.Pair getParent();
  public char[] getChars();
  public byte[] getData() throws edu.luc.nmerge.exception.MVDException;
  void setData(char[]);
  public edu.luc.nmerge.mvd.Pair getChildInVersion(short);
  public void verify() throws edu.luc.nmerge.exception.MVDException;
  static {};
}
Compiled from "PairPos.java"
public class edu.luc.nmerge.mvd.PairPos {
  int index;
  int position;
  short base;
  public edu.luc.nmerge.mvd.PairPos(int, int, short);
  int getPosition();
  int getIndex();
  short getBase();
}
Compiled from "Serialiser.java"
class edu.luc.nmerge.mvd.Serialiser implements java.io.Serializable {
  public static final long serialVersionUID;
  public edu.luc.nmerge.mvd.Serialiser();
  protected void writeInt(byte[], int, int);
  protected void writeShort(byte[], int, short);
  protected int writeUtf8String(byte[], int, java.lang.String) throws java.io.UnsupportedEncodingException;
  protected int measureUtf8String(java.lang.String) throws java.io.UnsupportedEncodingException;
  protected int writeData(byte[], int, byte[]) throws edu.luc.nmerge.exception.MVDException;
}
Compiled from "TransposeState.java"
public class edu.luc.nmerge.mvd.TransposeState {
  int id;
  edu.luc.nmerge.mvd.ChunkState state;
  static int transposeId;
  public edu.luc.nmerge.mvd.TransposeState();
  public int getId();
  public edu.luc.nmerge.mvd.ChunkState getChunkState();
  edu.luc.nmerge.mvd.TransposeState next(edu.luc.nmerge.mvd.Pair, short, short);
  public java.lang.String toString();
  public boolean isTransposed();
  static {};
}
Compiled from "VMap.java"
public class edu.luc.nmerge.mvd.VMap extends java.util.HashMap<edu.luc.nmerge.mvd.Pair, edu.luc.nmerge.mvd.Pair> {
  edu.luc.nmerge.mvd.VMap(short, java.util.Vector<edu.luc.nmerge.mvd.Pair>);
  boolean isContiguous(edu.luc.nmerge.mvd.Pair, edu.luc.nmerge.mvd.Pair, short);
}
Compiled from "Variant.java"
public class edu.luc.nmerge.mvd.Variant implements java.lang.Comparable<edu.luc.nmerge.mvd.Variant> {
  java.util.BitSet versions;
  int startIndex;
  int endIndex;
  int startOffset;
  int length;
  edu.luc.nmerge.mvd.MVD mvd;
  char[] data;
  public edu.luc.nmerge.mvd.Variant(int, int, int, int, java.util.BitSet, edu.luc.nmerge.mvd.MVD);
  public java.util.BitSet getVersions();
  protected java.lang.String createHeader();
  public java.lang.String toString();
  public char[] getChars();
  public boolean equals(java.lang.Object);
  public boolean equalsContent(edu.luc.nmerge.mvd.Variant);
  public int hashCode();
  void findContent();
  public void merge(edu.luc.nmerge.mvd.Variant);
  edu.luc.nmerge.mvd.Variant split(java.util.BitSet);
  public boolean isWithin(edu.luc.nmerge.mvd.Variant);
  public int compareTo(edu.luc.nmerge.mvd.Variant);
  public int compareTo(java.lang.Object);
}
Compiled from "Version.java"
public class edu.luc.nmerge.mvd.Version extends edu.luc.nmerge.mvd.Serialiser {
  static final long serialVersionUID;
  public short group;
  public short backup;
  public java.lang.String shortName;
  public java.lang.String longName;
  int versionSize;
  public static short NO_BACKUP;
  public edu.luc.nmerge.mvd.Version(short, short, java.lang.String, java.lang.String);
  int dataSize() throws java.io.UnsupportedEncodingException;
  void serialise(byte[], int) throws java.lang.Exception;
  public short getBackup();
  public boolean isPartial();
  java.lang.String toXML(int, int);
  public java.lang.String toString();
  public java.lang.String versionID(java.util.ArrayList<edu.luc.nmerge.mvd.Group>);
  static {};
}
Compiled from "WrappedPair.java"
public class edu.luc.nmerge.mvd.WrappedPair {
  edu.luc.nmerge.mvd.Pair pair;
  edu.luc.nmerge.mvd.CompactNode defaultNode;
  edu.luc.nmerge.mvd.WrappedPair(edu.luc.nmerge.mvd.Pair);
  edu.luc.nmerge.mvd.CompactNode getDefaultNode();
  edu.luc.nmerge.mvd.Pair getPair();
  void setDefaultNode(edu.luc.nmerge.mvd.CompactNode);
  public java.lang.String toString();
}
Compiled from "XMLGuideFile.java"
public class edu.luc.nmerge.mvd.XMLGuideFile {
  static java.lang.String GROUPS;
  static java.lang.String VERSIONS;
  static java.lang.String VERSION;
  static java.lang.String GROUP;
  static java.lang.String NAME;
  static java.lang.String PARENT;
  static java.lang.String BACKUP;
  static java.lang.String SHORTNAME;
  static java.lang.String LONGNAME;
  static java.lang.String DESCRIPTION;
  static java.lang.String MVDGUIDE;
  public static java.lang.String GUIDE_FILE;
  java.lang.String description;
  java.util.Vector<edu.luc.nmerge.mvd.Group> groups;
  java.util.Vector<edu.luc.nmerge.mvd.XMLGuideFile$VersionInfo> versions;
  public edu.luc.nmerge.mvd.XMLGuideFile(edu.luc.nmerge.mvd.MVD);
  public edu.luc.nmerge.mvd.XMLGuideFile$VersionInfo getVersionInfo(short) throws edu.luc.nmerge.exception.MVDToolException;
  public int numVersions();
  public java.lang.String getGroupName(short) throws edu.luc.nmerge.exception.MVDToolException;
  public void setVersionFile(short, java.lang.String) throws edu.luc.nmerge.exception.MVDToolException;
  public java.lang.String[] getVersionFileNames();
  public java.lang.String getDescription();
  public void externalise(java.io.File) throws edu.luc.nmerge.exception.MVDException;
  public static edu.luc.nmerge.mvd.XMLGuideFile internalise(java.io.File) throws edu.luc.nmerge.exception.MVDException;
  static {};
}
Compiled from "XMLGuideFile.java"
public class edu.luc.nmerge.mvd.XMLGuideFile$VersionInfo extends edu.luc.nmerge.mvd.Version {
  java.lang.String file;
  final edu.luc.nmerge.mvd.XMLGuideFile this$0;
  edu.luc.nmerge.mvd.XMLGuideFile$VersionInfo(edu.luc.nmerge.mvd.XMLGuideFile, short, short, java.lang.String, java.lang.String, java.lang.String);
  void setFile(java.lang.String);
}
Compiled from "XMLPretty.java"
public class edu.luc.nmerge.mvd.XMLPretty {
  public edu.luc.nmerge.mvd.XMLPretty();
  public static void writeXMLDeclaration(java.io.FileOutputStream, java.lang.String) throws java.io.IOException;
  public static void writeNode(org.w3c.dom.Node, java.io.FileOutputStream, java.lang.String, boolean, int) throws java.io.IOException;
}
Compiled from "Diagonal.java"
public class edu.luc.nmerge.mvd.diff.Diagonal {
  edu.luc.nmerge.mvd.diff.Diagonal left;
  edu.luc.nmerge.mvd.diff.Diagonal right;
  edu.luc.nmerge.mvd.diff.Matrix parent;
  int index;
  int x;
  edu.luc.nmerge.mvd.diff.Path p;
  edu.luc.nmerge.mvd.diff.Diagonal(int, edu.luc.nmerge.mvd.diff.Matrix, int);
  void setPrev(edu.luc.nmerge.mvd.diff.Path, edu.luc.nmerge.mvd.diff.PathOperation, int, int, int);
  void extend();
  void addLeft();
  void addRight();
  void advance();
  void remove();
  void seek();
  boolean atEnd();
}
Compiled from "Diff.java"
public class edu.luc.nmerge.mvd.diff.Diff {
  int oldOffset;
  int newOffset;
  int oldLen;
  int newLen;
  edu.luc.nmerge.mvd.diff.DiffKind kind;
  edu.luc.nmerge.mvd.diff.Diff(int, int, int, int, edu.luc.nmerge.mvd.diff.DiffKind);
  public int oldEnd();
  public int newEnd();
  public int oldLen();
  public int newLen();
  public int oldOff();
  public int newOff();
  public edu.luc.nmerge.mvd.diff.DiffKind getKind();
}
Compiled from "DiffKind.java"
public final class edu.luc.nmerge.mvd.diff.DiffKind extends java.lang.Enum<edu.luc.nmerge.mvd.diff.DiffKind> {
  public static final edu.luc.nmerge.mvd.diff.DiffKind INSERTED;
  public static final edu.luc.nmerge.mvd.diff.DiffKind DELETED;
  public static final edu.luc.nmerge.mvd.diff.DiffKind EXCHANGED;
  public static final edu.luc.nmerge.mvd.diff.DiffKind CHANGED;
  public static edu.luc.nmerge.mvd.diff.DiffKind[] values();
  public static edu.luc.nmerge.mvd.diff.DiffKind valueOf(java.lang.String);
  static {};
}
Compiled from "Matrix.java"
public class edu.luc.nmerge.mvd.diff.Matrix {
  char[] A;
  char[] B;
  int goalIndex;
  int d;
  edu.luc.nmerge.mvd.diff.Diagonal best;
  edu.luc.nmerge.mvd.diff.Diagonal diagonals;
  edu.luc.nmerge.mvd.diff.Tracker t;
  boolean reachedEnd;
  protected edu.luc.nmerge.mvd.diff.Matrix(char[], char[]);
  public static edu.luc.nmerge.mvd.diff.Diff[] computeBasicDiffs(char[], char[]);
  public static edu.luc.nmerge.mvd.diff.Diff[] computeDetailedDiffs(char[], char[]);
  void compute();
  edu.luc.nmerge.mvd.diff.Diff[] getDiffs(boolean);
  boolean check(int, int);
  boolean within(int, int);
  boolean valid(int, int);
  void setBest(edu.luc.nmerge.mvd.diff.Diagonal);
  void track(int, int, int, int);
}
Compiled from "Path.java"
public class edu.luc.nmerge.mvd.diff.Path {
  edu.luc.nmerge.mvd.diff.Path prev;
  edu.luc.nmerge.mvd.diff.Path next;
  edu.luc.nmerge.mvd.diff.PathOperation kind;
  int len;
  int index;
  int x;
  edu.luc.nmerge.mvd.diff.Path(int, int, edu.luc.nmerge.mvd.diff.PathOperation, int);
  java.awt.Point printOld(java.awt.Point, edu.luc.nmerge.mvd.diff.Path, java.util.ArrayList<edu.luc.nmerge.mvd.diff.Diff>, edu.luc.nmerge.mvd.diff.DiffKind);
  edu.luc.nmerge.mvd.diff.Diff[] print(int, int, boolean);
}
Compiled from "Path.java"
class edu.luc.nmerge.mvd.diff.Path$1 {
  static final int[] $SwitchMap$edu$luc$nmerge$mvd$diff$PathOperation;
  static {};
}
Compiled from "PathOperation.java"
public final class edu.luc.nmerge.mvd.diff.PathOperation extends java.lang.Enum<edu.luc.nmerge.mvd.diff.PathOperation> {
  public static final edu.luc.nmerge.mvd.diff.PathOperation nothing;
  public static final edu.luc.nmerge.mvd.diff.PathOperation insertion;
  public static final edu.luc.nmerge.mvd.diff.PathOperation deletion;
  public static final edu.luc.nmerge.mvd.diff.PathOperation exchange;
  public static final edu.luc.nmerge.mvd.diff.PathOperation matched;
  public static edu.luc.nmerge.mvd.diff.PathOperation[] values();
  public static edu.luc.nmerge.mvd.diff.PathOperation valueOf(java.lang.String);
  static {};
}
Compiled from "Tracker.java"
public class edu.luc.nmerge.mvd.diff.Tracker {
  int x;
  int y;
  char[] xAxis;
  char[] yAxis;
  char[][] m;
  edu.luc.nmerge.mvd.diff.Tracker(char[], char[]);
  void track(int, int, int, int);
  void print();
}
Compiled from "TextNavigator.java"
public class edu.luc.nmerge.mvd.navigator.TextNavigator {
  static java.util.HashSet<java.lang.Character> roman;
  int offset;
  int index;
  int v;
  java.lang.String text;
  boolean lastWasLetter;
  edu.luc.nmerge.mvd.MVD mvd;
  java.util.ArrayList<edu.luc.nmerge.mvd.Pair> pairs;
  java.util.ArrayList<java.lang.Character> undo;
  public edu.luc.nmerge.mvd.navigator.TextNavigator(edu.luc.nmerge.mvd.MVD, int, int, int);
  public edu.luc.nmerge.mvd.navigator.TextNavigator();
  public char next();
  boolean readArabicPageBackwards();
  public char prev();
  public static void main(java.lang.String[]);
  static {};
}
Compiled from "Atom.java"
public abstract class edu.luc.nmerge.mvd.table.Atom {
  edu.luc.nmerge.mvd.table.FragKind kind;
  java.util.BitSet versions;
  static float THRESHOLD_SIM;
  public edu.luc.nmerge.mvd.table.Atom();
  abstract edu.luc.nmerge.mvd.table.Atom merge(edu.luc.nmerge.mvd.table.Atom) throws java.lang.Exception;
  abstract boolean startsWithBreakPoint();
  abstract boolean endsWithBreakPoint();
  abstract java.lang.String getContents();
  abstract int length();
  static {};
}
Compiled from "FragKind.java"
public final class edu.luc.nmerge.mvd.table.FragKind extends java.lang.Enum<edu.luc.nmerge.mvd.table.FragKind> {
  public static final edu.luc.nmerge.mvd.table.FragKind empty;
  public static final edu.luc.nmerge.mvd.table.FragKind aligned;
  public static final edu.luc.nmerge.mvd.table.FragKind inserted;
  public static final edu.luc.nmerge.mvd.table.FragKind deleted;
  public static final edu.luc.nmerge.mvd.table.FragKind exchanged;
  public static final edu.luc.nmerge.mvd.table.FragKind merged;
  public static final edu.luc.nmerge.mvd.table.FragKind almost;
  public static edu.luc.nmerge.mvd.table.FragKind[] values();
  public static edu.luc.nmerge.mvd.table.FragKind valueOf(java.lang.String);
  static {};
}
Compiled from "FragList.java"
public class edu.luc.nmerge.mvd.table.FragList {
  java.util.ArrayList<edu.luc.nmerge.mvd.table.Atom> fragments;
  edu.luc.nmerge.mvd.table.Step editScript;
  boolean isBase;
  boolean merged;
  boolean nested;
  int id;
  edu.luc.nmerge.mvd.table.FragList();
  edu.luc.nmerge.mvd.table.FragList(boolean);
  void setNested(boolean);
  void setID(int);
  void add(edu.luc.nmerge.mvd.table.FragKind, java.lang.String, java.util.BitSet);
  void add(edu.luc.nmerge.mvd.table.Atom);
  void prepend(edu.luc.nmerge.mvd.table.FragKind, java.lang.String, java.util.BitSet);
  void prepend(edu.luc.nmerge.mvd.table.Atom);
  void setBase(boolean);
  java.util.BitSet getShared();
  public java.lang.Object clone();
  void printList(java.util.ArrayList<edu.luc.nmerge.mvd.Version>, java.util.ArrayList<edu.luc.nmerge.mvd.Group>);
  public java.lang.String toJSONString();
  public java.lang.String toString();
  public boolean equals(java.lang.Object);
  int max(int, int);
  boolean finished(int, int, edu.luc.nmerge.mvd.table.FragList);
  float similarity(edu.luc.nmerge.mvd.table.FragList);
  int snake(int, int, edu.luc.nmerge.mvd.table.FragList);
  boolean isEmpty();
  edu.luc.nmerge.mvd.table.Table updateTable(edu.luc.nmerge.mvd.table.Table, java.util.ArrayList<edu.luc.nmerge.mvd.Version>, short, java.util.BitSet);
  short computeBase(java.util.BitSet, java.util.BitSet);
  float computeD(edu.luc.nmerge.mvd.table.FragList);
  void merge(edu.luc.nmerge.mvd.table.FragList, java.util.ArrayList<edu.luc.nmerge.mvd.Version>, java.util.ArrayList<edu.luc.nmerge.mvd.Group>, java.util.BitSet) throws java.lang.Exception;
  java.lang.String getToNextBreakPoint(java.lang.String);
  int indexOfBreakPoint(java.lang.String);
  int lastIndexOfBreakPoint(java.lang.String);
  boolean doubledUp(java.lang.String, java.lang.String, edu.luc.nmerge.mvd.table.FragList);
  void extendLeft(edu.luc.nmerge.mvd.table.FragList, java.lang.String, short);
  void extendRight(edu.luc.nmerge.mvd.table.FragList, java.lang.String, short);
  public static void main(java.lang.String[]);
  java.lang.String getContents();
}
Compiled from "FragList.java"
class edu.luc.nmerge.mvd.table.FragList$1 {
  static final int[] $SwitchMap$edu$luc$nmerge$mvd$table$FragKind;
  static {};
}
Compiled from "Fragment.java"
class edu.luc.nmerge.mvd.table.Fragment extends edu.luc.nmerge.mvd.table.Atom {
  java.lang.String contents;
  java.lang.String style;
  edu.luc.nmerge.mvd.table.Fragment(edu.luc.nmerge.mvd.table.FragKind, java.lang.String, java.util.BitSet);
  public int length();
  public boolean isEmpty();
  void setStyle(java.lang.String);
  public java.lang.String getContents();
  public boolean equals(java.lang.Object);
  public java.lang.String getClassName();
  public java.lang.String toString();
  edu.luc.nmerge.mvd.table.Atom merge(edu.luc.nmerge.mvd.table.Atom) throws java.lang.Exception;
  boolean startsWithBreakPoint();
  boolean endsWithBreakPoint();
}
Compiled from "Options.java"
public final class edu.luc.nmerge.mvd.table.Options extends java.lang.Enum<edu.luc.nmerge.mvd.table.Options> {
  public static final edu.luc.nmerge.mvd.table.Options COMPACT;
  public static final edu.luc.nmerge.mvd.table.Options HIDE_MERGED;
  public static final edu.luc.nmerge.mvd.table.Options WHOLE_WORDS;
  public static final edu.luc.nmerge.mvd.table.Options FIRST_MERGEID;
  public static final edu.luc.nmerge.mvd.table.Options TABLE_ID;
  public static edu.luc.nmerge.mvd.table.Options[] values();
  public static edu.luc.nmerge.mvd.table.Options valueOf(java.lang.String);
  static {};
}
Compiled from "RandomId.java"
public class edu.luc.nmerge.mvd.table.RandomId {
  public edu.luc.nmerge.mvd.table.RandomId();
  public static java.lang.String getId(int);
  static {};
}
Compiled from "Row.java"
class edu.luc.nmerge.mvd.table.Row {
  java.util.ArrayList<edu.luc.nmerge.mvd.table.FragList> cells;
  java.util.ArrayList<edu.luc.nmerge.mvd.Version> sigla;
  java.util.ArrayList<edu.luc.nmerge.mvd.Group> groups;
  java.util.BitSet versions;
  short base;
  boolean nested;
  int id;
  edu.luc.nmerge.mvd.table.Row(java.util.BitSet, java.util.ArrayList<edu.luc.nmerge.mvd.Version>, java.util.ArrayList<edu.luc.nmerge.mvd.Group>, short);
  edu.luc.nmerge.mvd.table.Row(java.util.ArrayList<edu.luc.nmerge.mvd.Version>, java.util.ArrayList<edu.luc.nmerge.mvd.Group>, short);
  void setNested(boolean);
  void setID(int);
  void add(edu.luc.nmerge.mvd.table.Atom);
  void add(edu.luc.nmerge.mvd.table.FragList);
  void printRow();
  float similarity(edu.luc.nmerge.mvd.table.Row);
  boolean merge(edu.luc.nmerge.mvd.table.Row) throws java.lang.Exception;
  public boolean isEmpty();
  public void addVersions(java.util.BitSet);
  boolean isHidden();
  public java.lang.String toJSONString();
  public java.lang.String toString();
  public boolean equals(java.lang.Object);
  java.lang.String getContents();
  boolean textEquals(edu.luc.nmerge.mvd.table.Row);
}
Compiled from "Section.java"
public class edu.luc.nmerge.mvd.table.Section {
  java.util.HashMap<java.lang.Short, edu.luc.nmerge.mvd.table.FragList> lists;
  edu.luc.nmerge.mvd.table.SectionState state;
  java.util.BitSet versions;
  int offset;
  edu.luc.nmerge.mvd.table.Section();
  java.util.BitSet getVersions();
  int getOffset();
  void addFrag(edu.luc.nmerge.mvd.table.FragKind, short, int, java.util.BitSet, java.lang.String);
  void addFragSet(edu.luc.nmerge.mvd.table.FragKind, int, java.util.BitSet, java.lang.String);
  void addAlmostSet(int, java.util.BitSet, java.util.BitSet, java.lang.String);
}
Compiled from "SectionState.java"
public final class edu.luc.nmerge.mvd.table.SectionState extends java.lang.Enum<edu.luc.nmerge.mvd.table.SectionState> {
  public static final edu.luc.nmerge.mvd.table.SectionState merged;
  public static final edu.luc.nmerge.mvd.table.SectionState almost;
  public static final edu.luc.nmerge.mvd.table.SectionState disjoint;
  public static edu.luc.nmerge.mvd.table.SectionState[] values();
  public static edu.luc.nmerge.mvd.table.SectionState valueOf(java.lang.String);
  public static edu.luc.nmerge.mvd.table.SectionState state(edu.luc.nmerge.mvd.table.FragKind);
  static {};
}
Compiled from "SectionState.java"
class edu.luc.nmerge.mvd.table.SectionState$1 {
  static final int[] $SwitchMap$edu$luc$nmerge$mvd$table$FragKind;
  static {};
}
Compiled from "Step.java"
public class edu.luc.nmerge.mvd.table.Step {
  edu.luc.nmerge.mvd.table.Step parent;
  edu.luc.nmerge.mvd.table.FragKind kind;
  int x;
  edu.luc.nmerge.mvd.table.Step(edu.luc.nmerge.mvd.table.Step, edu.luc.nmerge.mvd.table.FragKind, int);
  edu.luc.nmerge.mvd.table.Step update(edu.luc.nmerge.mvd.table.FragKind, int);
  public java.lang.String toString();
}
Compiled from "Step.java"
class edu.luc.nmerge.mvd.table.Step$1 {
  static final int[] $SwitchMap$edu$luc$nmerge$mvd$table$FragKind;
  static {};
}
Compiled from "Table.java"
public class edu.luc.nmerge.mvd.table.Table extends edu.luc.nmerge.mvd.table.Atom {
  java.util.ArrayList<edu.luc.nmerge.mvd.table.Row> rows;
  java.util.ArrayList<edu.luc.nmerge.mvd.Version> sigla;
  java.util.ArrayList<edu.luc.nmerge.mvd.Group> groups;
  short base;
  int id;
  java.lang.String tableId;
  int depth;
  edu.luc.nmerge.mvd.table.Table(java.util.BitSet, java.util.ArrayList<edu.luc.nmerge.mvd.Version>, short, int);
  public edu.luc.nmerge.mvd.table.Row getEmptyRow();
  public int length();
  boolean nested();
  void setNested();
  void setID(int);
  void setTableId(java.lang.String);
  boolean isSubSet(java.util.BitSet, java.util.BitSet);
  void addRow(edu.luc.nmerge.mvd.table.Row);
  void assignToRow(edu.luc.nmerge.mvd.table.Atom) throws java.lang.Exception;
  edu.luc.nmerge.mvd.table.Atom merge(edu.luc.nmerge.mvd.table.Atom) throws java.lang.Exception;
  public java.lang.String toString();
  public java.lang.String toJSONString(java.util.HashMap<java.lang.String, java.lang.String>);
  edu.luc.nmerge.mvd.table.Row getRow(int);
  public void compact() throws java.lang.Exception;
  boolean contains(edu.luc.nmerge.mvd.table.Fragment);
  public boolean equals(java.lang.Object);
  public int hashCode();
  void extendToWholeWords() throws java.lang.Exception;
  boolean startsWithBreakPoint();
  boolean endsWithBreakPoint();
  boolean checkRowVersions();
  public java.lang.String getContents();
}
Compiled from "TableCell.java"
public class edu.luc.nmerge.mvd.table.TableCell {
  java.lang.String tagName;
  java.lang.String className;
  java.lang.String currentTextClass;
  java.util.ArrayList<edu.luc.nmerge.mvd.table.TextSegment> segments;
  int id;
  edu.luc.nmerge.mvd.table.TableCell(java.lang.String, java.lang.String);
  void setID(int);
  public java.lang.String toJSONString();
  public java.lang.String toString();
  void add(java.lang.String, java.lang.String);
  void add(java.lang.String);
}
Compiled from "TableView.java"
public class edu.luc.nmerge.mvd.table.TableView {
  java.util.ArrayList<edu.luc.nmerge.mvd.table.Section> sections;
  java.util.ArrayList<edu.luc.nmerge.mvd.Version> sigla;
  java.util.ArrayList<edu.luc.nmerge.mvd.Group> groups;
  java.util.EnumMap<edu.luc.nmerge.mvd.table.Options, java.lang.Object> options;
  boolean hideMerged;
  edu.luc.nmerge.mvd.table.Section current;
  int firstID;
  java.lang.String tableId;
  java.util.BitSet all;
  short base;
  public edu.luc.nmerge.mvd.table.TableView(java.util.ArrayList<edu.luc.nmerge.mvd.Version>, java.util.ArrayList<edu.luc.nmerge.mvd.Group>, short, java.util.BitSet, java.util.EnumMap<edu.luc.nmerge.mvd.table.Options, java.lang.Object>);
  public int[] getSectionStats();
  public void addFragment(edu.luc.nmerge.mvd.table.FragKind, int, java.util.BitSet, java.lang.String);
  public java.util.BitSet getCurrentVersions();
  public void clearCurrent(short);
  java.util.BitSet[] computeRows();
  void checkExclusivity(java.util.BitSet[]) throws java.lang.Exception;
  boolean getBooleanOption(edu.luc.nmerge.mvd.table.Options);
  public java.lang.String toString();
  public java.lang.String toJSONString(java.util.HashMap<java.lang.String, java.lang.String>);
}
Compiled from "TextSegment.java"
public class edu.luc.nmerge.mvd.table.TextSegment {
  java.lang.String className;
  java.lang.StringBuilder sb;
  public edu.luc.nmerge.mvd.table.TextSegment(java.lang.String, java.lang.String);
  public void add(java.lang.String);
  public java.lang.String getClassName();
  public int length();
  public java.lang.String toJSONString();
  public java.lang.String toString();
}
Compiled from "Utils.java"
public class edu.luc.nmerge.mvd.table.Utils {
  static java.lang.String[] layerNames;
  public edu.luc.nmerge.mvd.table.Utils();
  static java.lang.String bitSetToString(java.util.ArrayList<edu.luc.nmerge.mvd.Version>, java.util.ArrayList<edu.luc.nmerge.mvd.Group>, java.util.BitSet);
  public static void ensureExclusivity(java.util.BitSet, java.util.BitSet);
  static {};
}
Compiled from "Cache.java"
public class edu.luc.qut.nmerge.Cache extends java.util.HashMap<java.lang.String, edu.luc.nmerge.mvd.MVD> {
  public static final long serialVersionUID;
  int matchIndex;
  boolean multiVersion;
  edu.luc.nmerge.mvd.Match[] matches;
  byte[] pattern;
  java.lang.String dbConn;
  public edu.luc.qut.nmerge.Cache(java.lang.String);
  public java.lang.String getDbConn();
  edu.luc.nmerge.mvd.Match[] getNextMatch(byte[]);
  void clearMatches();
  boolean getMultiVersion();
  void setMultiVersion(boolean);
  void saveMatches(edu.luc.nmerge.mvd.Match[], byte[]);
}
