package jneat;

import java.util.Iterator;
import java.util.Vector;

// aka Phenotype
public class Network {
	
	public Vector<NNode> inputs;
	public Vector<NNode> outputs;
	public Vector<NNode> allNodes;
	
	Genome genotype;		// The genotype that created this phenotype
	int net_id;
	
	/** Status flag, currently used to determine if there's a loop in a recurrent network */
	NetworkStatusEnum status;
	
	public Network(Vector<NNode> in, Vector<NNode> out, int newID) {
		if (in != null) inputs = in;
		else inputs = new Vector<NNode>();
		
		if (out != null) outputs = out;
		else outputs = new Vector<NNode>();
		
		allNodes = new Vector<NNode>();
		genotype = null;
		
		// In the event of a manually specified ID number, ensures a duplicate number is not
		// automatically generated by the JNEATGlobal function.
		if (newID > JNEATGlobal.numNetworks) JNEATGlobal.numNetworks = newID;
		
		net_id = newID;
		status = NetworkStatusEnum.NORMAL;
	}
	
	public Network(Vector<NNode> in, Vector<NNode> out) {
		this(in, out, JNEATGlobal.NewNetworkID());
	}
	
	public Network() {
		this(new Vector<NNode>(), new Vector<NNode>());
	}
	
	public Network(int id) {
		this(new Vector<NNode>(), new Vector<NNode>(), id);
	}
	
	/** Attaches a hidden node to this neural network.
	 * 
	 * @param n
	 */
	public void attachHidden(NNode n) {
		allNodes.addElement(n);
		
		//System.out.println("Added node " + n.id + " as a hidden node of network " + net_id);
	}
	
	/** Adds node 'n' to this neural network's input nodes
	 * @param n
	 */
	public void attachInput(NNode n) {
		
		inputs.addElement(n);
		allNodes.addElement(n);
		
		//System.out.println("Added node " + n.id + " to inputs of network " + net_id);
	}
	
	/** Adds node 'n' to this neural network's output nodes
	 * 
	 * @param n
	 */
	public void attachOutput(NNode n) {
		outputs.addElement(n);
		allNodes.addElement(n);
		
		//System.out.println("Added node " + n.id + " to outputs of network " + net_id);
	}
	
	public void linkNodes(NNode parent, NNode child, double weight) {
		if (parent == null || child == null) {
			System.out.println("ERROR!  Attempting to link a non-existant node!");
			return;
		}
		
		Link l = new Link(weight, parent, child, false);
		parent.AddOutgoingLink(l);
		child.AddIncomingLink(l);
		
		System.out.println(l.PrintLink());
	}
	
	
	public boolean ActivateNetwork() {
		int abortCount = 0;		// Counts number of cycles in which the outputs have not all activated
		boolean activateOnce = false;	
		
		while (OutputsOff() || !activateOnce) 
		{
			abortCount++;
			if (abortCount >= JNEATGlobal.maxActivationCycles) {
				System.out.println("ERROR!  Network outputs not active after " + abortCount + " cycles!  Aborting.");
				return false;
			}
		
		
			for (int i = 0; i < allNodes.size(); i++) {
				NNode finger = allNodes.elementAt(i);
			
				if (finger.nType != NodeTypeEnum.SENSOR) {
					finger.activesum = 0.0;
					finger.active_flag = false;
					
					for (int j = 0; j < finger.incoming.size(); j++) {
						Link fingerLink = finger.incoming.elementAt(j);
						
						if (fingerLink.time_delay) {
							finger.activesum += fingerLink.weight * fingerLink.in_node.getTimeDelayActivation();
						} else {
							if (fingerLink.in_node.active_flag || fingerLink.in_node.nType == NodeTypeEnum.SENSOR) finger.active_flag = true;
							
							finger.activesum += fingerLink.weight * fingerLink.in_node.getActivation();
						}
					}			
				}
			}
		
			for (int i = 0; i < allNodes.size(); i++) {
				NNode finger = allNodes.elementAt(i);
				
				if (finger.nType != NodeTypeEnum.SENSOR) {
					if (finger.active_flag) {
						finger.prior_activation = finger.last_activation;
						finger.last_activation = finger.activation;
						
						if (finger.fType == NodeFuncEnum.SIGMOID) {
							finger.activation = JNEATGlobal.fsigmoid(finger.activesum,  4.924273);
						}
						finger.activation_count += 1.0;
					}
				}
			}
		
			activateOnce = true;
		}
		
		return true;
	}
	
	/** Checks all output neurons of this network.  Returns true if any of these outputs have NOT been activated.
	 * 
	 * @return
	 */
	public boolean OutputsOff() {
		for (int i = 0; i < outputs.size(); i++) {
			if (outputs.elementAt(i).activation_count == 0) return true; 
		}
		
		return false;
	}
	
	public boolean IsRecurrent(NNode pIn, NNode pOut, int level, int threshold) {
		level++;
		
		if (level > threshold) {
			status = NetworkStatusEnum.HAS_LOOP;
			return false;
		}
		
		if (pIn == pOut) return true;
		
		else {
			Iterator<Link> itr_link = pIn.incoming.iterator();
			while (itr_link.hasNext()) {
				Link _link = itr_link.next();
				if (!_link.recurrent) {
					if (!_link.in_node.is_traversed) {
						_link.in_node.is_traversed = true;
						if (IsRecurrent(_link.in_node, pOut, level, threshold)) return true;
					}
				}
			}
			
			pIn.is_traversed = true;
			return false;			
		}
	}
	
	/** Checks to see that the outputs are connected to the inputs and returns true/false accordingly */
	public boolean IsMinimal() {
		boolean ret_code = true;
		
		// Reset all nodes pending evaluation
		Iterator<NNode> itr_node = allNodes.iterator();
		while (itr_node.hasNext()) {
			itr_node.next().is_traversed = false;
		}
		
		// Traces path backwards from outputs to sensors
		itr_node = outputs.iterator();
		while (itr_node.hasNext()) {
			boolean rc = itr_node.next().mark(0);
			
			// Wil be false if the network has a loop or disconnected output
			if (!rc) return false;
		}
		
		// Now that the virtaul signal has flowed from output to inputs, see if the sensors have been touched
		itr_node = inputs.iterator();
		while (itr_node.hasNext()) {
			if (!itr_node.next().is_traversed) ret_code = false;
		}
		
		return ret_code;
	}
	
	/** Period is the length of time you want the network to be stable for.  Default is 30.
	 * Gives the network 90 turns plus the period the network must be stable for.
	 * Result is the time it took for the network to stabilize. */
	public int IsStabilized(int period) {
		int level = 0;
		
		if (period == 0) period = 30;
		
		// First activates the sensor nodes
		Iterator<NNode> itr_node = inputs.iterator();
		while (itr_node.hasNext()) {
			NNode _node = itr_node.next();
			if (_node.nType == NodeTypeEnum.SENSOR) {
				_node.prior_activation = _node.last_activation;
				_node.last_activation = _node.activation;
				_node.activation_count++;
				_node.activation = 1.0;
			}
		}
		
		// Activation of the network
		boolean done = false;
		int time_passed = 0;
		int time_limit = period + 90;
		int turns_stable = 0;
		
		while (!done) {
			if (time_passed >= time_limit) return 0; 	// Network has not stabilized
			
			// For each node, calculate the sum of its incoming activation
			itr_node = allNodes.iterator();
			while (itr_node.hasNext()) {
				NNode _node = itr_node.next();
				if (_node.nType != NodeTypeEnum.SENSOR) {
					_node.activesum = 0.0;
					_node.active_flag = false;
					
					Iterator<Link> itr_link = _node.incoming.iterator();
					while (itr_link.hasNext()) {
						Link _link = itr_link.next();
						if (!_link.time_delay) {
							_node.activesum += _link.in_node.getActivation();
							if (_link.in_node.active_flag || _link.in_node.nType == NodeTypeEnum.SENSOR) _node.active_flag = true; 
						} 
						// If time delayed
						else {								
							_node.activesum += _link.in_node.getTimeDelayActivation();
						}
					}
				}
			}
			
			// Now activates all non-sensor nodes based on their incoming activation
			itr_node = allNodes.iterator();
			while (itr_node.hasNext()) {
				NNode _node = itr_node.next();
				if (_node.nType != NodeTypeEnum.SENSOR) {
					// Only activate if some active input came in
					if (_node.active_flag) {
						_node.prior_activation = _node.last_activation;
						_node.last_activation = _node.activation;
						_node.activation = _node.activesum;
						_node.activation_count++;
					}
				}				
			}
			
			if (!OutputsOff()) {
				// Verify there is a change in any output
				boolean has_changed = false;
				itr_node = outputs.iterator();
				while (itr_node.hasNext()) {
					NNode _node = itr_node.next();
					if (_node.last_activation != _node.activation) {
						has_changed = true;
						break;
					}
				}
				
				if (!has_changed) {
					// If no change, increase the stability counter
					turns_stable++;
					
					if (turns_stable >= period) {
						done = true;
						level = time_passed;
						break;
					}
				}
				
				// Change, meaning stability counter is reset
				else {
					turns_stable = 0;
				}							
			}
			
			time_passed++;		
		}		
		
		// Returns 
		return (level - period + 1);
	}
	
	/** Finds the maximum number of neurons between an output and input*/
	public int max_depth() {
		int max = 0;
		
		for (int j = 0; j < allNodes.size(); j++) {
			NNode _node = allNodes.elementAt(j);
			_node.inner_level = 0;
			_node.is_traversed = false;
		}
		
		Iterator<NNode> itr_node = outputs.iterator();
		while (itr_node.hasNext()) {
			NNode _node = itr_node.next();
			int cur_depth = _node.depth(0, max);
			if (cur_depth > max) max = cur_depth;
		}
		
		return max;
	}
	
	public boolean HasPath(NNode pIn, NNode pOut, int level, int threshold) {
		
		// Reset all links to a state of none being traversed
		for (int i = 0; i < allNodes.size(); i++) {
			allNodes.elementAt(i).is_traversed = false;
		}
		
		return IsRecurrent(pIn, pOut, level, threshold);
	}
	
	public String PrintNetwork() {
		return PrintNetwork(false);
	}
	
	public String PrintNetwork(boolean showLinks) {
		String ret = "\nNETWORK #" + net_id + " has " + allNodes.size() + " nodes.\n";		
		
		Iterator<NNode> itr_node = allNodes.iterator();
		while (itr_node.hasNext()) {
			ret += " * " + itr_node.next().PrintNode(showLinks) + "\n";
		}
		
		return ret;
	}
	
	/** Resets all nodes in the network */
	public void flush() {
		Iterator<NNode> itr_node = allNodes.iterator();
		while (itr_node.hasNext()) {
			itr_node.next().resetNode();
		}
	}
}
