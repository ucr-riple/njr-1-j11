Compiled from "LeetTest.java"
public class algorithm.leetcode.LeetTest {
  public algorithm.leetcode.LeetTest();
  public static boolean isPalindromeNumber(int);
  public static boolean isPalindromeNumber2(int);
  public static int isPalindromeString(java.lang.String);
  public static void reverseWordsSequenceTest();
  public static int findSingleNumberTest();
  public static int findSingleNumberPart2Test();
  public static void generatePascalTriangleTest();
  public static int maxProductSubArrayTest();
  public static java.lang.String addBinaryTest(java.lang.String, java.lang.String);
  public static java.lang.String countAndSay(int);
  public static int lengthOfLastWord(java.lang.String);
  public static boolean isPalindrome(java.lang.String);
  public static boolean isPalindrome2(java.lang.String);
  public static int reverse(int);
  public static int[] plusOne(int[]);
  public int removeElement(int[], int);
  public static int maxProfitI(int[]);
  public static int maxProfitII(int[]);
  public static int maxProfitIII(int[]);
  public static int maxProfitIIII(int[]);
  public static int maxProfitV(int, int[]);
  public static int canCompleteCircuit(int[], int[]);
  public static int numDecodingsRecursion(java.lang.String);
  public static int numDecodingsIteration(java.lang.String);
  public static int[] merge(int[], int, int[], int);
  public static java.util.List<java.lang.Integer> spiralOrder(int[][]);
  public static int[][] generateMatrix(int);
  public static java.util.List<java.util.List<java.lang.Integer>> combine(int, int);
  public static int findMin(int[]);
  public static int ladderLength(java.lang.String, java.lang.String, java.util.Set<java.lang.String>);
  public static int ladderLengthLoop(java.lang.String, java.lang.String, java.util.Set<java.lang.String>);
  public void rotate(int[][]);
  public static boolean isValidParentheses(java.lang.String);
  public static int maxSubArray(int[]);
  public static int[] twoSum(int[], int);
  public static java.util.List<java.util.List<java.lang.Integer>> threeSum(int[]);
  public static int threeSumClosest(int[], int);
  public static java.util.List<java.util.List<java.lang.Integer>> fourSum(int[], int);
  public static java.util.List<java.lang.Integer> grayCode(int);
  public static int minimumTotal(java.util.List<java.util.List<java.lang.Integer>>);
  public static int evalRPN(java.lang.String[]);
  public static void sortColors(int[]);
  public static java.lang.String longestPalindrome(java.lang.String);
  public static int lengthOfLongestSubstring(java.lang.String);
  public static int findPeakElement(int[]);
  public static java.util.List<java.lang.String> restoreIpAddresses(java.lang.String);
  public static int minPathSum(int[][]);
  public static java.util.List<java.lang.String> generateParenthesis(int);
  public static java.util.List<java.util.List<java.lang.Integer>> permute(int[]);
  public static java.util.List<java.util.List<java.lang.Integer>> permuteUnique(int[]);
  public static void setZeroes(int[][]);
  public static java.util.List<java.util.List<java.lang.Integer>> subsets(int[]);
  public static java.util.List<java.util.List<java.lang.Integer>> subsetsWithDup(int[]);
  public static boolean searchMatrix(int[][], int);
  public static int searchInsert(int[], int);
  public static java.lang.String simplifyPath(java.lang.String);
  public static int divide(int, int);
  public static int maxArea(int[]);
  public static int uniquePaths(int, int);
  public static int uniquePathsWithObstacles(int[][]);
  public static boolean canJump(int[]);
  public static java.util.List<java.util.List<java.lang.Integer>> combinationSum(int[], int);
  public static java.util.List<java.util.List<java.lang.Integer>> combinationSum2(int[], int);
  public static java.util.List<java.lang.String> anagrams(java.lang.String[]);
  public static boolean isAnagrams(java.lang.String, java.lang.String);
  public static java.lang.String multiply(java.lang.String, java.lang.String);
  public static double pow(double, int);
  public static int sqrt(int);
  public static boolean wordBreak(java.lang.String, java.util.Set<java.lang.String>);
  public static java.util.List<java.lang.String> wordBreakII(java.lang.String, java.util.Set<java.lang.String>);
  public static java.lang.String intToRoman(int);
  public static int search(int[], int);
  public static boolean search2(int[], int);
  public static int removeDuplicates(int[]);
  public static boolean exist(char[][], java.lang.String);
  public static java.util.List<java.lang.String> letterCombinations(java.lang.String);
  public static void solve(char[][]);
  public static int[] searchRange(int[], int);
  public static java.util.List<java.util.List<java.lang.String>> partition(java.lang.String);
  public static int minCut(java.lang.String);
  public static void nextPermutation(int[]);
  public static int atoi(java.lang.String);
  public static int romanToInt(java.lang.String);
  public static java.lang.String longestCommonPrefix(java.lang.String[]);
  public static boolean isValidSudoku(char[][]);
  public static java.lang.String convertToTitle(int);
  public static int strStr(java.lang.String, java.lang.String);
  public static int compareVersion(java.lang.String, java.lang.String);
  public static java.lang.String convert(java.lang.String, int);
  public static java.util.List<java.lang.Integer> getRow(int);
  public static int jump(int[]);
  public static int majorityElement(int[]);
  public static java.lang.String getPermutation(int, int);
  public static void solveSudoku(char[][]);
  public static boolean isInterleave(java.lang.String, java.lang.String, java.lang.String);
  public static boolean isInterleaveHelper(java.lang.String, java.lang.String, java.lang.String, int, int, int, java.util.Map<java.lang.Integer, java.lang.Boolean>);
  public static boolean isMatch(java.lang.String, java.lang.String);
  public static boolean isMatchHelper(java.lang.String, java.lang.String, int, int);
  public static java.lang.String minWindow(java.lang.String, java.lang.String);
  public static int numDistinct(java.lang.String, java.lang.String);
  public static int minDistance(java.lang.String, java.lang.String);
  public static boolean isScramble(java.lang.String, java.lang.String);
  public static int maximumGap(int[]);
  public static int candy(int[]);
  public static int longestConsecutive(int[]);
  public static int longestValidParentheses(java.lang.String);
  public static int maxPoints(algorithm.leetcode.Point[]);
  public static int trap(int[]);
  public static int largestRectangleArea(int[]);
  public static int largestRectangleAreaFast(int[]);
  public static java.util.List<java.lang.String[]> solveNQueens(int);
  public static int totalNQueens(int);
  public static int titleToNumber(java.lang.String);
  public static int trailingZeroes(int);
  public static int firstMissingPositive(int[]);
  public static int calculateMinimumHP(int[][]);
  public static java.lang.String largestNumber(int[]);
  public static java.util.List<java.lang.String> findRepeatedDnaSequences(java.lang.String);
}
Compiled from "LeetTest.java"
final class algorithm.leetcode.LeetTest$1 implements java.util.Comparator<java.lang.String> {
  algorithm.leetcode.LeetTest$1();
  public int compare(java.lang.String, java.lang.String);
  public int compare(java.lang.Object, java.lang.Object);
}
Compiled from "MainLeet.java"
public class algorithm.leetcode.MainLeet {
  public algorithm.leetcode.MainLeet();
  public static void main(java.lang.String[]);
}
Compiled from "LeetTest.java"
class algorithm.leetcode.Point {
  int x;
  int y;
  algorithm.leetcode.Point();
  algorithm.leetcode.Point(int, int);
}
Compiled from "MainRecursion.java"
public class algorithm.recursion.MainRecursion {
  public algorithm.recursion.MainRecursion();
  public static void main(java.lang.String[]);
}
Compiled from "RecursionTest.java"
public class algorithm.recursion.RecursionTest {
  public algorithm.recursion.RecursionTest();
  public static int generateFibonacciNum(int);
  public static int count2sR(int);
}
Compiled from "MainSort.java"
public class algorithm.sort.MainSort {
  public algorithm.sort.MainSort();
  public static void main(java.lang.String[]);
}
Compiled from "Sort.java"
public class algorithm.sort.Sort {
  public algorithm.sort.Sort();
  public static int[] generateRandomArray();
  public static void selectionSort(int[]);
  public static void insertionSort(int[]);
  public static void mergeSort(int[], int, int);
  public static void quickSort(int[], int, int);
}
Compiled from "LCS.java"
public class algorithm.string.LCS {
  public algorithm.string.LCS(java.lang.String, java.lang.String);
  public void computeLCSTable();
  public java.lang.String findLCS(java.lang.String, int, int);
}
Compiled from "MainString.java"
public class algorithm.string.MainString {
  public algorithm.string.MainString();
  public static void main(java.lang.String[]);
}
Compiled from "Matching.java"
public class algorithm.string.Matching {
  public algorithm.string.Matching(java.lang.String, java.lang.String);
  public void createNextStateTable();
  public void findMatch();
}
Compiled from "Operation.java"
public final class algorithm.string.Operation extends java.lang.Enum<algorithm.string.Operation> {
  public static final algorithm.string.Operation delete;
  public static final algorithm.string.Operation insert;
  public static final algorithm.string.Operation replace;
  public static final algorithm.string.Operation copy;
  public static algorithm.string.Operation[] values();
  public static algorithm.string.Operation valueOf(java.lang.String);
  static {};
}
Compiled from "Test.java"
public class algorithm.string.Test {
  public algorithm.string.Test();
  public static boolean determineUniqueChar(java.lang.String);
  public static boolean determineUniqueChar2(java.lang.String);
  public static java.lang.String reverseCString(java.lang.String);
}
Compiled from "Transform.java"
public class algorithm.string.Transform {
  public algorithm.string.Transform(java.lang.String, java.lang.String);
  public int computeTransformTable();
  public java.lang.String assembleTransformation(java.lang.String, int, int);
}
Compiled from "AbstractMain.java"
public class basic.structure.abstractt.AbstractMain {
  public basic.structure.abstractt.AbstractMain();
  public static void main(java.lang.String[]);
}
Compiled from "Animal.java"
public abstract class basic.structure.abstractt.Animal {
  public basic.structure.abstractt.Animal();
  public abstract void eat();
  public void walk();
}
Compiled from "Dog.java"
public class basic.structure.abstractt.Dog extends basic.structure.abstractt.Animal {
  public basic.structure.abstractt.Dog();
  public void eat();
}
Compiled from "HashTableMain.java"
public class basic.structure.hashtable.HashTableMain {
  public basic.structure.hashtable.HashTableMain();
  public static void main(java.lang.String[]);
}
Compiled from "Human.java"
public class basic.structure.interfacee.Human implements basic.structure.interfacee.Whistle {
  public basic.structure.interfacee.Human(java.lang.String);
  public void whistle();
}
Compiled from "Main.java"
public class basic.structure.interfacee.Main {
  public basic.structure.interfacee.Main();
  public static void main(java.lang.String[]);
  public static void doWhistle(basic.structure.interfacee.Whistle);
}
Compiled from "Parrot.java"
public class basic.structure.interfacee.Parrot implements basic.structure.interfacee.Whistle {
  public basic.structure.interfacee.Parrot(java.lang.String);
  public void whistle();
}
Compiled from "Whistle.java"
public interface basic.structure.interfacee.Whistle {
  public abstract void whistle();
}
Compiled from "AVLTree.java"
public class datastructure.avltree.AVLTree extends datastructure.binarytree.BinaryTree {
  public datastructure.avltree.AVLTree();
  protected void insertNode(datastructure.binarytree.TreeNode, datastructure.binarytree.TreeNode);
  public void remove(datastructure.binarytree.TreeNode);
  public void checkBalance(datastructure.binarytree.TreeNode);
  public void rightRotation(datastructure.binarytree.TreeNode, datastructure.binarytree.TreeNode);
  public void leftRotation(datastructure.binarytree.TreeNode, datastructure.binarytree.TreeNode);
  public void leftAndRightRotation(datastructure.binarytree.TreeNode, datastructure.binarytree.TreeNode);
  public void rightAndLeftRotation(datastructure.binarytree.TreeNode, datastructure.binarytree.TreeNode);
}
Compiled from "MainAVL.java"
public class datastructure.avltree.MainAVL {
  public datastructure.avltree.MainAVL();
  public static void main(java.lang.String[]);
}
Compiled from "BinaryTree.java"
public class datastructure.binarytree.BinaryTree {
  protected datastructure.binarytree.TreeNode rootNode;
  protected int count;
  public datastructure.binarytree.BinaryTree();
  public void insert(datastructure.binarytree.TreeNode);
  protected void insertNode(datastructure.binarytree.TreeNode, datastructure.binarytree.TreeNode);
  public datastructure.binarytree.TreeNode getRootNode();
  public boolean contains(datastructure.binarytree.TreeNode, datastructure.binarytree.TreeNode);
  public datastructure.binarytree.TreeNode findNode(datastructure.binarytree.TreeNode, datastructure.binarytree.TreeNode);
  public int findMin(datastructure.binarytree.TreeNode);
  public int findMax(datastructure.binarytree.TreeNode);
  public int height(datastructure.binarytree.TreeNode);
  public int minDepth(datastructure.binarytree.TreeNode);
  public void remove(datastructure.binarytree.TreeNode);
  public datastructure.binarytree.TreeNode findParentNode(datastructure.binarytree.TreeNode, datastructure.binarytree.TreeNode);
  public void preorderTraverseRecursion(datastructure.binarytree.TreeNode);
  public void preorderTraverseLoop(datastructure.binarytree.TreeNode);
  public void postorderTraverseRecursion(datastructure.binarytree.TreeNode);
  public void postorderTraverseLoop(datastructure.binarytree.TreeNode);
  public void inorderTraverse(datastructure.binarytree.TreeNode);
  public void inorderTraverseRecur(datastructure.binarytree.TreeNode, java.util.List<java.lang.Integer>);
  public void inorderTraverseLoop(datastructure.binarytree.TreeNode);
  public boolean isValidBST(datastructure.binarytree.TreeNode);
  public void breadthFirstTraverse(datastructure.binarytree.TreeNode);
  public void levelOrderTraverse(datastructure.binarytree.TreeNode);
  public void zigzagLevelOrderTraverse(datastructure.binarytree.TreeNode);
  public datastructure.binarytree.TreeNode inorderSucc(datastructure.binarytree.TreeNode);
  public datastructure.binarytree.TreeNode findTheMostLeftNode(datastructure.binarytree.TreeNode);
  public boolean cover(datastructure.binarytree.TreeNode, datastructure.binarytree.TreeNode);
  public boolean isSameTree(datastructure.binarytree.TreeNode, datastructure.binarytree.TreeNode);
  public boolean hasPathSum(datastructure.binarytree.TreeNode, int);
  public java.util.List<java.util.List<java.lang.Integer>> pathSumII(datastructure.binarytree.TreeNode, int);
  public static boolean isSymmetric(datastructure.binarytree.TreeNode);
  public static datastructure.binarytree.TreeNode flatten(datastructure.binarytree.TreeNode);
  public static int numTrees(int);
  public static java.util.List<datastructure.binarytree.TreeNode> generateTrees(int);
  public int sumNumbers(datastructure.binarytree.TreeNode);
  public static datastructure.binarytree.TreeNode buildTree(int[], int[]);
  public datastructure.binarytree.TreeNode buildTree2(int[], int[]);
  public static int maxPathSum(datastructure.binarytree.TreeNode);
  public static int[] maxPathSumHelper(datastructure.binarytree.TreeNode);
}
Compiled from "MainBST.java"
public class datastructure.binarytree.MainBST {
  public datastructure.binarytree.MainBST();
  public static void main(java.lang.String[]);
}
Compiled from "TreeNode.java"
public class datastructure.binarytree.TreeNode {
  public int val;
  public datastructure.binarytree.TreeNode(int);
  public void setLeftLeafNode(datastructure.binarytree.TreeNode);
  public void setRightLeafNode(datastructure.binarytree.TreeNode);
  public datastructure.binarytree.TreeNode getLeftLeafNode();
  public datastructure.binarytree.TreeNode getRightLeafNode();
}
Compiled from "Heap.java"
public class datastructure.heap.Heap {
  java.util.ArrayList<java.lang.Integer> heapArrayMin;
  java.util.ArrayList<java.lang.Integer> heapArrayMax;
  public datastructure.heap.Heap();
  public void insertToMinHeap(int);
  public void insertToMaxHeap(int);
  public void removeFromMinHeap();
  public void removeFromMaxHeap();
  public boolean containsInMinHeap(int);
  public boolean containsInMaxHeap(int);
  public void printArrayMin();
  public void printArrayMax();
}
Compiled from "MainHeap.java"
public class datastructure.heap.MainHeap {
  public datastructure.heap.MainHeap();
  public static void main(java.lang.String[]);
  public static void testHeap();
}
Compiled from "LinkedListTest.java"
public class datastructure.linkedlist.LinkedListTest {
  public datastructure.linkedlist.LinkedListTest();
  public void addList();
  public void findBeginningTest();
  public boolean hasCycle(datastructure.linkedlist.ListNode);
  public static void swapPairsTest();
  public static void deleteDuplicatesTest();
  public static void testMergeTwoLists();
  public static datastructure.linkedlist.ListNode mergeTwoLists(datastructure.linkedlist.ListNode, datastructure.linkedlist.ListNode);
  public static datastructure.linkedlist.ListNode sortListTest();
  public static void reorderList();
  public static void addTwoNumbersTest();
  public static datastructure.linkedlist.ListNode partition(datastructure.linkedlist.ListNode, int);
  public static datastructure.linkedlist.ListNode rotateRight(datastructure.linkedlist.ListNode, int);
  public static datastructure.linkedlist.ListNode reverseBetween(datastructure.linkedlist.ListNode, int, int);
  public static datastructure.linkedlist.ListNode reverseBetween2(datastructure.linkedlist.ListNode, int, int);
  public static datastructure.linkedlist.ListNode removeNthFromEnd(datastructure.linkedlist.ListNode, int);
  public static datastructure.linkedlist.ListNode getIntersectionNode(datastructure.linkedlist.ListNode, datastructure.linkedlist.ListNode);
  public static datastructure.linkedlist.ListNode insertionSortList(datastructure.linkedlist.ListNode);
  public static datastructure.linkedlist.ListNode mergeKLists(java.util.List<datastructure.linkedlist.ListNode>);
  public static datastructure.linkedlist.ListNode mergeKListsHelper(datastructure.linkedlist.ListNode, datastructure.linkedlist.ListNode);
  public static datastructure.linkedlist.ListNode reverseKGroup(datastructure.linkedlist.ListNode, int);
}
Compiled from "ListNode.java"
public class datastructure.linkedlist.ListNode extends datastructure.binarytree.TreeNode {
  public datastructure.linkedlist.ListNode next;
  public datastructure.linkedlist.ListNode(int);
  public void push(int);
  public datastructure.linkedlist.ListNode deleteNode(datastructure.linkedlist.ListNode, int);
}
Compiled from "Main.java"
public class datastructure.linkedlist.Main {
  public datastructure.linkedlist.Main();
  public static void main(java.lang.String[]);
}
Compiled from "MainStack.java"
public class datastructure.stack.MainStack {
  public datastructure.stack.MainStack();
  public static void main(java.lang.String[]);
}
Compiled from "MyQueue.java"
public class datastructure.stack.MyQueue {
  java.util.Stack<java.lang.Integer> s1;
  java.util.Stack<java.lang.Integer> s2;
  public datastructure.stack.MyQueue();
  public void push(int);
  public int peek();
  public int pop();
}
Compiled from "StackTest.java"
public class datastructure.stack.StackTest {
  public datastructure.stack.StackTest();
  public void storeMinTest();
  public static void createQueueTest();
  public static void sortStackTest();
}
Compiled from "StackWithMin.java"
public class datastructure.stack.StackWithMin extends java.util.Stack<java.lang.Integer> {
  java.util.Stack<java.lang.Integer> stackMin;
  public datastructure.stack.StackWithMin();
  public void push(int);
  public java.lang.Integer pop();
  public int getMin();
  public java.lang.Object pop();
}
