Compiled from "AlphaPalindrome.java"
public class careercup.google.AlphaPalindrome {
  public careercup.google.AlphaPalindrome();
  public boolean isPalindrome(java.lang.String);
  public static void main(java.lang.String[]);
}
Compiled from "AnimalTreePrinter.java"
public class careercup.google.AnimalTreePrinter {
  public careercup.google.AnimalTreePrinter();
  public static void printTree(java.lang.Iterable<careercup.google.AnimalTreePrinter$Relation>);
  public static void main(java.lang.String[]);
}
Compiled from "AnimalTreePrinter.java"
public class careercup.google.AnimalTreePrinter$Relation {
  java.lang.String parent;
  java.lang.String child;
  public careercup.google.AnimalTreePrinter$Relation(java.lang.String, java.lang.String);
}
Compiled from "Array2Dto1D.java"
public class careercup.google.Array2Dto1D {
  public careercup.google.Array2Dto1D();
  public static int[] convert(int[][]);
  public static void main(java.lang.String[]);
}
Compiled from "Brackets.java"
public class careercup.google.Brackets {
  public careercup.google.Brackets();
  public void brackets(int);
  public static void main(java.lang.String[]);
}
Compiled from "CircularQueue.java"
public class careercup.google.CircularQueue {
  public careercup.google.CircularQueue(int);
  public synchronized void initialize();
  public synchronized void enqueue(int);
  public synchronized int dequeue();
  public static void main(java.lang.String[]);
}
Compiled from "CoinDenominations.java"
public class careercup.google.CoinDenominations {
  public careercup.google.CoinDenominations();
  public int getNumOfWays(int, java.util.List<java.lang.Integer>);
  public void getNumOfWays(int, java.util.List<java.lang.Integer>, int, int, careercup.google.MutableInt);
  public int getNumOfWays(int, java.util.List<java.lang.Integer>, int);
  public static void main(java.lang.String[]);
}
Compiled from "DistanceMaximizingProblem.java"
public class careercup.google.DistanceMaximizingProblem {
  public careercup.google.DistanceMaximizingProblem();
  public careercup.google.DistanceMaximizingProblem$MaxDistance findMaxDistance(int[]);
  public static void main(java.lang.String[]);
}
Compiled from "DistanceMaximizingProblem.java"
class careercup.google.DistanceMaximizingProblem$MaxDistance {
  int i;
  int j;
  careercup.google.DistanceMaximizingProblem$MaxDistance();
  public java.lang.String toString();
}
Compiled from "MergeSortedStreams.java"
class careercup.google.IntegerStream implements careercup.google.Stream<java.lang.Integer> {
  java.util.List<java.lang.Integer> integers;
  java.util.Iterator<java.lang.Integer> iterator;
  int currentValue;
  careercup.google.IntegerStream(java.util.List<java.lang.Integer>);
  public java.lang.Integer next();
  public java.lang.Integer peek();
  public boolean hasNext();
  public java.lang.String toString();
  public java.lang.Comparable peek();
  public java.lang.Comparable next();
}
Compiled from "InterleavingStringsDP.java"
public class careercup.google.InterleavingStringsDP {
  public careercup.google.InterleavingStringsDP();
  public boolean interleave(java.lang.String, java.lang.String, java.lang.String);
  public static void main(java.lang.String[]);
}
Compiled from "InterleavingStringsRecursive.java"
public class careercup.google.InterleavingStringsRecursive {
  public careercup.google.InterleavingStringsRecursive();
  public boolean interleave(java.lang.String, java.lang.String, java.lang.String, int, int, int);
  public static void main(java.lang.String[]);
}
Compiled from "KthSmallestElement.java"
public class careercup.google.KthSmallestElement {
  public careercup.google.KthSmallestElement();
  public static int kthOrderStatistics(int[], int, int, int);
  public static void main(java.lang.String[]);
}
Compiled from "MergeBSTs.java"
public class careercup.google.MergeBSTs {
  public careercup.google.MergeBSTs();
  public common.TreeParentNode createBalancedBSTFromTrees(common.TreeParentNode<java.lang.Integer>, common.TreeParentNode<java.lang.Integer>);
  public int getTreeSize(common.TreeParentNode);
  public static void main(java.lang.String[]);
}
Compiled from "MergeBSTs.java"
class careercup.google.MergeBSTs$TreeIterator<T> implements java.util.Iterator {
  public careercup.google.MergeBSTs$TreeIterator(common.TreeParentNode<T>);
  public boolean hasNext();
  public T next();
  public void remove();
  public T peek();
}
Compiled from "MergeSortedStreams.java"
public class careercup.google.MergeSortedStreams<T extends java.lang.Comparable<T>> {
  public careercup.google.MergeSortedStreams();
  public void mergeStreams(java.util.List<? extends careercup.google.Stream<T>>, careercup.google.Receiver<T>);
  public static void main(java.lang.String[]);
}
Compiled from "MergeSortedStreams.java"
final class careercup.google.MergeSortedStreams$1 implements careercup.google.Receiver<java.lang.Integer> {
  careercup.google.MergeSortedStreams$1();
  public void receive(java.lang.Integer);
  public void receive(java.lang.Object);
}
Compiled from "CoinDenominations.java"
class careercup.google.MutableInt {
  int i;
  public careercup.google.MutableInt(int);
}
Compiled from "SubtreeWeight.java"
class careercup.google.Node {
  int id;
  int parent;
  int weight;
  careercup.google.Node(int, int, int);
  public java.lang.String toString();
}
Compiled from "PlusPlusOperator.java"
public class careercup.google.PlusPlusOperator {
  public careercup.google.PlusPlusOperator();
  public int[] increment(int[]);
  public static void main(java.lang.String[]);
}
Compiled from "MergeSortedStreams.java"
interface careercup.google.Receiver<T> {
  public abstract void receive(T);
}
Compiled from "MergeSortedStreams.java"
interface careercup.google.Stream<T extends java.lang.Comparable<T>> {
  public abstract T next();
  public abstract T peek();
  public abstract boolean hasNext();
}
Compiled from "MergeSortedStreams.java"
class careercup.google.StreamHeap<T extends java.lang.Comparable<T>> {
  public careercup.google.StreamHeap(java.util.Collection<? extends careercup.google.Stream<T>>);
  public boolean hasNext();
  public careercup.google.Stream<T> getNext();
  public void add(careercup.google.Stream<T>);
}
Compiled from "SubarrayDiff.java"
public class careercup.google.SubarrayDiff {
  public careercup.google.SubarrayDiff();
  public careercup.google.SubarrayDiff$Answer getMaxSubarrayDiff(int[]);
  public static void main(java.lang.String[]);
}
Compiled from "SubarrayDiff.java"
class careercup.google.SubarrayDiff$Answer {
  int diff;
  careercup.google.SubarrayDiff$Answer();
  careercup.google.SubarrayDiff$Answer(int);
  public boolean equals(java.lang.Object);
  public int hashCode();
  public java.lang.String toString();
}
Compiled from "SubtreeWeight.java"
public class careercup.google.SubtreeWeight {
  public careercup.google.SubtreeWeight();
  public void printSubTreeWeight(java.util.List<careercup.google.Node>);
  public static void main(java.lang.String[]);
}
Compiled from "SumOfTwoIntegers.java"
public class careercup.google.SumOfTwoIntegers {
  public careercup.google.SumOfTwoIntegers();
  public int minSum(int[]);
  int addDigitToLeft(int, int, int);
  public static void main(java.lang.String[]);
}
Compiled from "ArrayLeader.java"
public class careercup.linkedin.ArrayLeader {
  public careercup.linkedin.ArrayLeader();
  int arrLeader(int[]);
  public static void main(java.lang.String[]);
}
Compiled from "BinaryTreeRepresentation.java"
public class careercup.linkedin.BinaryTreeRepresentation {
  public careercup.linkedin.BinaryTreeRepresentation();
  public int getTreeDepth(java.lang.String);
  public int getTreeDepth(java.util.Queue<java.lang.Character>, int, int);
  public static void main(java.lang.String[]);
}
Compiled from "BlockingQueue.java"
public class careercup.linkedin.BlockingQueue<T> {
  public careercup.linkedin.BlockingQueue(int);
  public synchronized void enqueue(T) throws java.lang.InterruptedException;
  public synchronized T dequeue() throws java.lang.InterruptedException;
}
Compiled from "KthElementToLast.java"
public interface careercup.linkedin.KthElementToLast<T> {
  public abstract T getKthElementToLast(careercup.linkedin.MyList<T>, int);
}
Compiled from "KthElementToLast.java"
class careercup.linkedin.KthElementToLastPointers<T> implements careercup.linkedin.KthElementToLast<T> {
  careercup.linkedin.KthElementToLastPointers();
  public T getKthElementToLast(careercup.linkedin.MyList<T>, int);
}
Compiled from "KthElementToLast.java"
class careercup.linkedin.KthElementToLastQueue<T> implements careercup.linkedin.KthElementToLast<T> {
  careercup.linkedin.KthElementToLastQueue();
  public T getKthElementToLast(careercup.linkedin.MyList<T>, int);
}
Compiled from "KthElementToLast.java"
class careercup.linkedin.KthElementToLastTest {
  careercup.linkedin.KthElementToLastTest();
  public static void main(java.lang.String[]);
}
Compiled from "KthElementToLast.java"
class careercup.linkedin.ListNode<T> {
  T data;
  careercup.linkedin.ListNode<T> next;
  careercup.linkedin.ListNode(T);
}
Compiled from "LogWithBitManipulation.java"
public class careercup.linkedin.LogWithBitManipulation {
  public careercup.linkedin.LogWithBitManipulation();
  public static int log2(int);
  public static void main(java.lang.String[]);
}
Compiled from "MaxSubarrayKadane.java"
public class careercup.linkedin.MaxSubarrayKadane {
  public careercup.linkedin.MaxSubarrayKadane();
  public int getMaxSubarray(int[]);
}
Compiled from "MaxSubarrayRecursive.java"
public class careercup.linkedin.MaxSubarrayRecursive {
  public careercup.linkedin.MaxSubarrayRecursive();
  public careercup.linkedin.MaxSubarrayRecursive$Subarray getMaxSubarray(int[]);
  public static void main(java.lang.String[]);
}
Compiled from "MaxSubarrayRecursive.java"
class careercup.linkedin.MaxSubarrayRecursive$Subarray {
  int left;
  int right;
  int sum;
  final careercup.linkedin.MaxSubarrayRecursive this$0;
  careercup.linkedin.MaxSubarrayRecursive$Subarray(careercup.linkedin.MaxSubarrayRecursive, int, int, int);
  careercup.linkedin.MaxSubarrayRecursive$Subarray(careercup.linkedin.MaxSubarrayRecursive);
  public java.lang.String toString();
}
Compiled from "MinDiffInSortedArrays.java"
public class careercup.linkedin.MinDiffInSortedArrays {
  public careercup.linkedin.MinDiffInSortedArrays();
  public int getMinDiff(int[], int[]);
  public static void main(java.lang.String[]);
}
Compiled from "KthElementToLast.java"
class careercup.linkedin.MyList<T> {
  careercup.linkedin.ListNode<T> root;
  careercup.linkedin.MyList();
  public careercup.linkedin.MyList<T> add(T);
  public careercup.linkedin.ListNode<T> getRoot();
}
Compiled from "PostfixExpression.java"
public class careercup.linkedin.PostfixExpression {
  public careercup.linkedin.PostfixExpression();
  public static double calculate(java.lang.String);
  public static void main(java.lang.String[]);
}
Compiled from "ReverseStringRecursively.java"
public class careercup.linkedin.ReverseStringRecursively {
  public careercup.linkedin.ReverseStringRecursively();
  public java.lang.String reverse(java.lang.String);
  public static void main(java.lang.String[]);
}
Compiled from "SearchInRotatedArray.java"
public class careercup.linkedin.SearchInRotatedArray {
  public careercup.linkedin.SearchInRotatedArray();
  public static int findElement(int[], int);
  public static int findElementInRotatedSorted(int[], int, int, int);
  public static int findElement2(int[], int);
  public static void main(java.lang.String[]);
}
Compiled from "SortedSetsCommonElement.java"
public class careercup.linkedin.SortedSetsCommonElement {
  public careercup.linkedin.SortedSetsCommonElement();
  java.util.List<java.lang.Integer> getCommonElements(java.util.Set<java.lang.Integer>, java.util.Set<java.lang.Integer>);
  public static void main(java.lang.String[]);
}
Compiled from "WordPatternMatcher.java"
public class careercup.linkedin.WordPatternMatcher {
  public careercup.linkedin.WordPatternMatcher();
  public java.lang.String getShortestString(java.lang.String, java.util.List<java.lang.String>);
  public static void main(java.lang.String[]);
}
Compiled from "ListNode.java"
public class common.ListNode {
  public int data;
  public common.ListNode next;
  public common.ListNode(int, common.ListNode);
  public common.ListNode(int);
  public java.lang.String toString();
}
Compiled from "TreeNode.java"
public class common.TreeNode {
  public int data;
  public common.TreeNode left;
  public common.TreeNode right;
  public common.TreeNode(int);
  public common.TreeNode(int, common.TreeNode, common.TreeNode);
  public java.lang.String toString();
}
Compiled from "TreeParentNode.java"
public class common.TreeParentNode<T> {
  public T data;
  public common.TreeParentNode<T> left;
  public common.TreeParentNode<T> right;
  public common.TreeParentNode<T> parent;
  public common.TreeParentNode(T, common.TreeParentNode<T>);
  public common.TreeParentNode();
}
Compiled from "DfsOrder.java"
public class common.graph.DfsOrder {
  public common.graph.DfsOrder(common.graph.Graph);
  public java.lang.Iterable<java.lang.Integer> getPreorder();
  public java.lang.Iterable<java.lang.Integer> getPostorder();
  public java.lang.Iterable<java.lang.Integer> getReversedPostorder();
  public boolean hasCycle();
}
Compiled from "Edge.java"
public class common.graph.Edge {
  public common.graph.Edge(int, int, double);
  public int getFrom();
  public int getTo();
  public double getWeight();
  public int other(int);
}
Compiled from "Graph.java"
public class common.graph.Graph {
  public common.graph.Graph(int);
  public java.util.Collection<common.graph.Edge> adjacent(int);
  public void addEdge(common.graph.Edge);
  public void addEdge(int, int, double);
  public java.lang.Iterable<common.graph.Edge> getAllEdges();
  public int getSize();
  public common.graph.Graph reverse();
}
Compiled from "MaxSubarrayDiff.java"
public class crackinginterview.MaxSubarrayDiff {
  public crackinginterview.MaxSubarrayDiff();
  public crackinginterview.MaxSubarrayDiff$Subarray getMaxSubarray(int[]);
  public static void main(java.lang.String[]);
}
Compiled from "MaxSubarrayDiff.java"
class crackinginterview.MaxSubarrayDiff$Subarray {
  int left;
  int right;
  int sum;
  crackinginterview.MaxSubarrayDiff$Subarray();
  public java.lang.String toString();
}
Compiled from "MatrixRotation.java"
public class crackinginterview.chap1arraysstrings.MatrixRotation {
  public crackinginterview.chap1arraysstrings.MatrixRotation();
  public void rotateClockwise(int[][]);
  public static void main(java.lang.String[]);
}
Compiled from "DeleteListNode.java"
public class crackinginterview.chap2linkedlists.DeleteListNode {
  public crackinginterview.chap2linkedlists.DeleteListNode();
  public void deleteNode(common.ListNode);
}
Compiled from "KthToLastInList.java"
public class crackinginterview.chap2linkedlists.KthToLastInList {
  public crackinginterview.chap2linkedlists.KthToLastInList();
  public common.ListNode getKthToLastInList(common.ListNode, int, crackinginterview.chap2linkedlists.KthToLastInList$MutableInt);
  public static void main(java.lang.String[]);
}
Compiled from "KthToLastInList.java"
class crackinginterview.chap2linkedlists.KthToLastInList$MutableInt {
  int value;
  crackinginterview.chap2linkedlists.KthToLastInList$MutableInt(int);
  public java.lang.String toString();
}
Compiled from "HanoiTowersOOP.java"
public class crackinginterview.chap3stackqueues.HanoiTowersOOP {
  public crackinginterview.chap3stackqueues.HanoiTowersOOP(crackinginterview.chap3stackqueues.HanoiTowersOOP$Tower, crackinginterview.chap3stackqueues.HanoiTowersOOP$Tower, crackinginterview.chap3stackqueues.HanoiTowersOOP$Tower);
  public void moveDisks(crackinginterview.chap3stackqueues.HanoiTowersOOP$Tower, int, crackinginterview.chap3stackqueues.HanoiTowersOOP$Tower, crackinginterview.chap3stackqueues.HanoiTowersOOP$Tower);
  public static void main(java.lang.String[]);
}
Compiled from "HanoiTowersOOP.java"
class crackinginterview.chap3stackqueues.HanoiTowersOOP$Tower {
  int index;
  java.util.Stack<java.lang.Integer> disks;
  crackinginterview.chap3stackqueues.HanoiTowersOOP$Tower(int);
  int getHeight();
  void addDisk(int);
}
Compiled from "TreePathsSum.java"
public class crackinginterview.chap4trees.TreePathsSum {
  public crackinginterview.chap4trees.TreePathsSum();
  public void findSumFrom(common.TreeNode, common.TreeNode, int, int, java.util.Stack<common.TreeNode>);
  public void findAllSums(common.TreeNode, int);
  public static void main(java.lang.String[]);
}
Compiled from "PermutationChopoffString.java"
public class crackinginterview.chap9recursion.PermutationChopoffString {
  public crackinginterview.chap9recursion.PermutationChopoffString();
  public java.util.List<java.lang.String> permut(java.lang.String, int);
  public static void main(java.lang.String[]);
}
Compiled from "PermutationUsed.java"
public class crackinginterview.chap9recursion.PermutationUsed {
  public crackinginterview.chap9recursion.PermutationUsed();
  public void permut(char[], char[], boolean[], int, java.util.List<java.lang.String>);
  public java.util.List<java.lang.String> permut(java.lang.String);
  public static void main(java.lang.String[]);
}
Compiled from "PowersetInt.java"
public class crackinginterview.chap9recursion.PowersetInt {
  public crackinginterview.chap9recursion.PowersetInt();
  public java.util.List<java.util.List<java.lang.String>> powerset(java.util.List<java.lang.String>);
  public static void main(java.lang.String[]);
}
Compiled from "PowersetRecursive.java"
public class crackinginterview.chap9recursion.PowersetRecursive {
  public crackinginterview.chap9recursion.PowersetRecursive();
  public java.util.List<java.util.List<java.lang.String>> powerset(java.util.List<java.lang.String>, int);
  public static void main(java.lang.String[]);
}
Compiled from "BSTFromPreorder.java"
public class leetcode.BSTFromPreorder {
  public leetcode.BSTFromPreorder();
  public static common.TreeNode buildBSTFromPreorder(int, int, int[], int[]);
  public static void main(java.lang.String[]);
}
Compiled from "BestTimeToBuyStock.java"
public class leetcode.BestTimeToBuyStock {
  public leetcode.BestTimeToBuyStock();
  public static int[] getBestBuyAndSellTimes(int[]);
}
Compiled from "QueueWithStacks.java"
public class leetcode.QueueWithStacks<T> {
  java.util.Stack<T> in;
  java.util.Stack<T> out;
  public leetcode.QueueWithStacks();
  public void enqueue(T);
  public T dequeue();
  public static void main(java.lang.String[]);
}
Compiled from "StackWithMin.java"
public class leetcode.StackWithMin {
  public leetcode.StackWithMin();
  public void push(int);
  public int pop();
  public int getMin();
}
Compiled from "SubstringWithoutRepeating.java"
public class leetcode.SubstringWithoutRepeating {
  public leetcode.SubstringWithoutRepeating();
  public static java.lang.String getLongestSubstringWithoutRepeating(java.lang.String);
  public static void main(java.lang.String[]);
}
Compiled from "TreeBSTTest.java"
public class leetcode.TreeBSTTest {
  public leetcode.TreeBSTTest();
  public static boolean isBSTRange(common.TreeNode, int, int);
  public static boolean isBSTInOrder(common.TreeNode, int);
  public static void main(java.lang.String[]);
}
Compiled from "TreeFromInPreOrder.java"
public class leetcode.TreeFromInPreOrder {
  public leetcode.TreeFromInPreOrder();
  public common.TreeNode buildInorderPreorder(int[], int[]);
  public common.TreeNode buildInorderPreorder(int[], leetcode.TreeFromInPreOrder$MutableInt, int, int[], int, int);
  public static void main(java.lang.String[]);
}
Compiled from "TreeFromInPreOrder.java"
class leetcode.TreeFromInPreOrder$MutableInt {
  int i;
  final leetcode.TreeFromInPreOrder this$0;
  leetcode.TreeFromInPreOrder$MutableInt(leetcode.TreeFromInPreOrder, int);
}
Compiled from "TreeLevelByLevel.java"
public class leetcode.TreeLevelByLevel {
  public leetcode.TreeLevelByLevel();
  public static void print(common.TreeNode);
  public static void printWithSpaces(common.TreeNode);
  public static void main(java.lang.String[]);
}
Compiled from "TreeSiblingPointers.java"
public class leetcode.TreeSiblingPointers {
  public leetcode.TreeSiblingPointers();
  public static void connect(leetcode.TreeSiblingPointers$SiblingNode);
  public static void main(java.lang.String[]);
}
Compiled from "TreeSiblingPointers.java"
class leetcode.TreeSiblingPointers$SiblingNode {
  int data;
  leetcode.TreeSiblingPointers$SiblingNode left;
  leetcode.TreeSiblingPointers$SiblingNode right;
  leetcode.TreeSiblingPointers$SiblingNode nextSibling;
  leetcode.TreeSiblingPointers$SiblingNode(int);
  leetcode.TreeSiblingPointers$SiblingNode(int, leetcode.TreeSiblingPointers$SiblingNode, leetcode.TreeSiblingPointers$SiblingNode);
  public java.lang.String toString();
}
Compiled from "Solution.java"
public class leetcode.oj.Solution {
  public leetcode.oj.Solution();
  public int[] twoSum(int[], int);
  public int evalRPN(java.lang.String[]);
  public java.util.ArrayList<java.lang.Integer> preorderTraversal(leetcode.oj.Solution$TreeNode);
  public java.util.ArrayList<java.lang.Integer> postorderTraversal(leetcode.oj.Solution$TreeNode);
  public int lengthOfLongestSubstring(java.lang.String);
  public double findMedianSortedArrays(int[], int[]);
  public leetcode.oj.Solution$ListNode addTwoNumbers(leetcode.oj.Solution$ListNode, leetcode.oj.Solution$ListNode);
  public java.lang.String longestPalindrome(java.lang.String);
  public java.lang.String convert(java.lang.String, int);
  public int reverse(int);
  public int atoi(java.lang.String);
  public boolean isPalindrome(int);
  public boolean isMatch(java.lang.String, java.lang.String);
  public int maxArea(int[]);
  public java.lang.String intToRoman(int);
  public int romanToInt(java.lang.String);
  public java.lang.String longestCommonPrefix(java.lang.String[]);
  public java.util.ArrayList<java.util.ArrayList<java.lang.Integer>> threeSum(int[]);
  public int threeSumClosest(int[], int);
  public java.util.List<java.util.List<java.lang.Integer>> fourSum(int[], int);
  public java.util.List<java.util.List<java.lang.Integer>> kSum(int[], int, int);
  public java.util.ArrayList<java.lang.String> letterCombinations(java.lang.String);
  public leetcode.oj.Solution$ListNode removeNthFromEnd(leetcode.oj.Solution$ListNode, int);
  public boolean isValid(java.lang.String);
  public java.util.ArrayList<java.lang.String> generateParenthesis(int);
  public int maxPoints(leetcode.oj.Solution$Point[]);
  public int maxProfitI(int[]);
  public int maxProfitII(int[]);
  public int maxProfitIII(int[]);
  public leetcode.oj.Solution$ListNode mergeKLists(java.util.ArrayList<leetcode.oj.Solution$ListNode>);
  public leetcode.oj.Solution$ListNode swapPairs(leetcode.oj.Solution$ListNode);
  public leetcode.oj.Solution$ListNode reverseKGroup(leetcode.oj.Solution$ListNode, int);
  public int removeDuplicates(int[]);
  public int removeElement(int[], int);
  public leetcode.oj.Solution$ListNode insertionSortList(leetcode.oj.Solution$ListNode);
  public java.lang.String strStr(java.lang.String, java.lang.String);
  public java.lang.String strStrBoyerMoore(java.lang.String, java.lang.String);
  public int divide(int, int);
  public java.util.List<java.lang.Integer> findSubstring(java.lang.String, java.lang.String[]);
  public void nextPermutation(int[]);
  public int longestValidParentheses(java.lang.String);
  public int search(int[], int);
  public int[] searchRange(int[], int);
  public int searchInsert(int[], int);
  public boolean isValidSudoku(char[][]);
  public void solveSudoku(char[][]);
  public java.lang.String countAndSay(int);
  public leetcode.oj.Solution$ListNode sortList(leetcode.oj.Solution$ListNode);
  public java.util.ArrayList<java.util.ArrayList<java.lang.Integer>> combinationSum(int[], int);
  public java.util.ArrayList<java.util.ArrayList<java.lang.Integer>> combinationSum2(int[], int);
  public int firstMissingPositive(int[]);
  public int trap(int[]);
  public java.lang.String multiply(java.lang.String, java.lang.String);
  public boolean isWildcardMatch(java.lang.String, java.lang.String);
  public boolean canJump(int[]);
  public int jump(int[]);
  public java.util.ArrayList<java.util.ArrayList<java.lang.Integer>> permute(int[]);
  public java.util.ArrayList<java.util.ArrayList<java.lang.Integer>> permuteUnique(int[]);
  public void rotate(int[][]);
  public java.util.ArrayList<java.lang.String> anagrams(java.lang.String[]);
  public double pow(double, int);
  public java.util.ArrayList<java.lang.String[]> solveNQueens(int);
  public int totalNQueens(int);
  public int maxSubArray(int[]);
  public java.util.ArrayList<java.lang.Integer> spiralOrder(int[][]);
  public java.util.ArrayList<leetcode.oj.Solution$Interval> merge(java.util.ArrayList<leetcode.oj.Solution$Interval>);
  public java.util.ArrayList<leetcode.oj.Solution$Interval> insert(java.util.ArrayList<leetcode.oj.Solution$Interval>, leetcode.oj.Solution$Interval);
  public int lengthOfLastWord(java.lang.String);
  public int[][] generateMatrix(int);
  public java.lang.String getPermutation(int, int);
  public leetcode.oj.Solution$ListNode rotateRight(leetcode.oj.Solution$ListNode, int);
  public int uniquePaths(int, int);
  public int uniquePathsWithObstacles(int[][]);
}
Compiled from "Solution.java"
class leetcode.oj.Solution$1 implements java.util.Comparator<leetcode.oj.Solution$ListNode> {
  final leetcode.oj.Solution this$0;
  leetcode.oj.Solution$1(leetcode.oj.Solution);
  public int compare(leetcode.oj.Solution$ListNode, leetcode.oj.Solution$ListNode);
  public int compare(java.lang.Object, java.lang.Object);
}
Compiled from "Solution.java"
class leetcode.oj.Solution$2 implements java.util.Comparator<leetcode.oj.Solution$Interval> {
  final leetcode.oj.Solution this$0;
  leetcode.oj.Solution$2(leetcode.oj.Solution);
  public int compare(leetcode.oj.Solution$Interval, leetcode.oj.Solution$Interval);
  public int compare(java.lang.Object, java.lang.Object);
}
Compiled from "Solution.java"
class leetcode.oj.Solution$Interval {
  int start;
  int end;
  leetcode.oj.Solution$Interval();
  leetcode.oj.Solution$Interval(int, int);
  public boolean equals(java.lang.Object);
  public int hashCode();
  public java.lang.String toString();
}
Compiled from "Solution.java"
public class leetcode.oj.Solution$LRUCache {
  public leetcode.oj.Solution$LRUCache(int);
  public int get(int);
  public void set(int, int);
}
Compiled from "Solution.java"
class leetcode.oj.Solution$LRUCache$Node {
  int data;
  leetcode.oj.Solution$LRUCache$Node prev;
  leetcode.oj.Solution$LRUCache$Node next;
  final leetcode.oj.Solution$LRUCache this$0;
  leetcode.oj.Solution$LRUCache$Node(leetcode.oj.Solution$LRUCache, int, leetcode.oj.Solution$LRUCache$Node, leetcode.oj.Solution$LRUCache$Node);
}
Compiled from "Solution.java"
public class leetcode.oj.Solution$ListNode {
  int val;
  leetcode.oj.Solution$ListNode next;
  static leetcode.oj.Solution$ListNode build(int...);
  leetcode.oj.Solution$ListNode(int);
  leetcode.oj.Solution$ListNode(int, leetcode.oj.Solution$ListNode);
  public java.lang.String toString();
  public boolean equals(java.lang.Object);
  public int hashCode();
}
Compiled from "Solution.java"
public class leetcode.oj.Solution$Point {
  int x;
  int y;
  leetcode.oj.Solution$Point(int, int);
}
Compiled from "Solution.java"
public class leetcode.oj.Solution$TreeNode {
  int val;
  leetcode.oj.Solution$TreeNode left;
  leetcode.oj.Solution$TreeNode right;
  leetcode.oj.Solution$TreeNode(int);
  leetcode.oj.Solution$TreeNode(int, leetcode.oj.Solution$TreeNode, leetcode.oj.Solution$TreeNode);
  public java.lang.String toString();
  public boolean equals(java.lang.Object);
  public int hashCode();
}
Compiled from "Solution2.java"
public class leetcode.oj.Solution2 {
  public leetcode.oj.Solution2();
  public int minPathSum(int[][]);
  public leetcode.oj.Solution$ListNode mergeTwoLists(leetcode.oj.Solution$ListNode, leetcode.oj.Solution$ListNode);
  public java.lang.String addBinary(java.lang.String, java.lang.String);
  public boolean isNumber(java.lang.String);
  public int[] plusOne(int[]);
  public java.util.ArrayList<java.lang.String> fullJustify(java.lang.String[], int);
  public int climbStairs(int);
  public java.lang.String simplifyPath(java.lang.String);
  public int minDistance(java.lang.String, java.lang.String);
  public void setZeroes(int[][]);
  public java.lang.String minWindow(java.lang.String, java.lang.String);
  public boolean searchMatrix(int[][], int);
  public void sortColors(int[]);
  public boolean exist(char[][], java.lang.String);
  public java.util.ArrayList<java.util.ArrayList<java.lang.Integer>> combine(int, int);
  public java.util.ArrayList<java.util.ArrayList<java.lang.Integer>> subsets(int[]);
  public int removeDuplicates(int[]);
  public boolean search(int[], int);
  public leetcode.oj.Solution$ListNode deleteDuplicates(leetcode.oj.Solution$ListNode);
  public leetcode.oj.Solution$ListNode deleteDuplicatesII(leetcode.oj.Solution$ListNode);
  public int largestRectangleArea(int[]);
  public java.util.ArrayList<java.lang.Integer> inorderTraversal(leetcode.oj.Solution$TreeNode);
  public int numTrees(int);
  public java.util.ArrayList<leetcode.oj.Solution$TreeNode> generateTrees(int);
  public boolean isValidBST(leetcode.oj.Solution$TreeNode);
  public boolean isSameTree(leetcode.oj.Solution$TreeNode, leetcode.oj.Solution$TreeNode);
  public leetcode.oj.Solution$TreeNode buildTree(int[], int[]);
  public boolean isSymmetric(leetcode.oj.Solution$TreeNode);
  public int maximalRectangle(char[][]);
  public leetcode.oj.Solution$ListNode partition(leetcode.oj.Solution$ListNode, int);
  public boolean isInterleave(java.lang.String, java.lang.String, java.lang.String);
  public void reorderList(leetcode.oj.Solution$ListNode);
  public java.util.ArrayList<java.util.ArrayList<java.lang.Integer>> levelOrder(leetcode.oj.Solution$TreeNode);
  public boolean isScramble(java.lang.String, java.lang.String);
  public void merge(int[], int, int[], int);
  public java.util.ArrayList<java.lang.Integer> grayCode(int);
  public int numDecodings(java.lang.String);
  public int numDecodings(java.lang.String, java.util.Map<java.lang.String, java.lang.Integer>);
  public java.util.ArrayList<java.util.ArrayList<java.lang.Integer>> subsetsWithDup(int[]);
  public java.util.ArrayList<java.lang.String> restoreIpAddresses(java.lang.String);
  public int singleNumber(int[]);
  public int singleNumberII(int[]);
  public int maxDepth(leetcode.oj.Solution$TreeNode);
  public int minDepth(leetcode.oj.Solution$TreeNode);
  public java.util.ArrayList<java.util.ArrayList<java.lang.Integer>> levelOrderBottom(leetcode.oj.Solution$TreeNode);
  public java.util.ArrayList<java.util.ArrayList<java.lang.Integer>> zigzagLevelOrder(leetcode.oj.Solution$TreeNode);
  public leetcode.oj.Solution$TreeNode sortedArrayToBST(int[]);
  public boolean isBalanced(leetcode.oj.Solution$TreeNode);
  public boolean hasCycle(leetcode.oj.Solution$ListNode);
  public leetcode.oj.Solution$ListNode detectCycle(leetcode.oj.Solution$ListNode);
  public int longestConsecutive(int[]);
  public boolean hasPathSum(leetcode.oj.Solution$TreeNode, int);
  public boolean hasPathSumRecursive(leetcode.oj.Solution$TreeNode, int);
  public leetcode.oj.Solution$TreeNode sortedListToBST(leetcode.oj.Solution$ListNode);
  public leetcode.oj.Solution$ListNode reverseBetween(leetcode.oj.Solution$ListNode, int, int);
  public java.util.ArrayList<java.util.ArrayList<java.lang.Integer>> pathSum(leetcode.oj.Solution$TreeNode, int);
  public leetcode.oj.Solution$TreeNode buildTreePost(int[], int[]);
  public leetcode.oj.Solution$TreeNode buildTreePost(int[], int, int, int[], int[]);
  public boolean wordBreak(java.lang.String, java.util.Set<java.lang.String>);
  public java.util.ArrayList<java.lang.String> wordBreakII(java.lang.String, java.util.Set<java.lang.String>);
  public void flatten(leetcode.oj.Solution$TreeNode);
  public int maxPathSum(leetcode.oj.Solution$TreeNode);
  public int sumNumbers(leetcode.oj.Solution$TreeNode);
  public leetcode.oj.Solution2$RandomListNode copyRandomList(leetcode.oj.Solution2$RandomListNode);
  public void recoverTree(leetcode.oj.Solution$TreeNode);
  public int minimumTotal(java.util.ArrayList<java.util.ArrayList<java.lang.Integer>>);
  public void connect(leetcode.oj.Solution2$TreeLinkNode);
  public void connectII(leetcode.oj.Solution2$TreeLinkNode);
  public java.util.ArrayList<java.util.ArrayList<java.lang.Integer>> generate(int);
  public java.util.ArrayList<java.lang.Integer> getRow(int);
  public boolean isPalindrome(java.lang.String);
  public void solve(char[][]);
  public leetcode.oj.Solution2$UndirectedGraphNode cloneGraph(leetcode.oj.Solution2$UndirectedGraphNode);
}
Compiled from "Solution2.java"
final class leetcode.oj.Solution2$Input extends java.lang.Enum<leetcode.oj.Solution2$Input> {
  public static final leetcode.oj.Solution2$Input INVALID;
  public static final leetcode.oj.Solution2$Input SPACE;
  public static final leetcode.oj.Solution2$Input SIGN;
  public static final leetcode.oj.Solution2$Input EXPONENT;
  public static final leetcode.oj.Solution2$Input DIGIT;
  public static final leetcode.oj.Solution2$Input DOT;
  int value;
  public static leetcode.oj.Solution2$Input[] values();
  public static leetcode.oj.Solution2$Input valueOf(java.lang.String);
  public static leetcode.oj.Solution2$Input of(char);
  static {};
}
Compiled from "Solution2.java"
class leetcode.oj.Solution2$RandomListNode {
  int label;
  leetcode.oj.Solution2$RandomListNode next;
  leetcode.oj.Solution2$RandomListNode random;
  leetcode.oj.Solution2$RandomListNode(int);
}
Compiled from "Solution2.java"
final class leetcode.oj.Solution2$State extends java.lang.Enum<leetcode.oj.Solution2$State> {
  public static final leetcode.oj.Solution2$State START_SPACE;
  public static final leetcode.oj.Solution2$State START_DIGIT;
  public static final leetcode.oj.Solution2$State SIGN_READ;
  public static final leetcode.oj.Solution2$State DOT_READ;
  public static final leetcode.oj.Solution2$State DIGIT_AFTER_DOT;
  public static final leetcode.oj.Solution2$State EXPONENT;
  public static final leetcode.oj.Solution2$State EXPONENT_SIGN;
  public static final leetcode.oj.Solution2$State EXPONENT_DIGIT;
  public static final leetcode.oj.Solution2$State END_SPACE;
  int value;
  public static leetcode.oj.Solution2$State[] values();
  public static leetcode.oj.Solution2$State valueOf(java.lang.String);
  static {};
}
Compiled from "Solution2.java"
class leetcode.oj.Solution2$Transition {
  leetcode.oj.Solution2$State state;
  leetcode.oj.Solution2$Input input;
  leetcode.oj.Solution2$Transition(leetcode.oj.Solution2$State, leetcode.oj.Solution2$Input);
  public boolean equals(java.lang.Object);
  public int hashCode();
}
Compiled from "Solution2.java"
class leetcode.oj.Solution2$TreeLinkNode {
  int val;
  leetcode.oj.Solution2$TreeLinkNode left;
  leetcode.oj.Solution2$TreeLinkNode right;
  leetcode.oj.Solution2$TreeLinkNode next;
  leetcode.oj.Solution2$TreeLinkNode(int);
  leetcode.oj.Solution2$TreeLinkNode(int, leetcode.oj.Solution2$TreeLinkNode, leetcode.oj.Solution2$TreeLinkNode);
  public java.lang.String toString();
}
Compiled from "Solution2.java"
class leetcode.oj.Solution2$UndirectedGraphNode {
  int label;
  java.util.ArrayList<leetcode.oj.Solution2$UndirectedGraphNode> neighbors;
  leetcode.oj.Solution2$UndirectedGraphNode(int);
}
Compiled from "Solution2Test.java"
public class leetcode.oj.Solution2Test {
  public leetcode.oj.Solution2Test();
  public static void main(java.lang.String[]);
  public void testMinPathSum();
  public void testMergeTwoLists();
  public void testAddBinary();
  public void testPlusOne();
  public void testIsNumber();
  public void testFullJustify();
  public void testClimbStairs();
  public void testSimplifyPath();
  public void testMinDistance();
  public void testSetZeros();
  public void testMinWindow();
  public void testSearchMatrix();
  public void testSortColors();
  public void testExist();
  public void testCombine();
  public void testSubsets();
  public void testRemoveDuplicates();
  public void testSearch();
  public void testDeleteDuplicates();
  public void testDeleteDuplicatesII();
  public void testLargestRectangleArea();
  public void testInorderTraversal();
  public void testNumTrees();
  public void testGenerateTrees();
  public void testIsValidBST();
  public void testIsSameTree();
  public void testBuildTree();
  public void testIsSymmetric();
  public void testMaximalRectangle();
  public void testPartition();
  public void testIsInterleave();
  public void testReorderList();
  public void testLevelOrder();
  public void testIsScramble();
  public void testMerge();
  public void testGrayCode();
  public void testNumDecoings();
  public void testSubsetsWithDup();
  public void testRestoreIp();
  public void testSingleNumber();
  public void testSingleNumberII();
  public void testMaxDepth();
  public void testMinDepth();
  public void testLevelOrderBottom();
  public void testZigzagLevelOrder();
  public void testSortedArrayToBST();
  public void testIsBalanced();
  public void testHasCycle();
  public void testDetectCycle();
  public void testLongestConsecutive();
  public void testHasPathSum();
  public void testSortedListToBST();
  public void testReverseBetween();
  public void testPathSum();
  public void testBuildTreePost();
  public void testWordBreak();
  public void testWordBreakII();
  public void testFlatten();
  public void testMaxPathSum();
  public void testSumNumbers();
  public void testCopyRandomList();
  public void testRecoverTree();
  public void testMinimumTotal();
  public void testConnect();
  public void testConnectII();
  public void testGenerate();
  public void testGetRow();
  public void testIsPalindrome();
  public void testSolve();
  public void testCloneGraph();
}
Compiled from "SolutionTest.java"
public class leetcode.oj.SolutionTest {
  public leetcode.oj.SolutionTest();
  public static void main(java.lang.String[]);
  public void testTwoSum();
  public void testEvalRPN();
  public void testPostorderTraversal();
  public void testPreorderTraversal();
  public void testLengthOfLongestSubstring();
  public void testFindMedianSortedArrays();
  public void testAddTwoNumbers();
  public void testLongestPalindrome();
  public void testZigzagConvert();
  public void testReverse();
  public void testAtoi();
  public void testIsPalindrome();
  public void testIsMatch();
  public void testMaxArea();
  public void testIntToRoman();
  public void testRomanToInt();
  public void testLongestCommonPrefix();
  public void testThreeSum();
  public void testThreeSumClosest();
  public void testFourSum();
  public void testKSum();
  public void testLetterCombinations();
  public void testIsValid();
  public void testGenerateParenthesis();
  public void testMaxPoints();
  public void testMaxProfitI();
  public void testMaxProfitII();
  public void testMaxProfitIII();
  public void testMergeKLists();
  public void testSwapPairs();
  public void testReverseKGroup();
  public void testRemoveDuplicates();
  public void testRemoveElement();
  public void testInsertionSortList();
  public void testStrStr();
  public void testDivide();
  public void testFindSubstring();
  public void testNextPermutation();
  public void testLongestValidParentheses();
  public void testSearch();
  public void testSearchRange();
  public void testSearchInsert();
  public void testIsValidSudoku();
  public void testSolveSudoku();
  public void testCountAndSay();
  public void testLRUCache();
  public void testSortList();
  public void testCombinationSum();
  public void testCombinationSum2();
  public void testFirstMissingPositive();
  public void testTrap();
  public void testMultiply();
  public void testIsWildcardMatch();
  public void testCanJump();
  public void testJump();
  public void testPermute();
  public void testPermuteUnique();
  public void testRotate();
  public void testAnagrams();
  public void testPow();
  public void testSolveNQueens();
  public void testTotalNQueens();
  public void testMaxSubArray();
  public void testSpiralOrder();
  public void testMerge();
  public void testInsert();
  public void testLengthOfLastWord();
  public void testGenerateMatrix();
  public void testGetPermutation();
  public void testRotateRight();
  public void testUniquePaths();
  public void testUniquePathsWithObstacles();
}
Compiled from "TestUtils.java"
public class leetcode.oj.TestUtils {
  public leetcode.oj.TestUtils();
  public static void assertEquals(java.lang.Object, java.lang.Object);
  public static void assertEquals(int[], int[]);
  public static void assertEquals(int[], int[], int);
  public static void assertEquals(java.lang.String[], java.lang.String[]);
  public static void assertArrayEquals(char[][], char[][]);
  public static void assertArrayEquals(int[][], int[][]);
  public static <T> java.util.ArrayList<T> arrayListOf(T, T...);
  public static <T> java.util.ArrayList<T> arrayListOf();
  public static <T> java.util.ArrayList<java.util.ArrayList<T>> arrayListOf(java.util.ArrayList<T>);
  public static <T> java.util.ArrayList<java.util.ArrayList<T>> arrayListOf(java.util.ArrayList<T>, java.util.ArrayList<T>);
  public static <T> java.util.ArrayList<java.util.ArrayList<T>> arrayListOf(java.util.ArrayList<T>, java.util.ArrayList<T>, java.util.ArrayList<T>);
  public static <T> java.util.ArrayList<java.util.ArrayList<T>> arrayListOf(java.util.ArrayList<T>, java.util.ArrayList<T>, java.util.ArrayList<T>, java.util.ArrayList<T>);
  public static <T> java.util.ArrayList<java.util.ArrayList<T>> arrayListOf(java.util.ArrayList<T>, java.util.ArrayList<T>, java.util.ArrayList<T>, java.util.ArrayList<T>, java.util.ArrayList<T>);
  public static <T> java.util.ArrayList<java.util.ArrayList<T>> arrayListOf(java.util.ArrayList<T>, java.util.ArrayList<T>, java.util.ArrayList<T>, java.util.ArrayList<T>, java.util.ArrayList<T>, java.util.ArrayList<T>);
  public static <T> java.util.ArrayList<java.util.ArrayList<T>> arrayListOf(java.util.ArrayList<T>, java.util.ArrayList<T>, java.util.ArrayList<T>, java.util.ArrayList<T>, java.util.ArrayList<T>, java.util.ArrayList<T>, java.util.ArrayList<T>);
}
Compiled from "BinarySearch.java"
public class other.BinarySearch {
  public other.BinarySearch();
  public int find(int[], int);
}
Compiled from "CheckboardPaint.java"
public class other.CheckboardPaint {
  public other.CheckboardPaint();
  public int[] getPaintedCells();
  public void fillCell(int[], int, int);
  public void fillPixel(int[], int, int);
  public void setBitValue(int[], int);
  public static void main(java.lang.String[]);
}
Compiled from "ChessKing.java"
public class other.ChessKing {
  public other.ChessKing();
  public static boolean move(int, int);
  public static boolean move(int, int, boolean[][], int[][], int[][], int);
  public static void main(java.lang.String[]);
  static {};
}
Compiled from "CupPyramid.java"
public class other.CupPyramid {
  public other.CupPyramid();
  public double getVolume(int, int, double);
  public static void main(java.lang.String[]);
}
Compiled from "HanoiTowers.java"
public class other.HanoiTowers {
  public other.HanoiTowers();
  public static void move(int, int, int, int);
  public static void main(java.lang.String[]);
}
Compiled from "Heap.java"
public class other.Heap<T extends java.lang.Comparable<? extends T>> {
  public other.Heap(other.Heap$Type);
  public void offer(T);
  public T poll();
  public T peek();
  public void build(T[]);
  public static void main(java.lang.String[]);
}
Compiled from "Heap.java"
final class other.Heap$Type extends java.lang.Enum<other.Heap$Type> {
  public static final other.Heap$Type MIN;
  public static final other.Heap$Type MAX;
  public static other.Heap$Type[] values();
  public static other.Heap$Type valueOf(java.lang.String);
  static {};
}
Compiled from "LongestCommonSubsequence.java"
public class other.LongestCommonSubsequence {
  public other.LongestCommonSubsequence();
  public java.lang.String getLCSubsequence(java.lang.String, java.lang.String);
  public static void main(java.lang.String[]);
}
Compiled from "LongestCommonSubstring.java"
public class other.LongestCommonSubstring {
  public other.LongestCommonSubstring();
  public java.util.Set<java.lang.String> getLCS(java.lang.String, java.lang.String);
  public static void main(java.lang.String[]);
}
Compiled from "LongestIncresingSubsequence.java"
public class other.LongestIncresingSubsequence {
  public other.LongestIncresingSubsequence();
  public other.LongestIncresingSubsequence$Subsequence getLongestIncreasingSubsequence(int[]);
  public static void main(java.lang.String[]);
}
Compiled from "LongestIncresingSubsequence.java"
class other.LongestIncresingSubsequence$Subsequence {
  int numOfElements;
  java.util.List<java.lang.Integer> subsequence;
  other.LongestIncresingSubsequence$Subsequence();
  public java.lang.String toString();
}
Compiled from "LongestPathInDag.java"
public class other.LongestPathInDag {
  public other.LongestPathInDag(common.graph.Graph, int);
  public double[] getDistTo();
  public java.lang.Iterable<java.lang.Integer> getPathTo(int);
  public static void main(java.lang.String[]);
}
Compiled from "MaxNumOfElementsInWindow.java"
public class other.MaxNumOfElementsInWindow {
  public other.MaxNumOfElementsInWindow();
  public static other.MaxNumOfElementsInWindow$MaxWindow getMaxWindow(int[], int);
  public static void main(java.lang.String[]);
}
Compiled from "MaxNumOfElementsInWindow.java"
class other.MaxNumOfElementsInWindow$MaxWindow {
  int startIndex;
  int endIndex;
  int num;
  int diff;
  other.MaxNumOfElementsInWindow$MaxWindow();
  public java.lang.String toString();
}
Compiled from "MaxSubarrayPractice.java"
public class other.MaxSubarrayPractice {
  public other.MaxSubarrayPractice();
  public other.MaxSubarrayPractice$Subarray findMaxSubarray(int[]);
  public static void main(java.lang.String[]);
}
Compiled from "MaxSubarrayPractice.java"
class other.MaxSubarrayPractice$Subarray {
  int startIndex;
  int endIndex;
  int sum;
  final other.MaxSubarrayPractice this$0;
  other.MaxSubarrayPractice$Subarray(other.MaxSubarrayPractice);
  public java.lang.String toString();
}
Compiled from "SCC.java"
public class other.SCC {
  public other.SCC(common.graph.Graph);
  public int getSCCNumber();
  public static void main(java.lang.String[]);
}
Compiled from "TrieST.java"
public class other.TrieST<Value> {
  public other.TrieST();
  public Value get(java.lang.String);
  public void put(java.lang.String, Value);
  public java.lang.Iterable<java.lang.String> keysWithPrefix(java.lang.String);
  public java.lang.Iterable<java.lang.String> keys();
  public java.lang.String longestPrefixOf(java.lang.String);
  public static void main(java.lang.String[]);
}
Compiled from "TrieST.java"
class other.TrieST$1 {
}
Compiled from "TrieST.java"
class other.TrieST$Node {
  static java.lang.Object access$000(other.TrieST$Node);
  static other.TrieST$Node[] access$100(other.TrieST$Node);
  other.TrieST$Node(other.TrieST$1);
  static java.lang.Object access$002(other.TrieST$Node, java.lang.Object);
}
Compiled from "WatermarkLevels.java"
public class other.WatermarkLevels {
  public other.WatermarkLevels();
  public int[] getWaterHeights(int[]);
  public static void main(java.lang.String[]);
}
