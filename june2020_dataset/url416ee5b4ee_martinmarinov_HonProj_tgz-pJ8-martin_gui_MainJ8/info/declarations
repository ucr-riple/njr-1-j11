Compiled from "CSVExporter.java"
public class martin.experiments.CSVExporter {
  public martin.experiments.CSVExporter(java.lang.String) throws java.io.IOException;
  public void putRow(java.lang.String, java.lang.Object[]);
  public void putRow(java.lang.String, double[]);
  public void putRow(java.lang.String, java.lang.String...);
  public java.lang.String toString();
  public void saveToFile(java.lang.String) throws java.io.FileNotFoundException;
}
Compiled from "ExperimTest.java"
public class martin.experiments.ExperimTest {
  public martin.experiments.ExperimTest();
  public static void main(java.lang.String[]) throws java.lang.Exception;
  public static martin.experiments.ExperimTest$ExperimentalResult perform(java.lang.String, java.lang.String, java.util.HashMap<java.lang.String, martin.math.Complex>, martin.experiments.ExperimTest$ProgressListener) throws java.lang.Exception;
}
Compiled from "ExperimTest.java"
final class martin.experiments.ExperimTest$1 extends martin.experiments.ExperimTest$ProgressListener {
  martin.experiments.ExperimTest$1();
  public void onProgress(double);
}
Compiled from "ExperimTest.java"
public class martin.experiments.ExperimTest$ExperimentalResult {
  public java.awt.image.BufferedImage image;
  public martin.experiments.CSVExporter csv;
  public martin.experiments.ExperimTest$ExperimentalResult();
}
Compiled from "ExperimTest.java"
public abstract class martin.experiments.ExperimTest$ProgressListener {
  public martin.experiments.ExperimTest$ProgressListener();
  public abstract void onProgress(double);
}
Compiled from "ExperimentVisualizer.java"
public class martin.experiments.ExperimentVisualizer {
  public martin.experiments.ExperimentVisualizer();
  public void add(java.lang.String, java.lang.Double[], java.lang.String, java.lang.Double[]);
  public java.awt.image.BufferedImage getImage();
  public void dumpToFile(java.lang.String) throws java.io.IOException;
}
Compiled from "LabCluster.java"
public class martin.experiments.LabCluster extends martin.quantum.SystemMatrix {
  public martin.experiments.LabCluster(martin.math.MathsItem[]) throws java.lang.Exception;
  public void perform(java.lang.String, int[]) throws java.lang.Exception;
  public static int[] parseBranches(java.lang.String) throws java.lang.Exception;
}
Compiled from "MeasurementCycleNotSupported.java"
public class martin.experiments.MeasurementCycleNotSupported extends java.lang.Exception {
  public martin.experiments.MeasurementCycleNotSupported(java.lang.String, int);
  public martin.experiments.MeasurementCycleNotSupported(java.lang.String);
}
Compiled from "TableStorage.java"
public class martin.experiments.TableStorage<R, C, V> {
  final java.util.ArrayList<R> rowheaders;
  final java.util.ArrayList<C> columns;
  final java.util.ArrayList<java.util.ArrayList<V>> values;
  public martin.experiments.TableStorage();
  public int getRowCount();
  public int getColCount();
  public void putRowHeader(R);
  public void putColumnHeader(C);
  public R getRowHeader(int);
  public C getColumnHeader(int);
  public V getValueAt(int, int);
  public void putValue(V, int);
  public java.lang.String toString();
}
Compiled from "Worksheet.java"
public class martin.experiments.Worksheet {
  public final martin.experiments.TableStorage<java.lang.String, int[], java.lang.Float> storage;
  public martin.experiments.Worksheet(java.lang.String) throws java.lang.Exception;
  protected void finalize() throws java.lang.Throwable;
  public java.lang.String toString();
}
Compiled from "AboutDialog.java"
public class martin.gui.AboutDialog extends javax.swing.JDialog {
  public martin.gui.AboutDialog();
}
Compiled from "AboutDialog.java"
class martin.gui.AboutDialog$1 implements java.awt.event.ActionListener {
  final martin.gui.AboutDialog this$0;
  martin.gui.AboutDialog$1(martin.gui.AboutDialog);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "CircuitSimulatorGUI.java"
public class martin.gui.CircuitSimulatorGUI {
  public void makeVisible();
  public martin.gui.CircuitSimulatorGUI();
  static javax.swing.JFrame access$000(martin.gui.CircuitSimulatorGUI);
  static javax.swing.JFileChooser access$100(martin.gui.CircuitSimulatorGUI);
  static javax.swing.JTextField access$200(martin.gui.CircuitSimulatorGUI);
  static javax.swing.JFileChooser access$300(martin.gui.CircuitSimulatorGUI);
  static javax.swing.JTextPane access$400(martin.gui.CircuitSimulatorGUI);
  static void access$500(martin.gui.CircuitSimulatorGUI, java.lang.Throwable);
  static javax.swing.JTextPane access$600(martin.gui.CircuitSimulatorGUI);
  static javax.swing.JTextPane access$700(martin.gui.CircuitSimulatorGUI);
}
Compiled from "CircuitSimulatorGUI.java"
class martin.gui.CircuitSimulatorGUI$1 implements java.awt.event.ActionListener {
  final martin.gui.CircuitSimulatorGUI this$0;
  martin.gui.CircuitSimulatorGUI$1(martin.gui.CircuitSimulatorGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "CircuitSimulatorGUI.java"
class martin.gui.CircuitSimulatorGUI$2 implements java.awt.event.ActionListener {
  final martin.gui.CircuitSimulatorGUI this$0;
  martin.gui.CircuitSimulatorGUI$2(martin.gui.CircuitSimulatorGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "CircuitSimulatorGUI.java"
class martin.gui.CircuitSimulatorGUI$3 implements java.awt.event.ActionListener {
  final martin.gui.CircuitSimulatorGUI this$0;
  martin.gui.CircuitSimulatorGUI$3(martin.gui.CircuitSimulatorGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "CircuitSimulatorGUI.java"
class martin.gui.CircuitSimulatorGUI$4 implements java.awt.event.ActionListener {
  final martin.gui.CircuitSimulatorGUI this$0;
  martin.gui.CircuitSimulatorGUI$4(martin.gui.CircuitSimulatorGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "EvaluatorGUI.java"
public class martin.gui.EvaluatorGUI {
  final martin.gui.EvaluatorGUI$PrintLogger logger;
  public martin.gui.EvaluatorGUI();
  public void makeVisible();
  public void populateFrom(martin.quantum.McalcDescription);
  static void access$000(martin.gui.EvaluatorGUI) throws java.lang.NumberFormatException, java.lang.Exception;
  static void access$100(martin.gui.EvaluatorGUI, java.lang.Exception);
  static martin.quantum.SystemMatrix access$200(martin.gui.EvaluatorGUI);
  static java.lang.Runtime access$300();
  static javax.swing.JTextField access$400(martin.gui.EvaluatorGUI);
  static javax.swing.JTextPane access$500(martin.gui.EvaluatorGUI);
  static javax.swing.JCheckBox access$600(martin.gui.EvaluatorGUI);
  static javax.swing.JTextPane access$700(martin.gui.EvaluatorGUI);
  static javax.swing.JFrame access$800(martin.gui.EvaluatorGUI);
  static javax.swing.JFileChooser access$900(martin.gui.EvaluatorGUI);
  static martin.quantum.McalcDescription access$1000(martin.gui.EvaluatorGUI);
  static {};
}
Compiled from "EvaluatorGUI.java"
class martin.gui.EvaluatorGUI$1 implements java.awt.event.ActionListener {
  final martin.gui.EvaluatorGUI this$0;
  martin.gui.EvaluatorGUI$1(martin.gui.EvaluatorGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "EvaluatorGUI.java"
class martin.gui.EvaluatorGUI$2 implements java.awt.event.ActionListener {
  final martin.gui.EvaluatorGUI this$0;
  martin.gui.EvaluatorGUI$2(martin.gui.EvaluatorGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "EvaluatorGUI.java"
class martin.gui.EvaluatorGUI$3 implements javax.swing.event.ChangeListener {
  final martin.gui.EvaluatorGUI this$0;
  martin.gui.EvaluatorGUI$3(martin.gui.EvaluatorGUI);
  public void stateChanged(javax.swing.event.ChangeEvent);
}
Compiled from "EvaluatorGUI.java"
class martin.gui.EvaluatorGUI$4 extends javax.swing.JTextPane {
  final martin.gui.EvaluatorGUI this$0;
  martin.gui.EvaluatorGUI$4(martin.gui.EvaluatorGUI);
  public void setBounds(int, int, int, int);
}
Compiled from "EvaluatorGUI.java"
class martin.gui.EvaluatorGUI$5 implements java.awt.event.ActionListener {
  final martin.gui.EvaluatorGUI this$0;
  martin.gui.EvaluatorGUI$5(martin.gui.EvaluatorGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "EvaluatorGUI.java"
class martin.gui.EvaluatorGUI$6 implements java.awt.event.ActionListener {
  final martin.gui.EvaluatorGUI this$0;
  martin.gui.EvaluatorGUI$6(martin.gui.EvaluatorGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "EvaluatorGUI.java"
class martin.gui.EvaluatorGUI$7 implements java.awt.event.ActionListener {
  final martin.gui.EvaluatorGUI this$0;
  martin.gui.EvaluatorGUI$7(martin.gui.EvaluatorGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "EvaluatorGUI.java"
class martin.gui.EvaluatorGUI$PrintLogger extends java.io.PrintStream {
  final martin.gui.EvaluatorGUI this$0;
  public martin.gui.EvaluatorGUI$PrintLogger(martin.gui.EvaluatorGUI);
}
Compiled from "EvaluatorGUI.java"
class martin.gui.EvaluatorGUI$PrintLogger$1 extends java.io.OutputStream {
  final javax.swing.text.SimpleAttributeSet keyWord;
  final martin.gui.EvaluatorGUI val$this$0;
  martin.gui.EvaluatorGUI$PrintLogger$1(martin.gui.EvaluatorGUI);
  public void write(int) throws java.io.IOException;
}
Compiled from "ExperimentConductor.java"
public class martin.gui.ExperimentConductor {
  public martin.gui.ExperimentConductor();
  public void makeVisible();
  static javax.swing.JFrame access$000(martin.gui.ExperimentConductor);
  static javax.swing.JFileChooser access$100(martin.gui.ExperimentConductor);
  static javax.swing.JButton access$200(martin.gui.ExperimentConductor);
  static javax.swing.JButton access$300(martin.gui.ExperimentConductor);
  static javax.swing.JButton access$400(martin.gui.ExperimentConductor);
  static martin.experiments.ExperimTest$ExperimentalResult access$502(martin.gui.ExperimentConductor, martin.experiments.ExperimTest$ExperimentalResult);
  static javax.swing.JTextField access$600(martin.gui.ExperimentConductor);
  static javax.swing.JTextField access$700(martin.gui.ExperimentConductor);
  static javax.swing.JProgressBar access$800(martin.gui.ExperimentConductor);
  static martin.experiments.ExperimTest$ExperimentalResult access$500(martin.gui.ExperimentConductor);
  static martin.gui.ExperimentConductor$ImageViewer access$900(martin.gui.ExperimentConductor);
  static void access$1000(martin.gui.ExperimentConductor, java.lang.Throwable);
  static javax.swing.JFileChooser access$1100(martin.gui.ExperimentConductor);
  static java.lang.String access$1200(java.lang.String);
  static javax.swing.JFileChooser access$1300(martin.gui.ExperimentConductor);
}
Compiled from "ExperimentConductor.java"
class martin.gui.ExperimentConductor$1 implements java.awt.event.ActionListener {
  final martin.gui.ExperimentConductor this$0;
  martin.gui.ExperimentConductor$1(martin.gui.ExperimentConductor);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "ExperimentConductor.java"
class martin.gui.ExperimentConductor$1$1 extends java.lang.Thread {
  final java.io.File val$file;
  final martin.gui.ExperimentConductor$1 this$1;
  martin.gui.ExperimentConductor$1$1(martin.gui.ExperimentConductor$1, java.io.File);
  public void run();
}
Compiled from "ExperimentConductor.java"
class martin.gui.ExperimentConductor$1$1$1 extends martin.experiments.ExperimTest$ProgressListener {
  final martin.gui.ExperimentConductor$1$1 this$2;
  martin.gui.ExperimentConductor$1$1$1(martin.gui.ExperimentConductor$1$1);
  public void onProgress(double);
}
Compiled from "ExperimentConductor.java"
class martin.gui.ExperimentConductor$2 implements java.awt.event.ActionListener {
  final martin.gui.ExperimentConductor this$0;
  martin.gui.ExperimentConductor$2(martin.gui.ExperimentConductor);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "ExperimentConductor.java"
class martin.gui.ExperimentConductor$3 implements java.awt.event.ActionListener {
  final martin.gui.ExperimentConductor this$0;
  martin.gui.ExperimentConductor$3(martin.gui.ExperimentConductor);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "ExperimentConductor.java"
class martin.gui.ExperimentConductor$ImageViewer extends javax.swing.JPanel {
  public void drawImage(java.awt.image.BufferedImage);
  public void paint(java.awt.Graphics);
  martin.gui.ExperimentConductor$ImageViewer(martin.gui.ExperimentConductor$1);
}
Compiled from "GraphicalGUI.java"
public class martin.gui.GraphicalGUI {
  public static void main(java.lang.String[]);
  public martin.gui.GraphicalGUI();
  public javax.swing.JRadioButtonMenuItem getRdbtnmntmDefaultView();
  public javax.swing.JRadioButtonMenuItem getRdbtnmntmPrinterFriendly();
  static javax.swing.JFrame access$000(martin.gui.GraphicalGUI);
  static javax.swing.JFileChooser access$100(martin.gui.GraphicalGUI);
  static martin.gui.quantum.Visualizer access$200(martin.gui.GraphicalGUI);
  static void access$300(martin.gui.GraphicalGUI, java.lang.Exception);
  static martin.gui.EvaluatorGUI access$400(martin.gui.GraphicalGUI);
  static javax.swing.JRadioButtonMenuItem access$500(martin.gui.GraphicalGUI);
  static javax.swing.JRadioButtonMenuItem access$600(martin.gui.GraphicalGUI);
  static martin.gui.ExperimentConductor access$700(martin.gui.GraphicalGUI);
  static martin.gui.CircuitSimulatorGUI access$800(martin.gui.GraphicalGUI);
  static javax.swing.JDialog access$900(martin.gui.GraphicalGUI);
  static javax.swing.JDialog access$1000(martin.gui.GraphicalGUI);
}
Compiled from "GraphicalGUI.java"
final class martin.gui.GraphicalGUI$1 implements java.lang.Runnable {
  martin.gui.GraphicalGUI$1();
  public void run();
}
Compiled from "GraphicalGUI.java"
class martin.gui.GraphicalGUI$10 implements java.awt.event.ActionListener {
  final martin.gui.GraphicalGUI this$0;
  martin.gui.GraphicalGUI$10(martin.gui.GraphicalGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "GraphicalGUI.java"
class martin.gui.GraphicalGUI$11 implements java.awt.event.ActionListener {
  final martin.gui.GraphicalGUI this$0;
  martin.gui.GraphicalGUI$11(martin.gui.GraphicalGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "GraphicalGUI.java"
class martin.gui.GraphicalGUI$12 implements java.awt.event.ActionListener {
  final martin.gui.GraphicalGUI this$0;
  martin.gui.GraphicalGUI$12(martin.gui.GraphicalGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "GraphicalGUI.java"
class martin.gui.GraphicalGUI$2 implements java.awt.event.ActionListener {
  final martin.gui.GraphicalGUI this$0;
  martin.gui.GraphicalGUI$2(martin.gui.GraphicalGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "GraphicalGUI.java"
class martin.gui.GraphicalGUI$3 implements java.awt.event.ActionListener {
  final martin.gui.GraphicalGUI this$0;
  martin.gui.GraphicalGUI$3(martin.gui.GraphicalGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "GraphicalGUI.java"
class martin.gui.GraphicalGUI$4 implements java.awt.event.ActionListener {
  final martin.gui.GraphicalGUI this$0;
  martin.gui.GraphicalGUI$4(martin.gui.GraphicalGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "GraphicalGUI.java"
class martin.gui.GraphicalGUI$5 implements java.awt.event.ActionListener {
  final martin.gui.GraphicalGUI this$0;
  martin.gui.GraphicalGUI$5(martin.gui.GraphicalGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "GraphicalGUI.java"
class martin.gui.GraphicalGUI$6 implements java.awt.event.ActionListener {
  final martin.gui.GraphicalGUI this$0;
  martin.gui.GraphicalGUI$6(martin.gui.GraphicalGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "GraphicalGUI.java"
class martin.gui.GraphicalGUI$7 implements java.awt.event.ActionListener {
  final martin.gui.GraphicalGUI this$0;
  martin.gui.GraphicalGUI$7(martin.gui.GraphicalGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "GraphicalGUI.java"
class martin.gui.GraphicalGUI$8 implements java.awt.event.ActionListener {
  final martin.gui.GraphicalGUI this$0;
  martin.gui.GraphicalGUI$8(martin.gui.GraphicalGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "GraphicalGUI.java"
class martin.gui.GraphicalGUI$9 implements java.awt.event.ActionListener {
  final martin.gui.GraphicalGUI this$0;
  martin.gui.GraphicalGUI$9(martin.gui.GraphicalGUI);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "LicenseDialog.java"
public class martin.gui.LicenseDialog extends javax.swing.JDialog {
  public martin.gui.LicenseDialog();
}
Compiled from "LicenseDialog.java"
class martin.gui.LicenseDialog$1 implements java.awt.event.ActionListener {
  final martin.gui.LicenseDialog this$0;
  martin.gui.LicenseDialog$1(martin.gui.LicenseDialog);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "Main.java"
public class martin.gui.Main {
  public martin.gui.Main();
  public static void main(java.lang.String[]) throws java.lang.Exception;
  public static void quantumTeleport() throws java.lang.Exception;
  public static void AltQunatumTeleport() throws java.lang.Exception;
  public static void moreComplicatedTest() throws java.lang.Exception;
}
Compiled from "MathTest.java"
public class martin.gui.MathTest {
  public martin.gui.MathTest();
  public static void main(java.lang.String[]) throws java.lang.Exception;
  static {};
}
Compiled from "MathTest2.java"
public class martin.gui.MathTest2 {
  public martin.gui.MathTest2();
  public static void main(java.lang.String[]) throws java.lang.Exception;
}
Compiled from "Arrow.java"
public class martin.gui.quantum.Arrow extends martin.gui.quantum.Item {
  public martin.gui.quantum.Arrow();
  void renderInstance(java.awt.Graphics2D, martin.gui.quantum.Visualizer);
  java.lang.String getIconFileName();
  void mouseMove(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mouseClick(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mouseDrag(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  java.awt.Cursor getCursor();
  boolean isMouseOntop(int, int);
  void mousePressed(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mouseReleased(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
}
Compiled from "Corrector.java"
public class martin.gui.quantum.Corrector extends martin.gui.quantum.Item {
  martin.gui.quantum.Qubit i1;
  martin.gui.quantum.Qubit i2;
  int[] trix;
  int[] triy;
  final martin.gui.quantum.Corrector$corrtype t;
  public boolean equals(java.lang.Object);
  public martin.gui.quantum.Corrector(martin.gui.quantum.Corrector$corrtype);
  void renderInstance(java.awt.Graphics2D, martin.gui.quantum.Visualizer);
  boolean isMouseOntop(int, int);
  public double distFromLine(double, double, double, double, double, double);
  java.lang.String getIconFileName();
  void moveWith(int, int, int, int, java.awt.Graphics2D, martin.gui.quantum.Visualizer);
  void mouseMove(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mouseClick(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mouseDrag(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mousePressed(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mouseReleased(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  java.lang.String[] getMenuEntries(martin.gui.quantum.Visualizer);
  void onMenuEntryClick(int, martin.gui.quantum.Visualizer);
  boolean doesItNeedToBeDeleted(java.util.HashSet<martin.gui.quantum.Item>);
  protected martin.gui.quantum.Item loadFromString(java.lang.String, martin.gui.quantum.Visualizer);
  protected java.lang.String saveToString();
  static {};
}
Compiled from "Corrector.java"
public final class martin.gui.quantum.Corrector$corrtype extends java.lang.Enum<martin.gui.quantum.Corrector$corrtype> {
  public static final martin.gui.quantum.Corrector$corrtype X;
  public static final martin.gui.quantum.Corrector$corrtype Z;
  public static martin.gui.quantum.Corrector$corrtype[] values();
  public static martin.gui.quantum.Corrector$corrtype valueOf(java.lang.String);
  static {};
}
Compiled from "Entangler.java"
public class martin.gui.quantum.Entangler extends martin.gui.quantum.Item {
  public static final int QUBIT_SIZE;
  martin.gui.quantum.Qubit i1;
  martin.gui.quantum.Qubit i2;
  public martin.gui.quantum.Entangler();
  public boolean equals(java.lang.Object);
  void renderInstance(java.awt.Graphics2D, martin.gui.quantum.Visualizer);
  boolean isMouseOntop(int, int);
  public double distFromLine(int, int);
  java.lang.String getIconFileName();
  void moveWith(int, int, int, int, java.awt.Graphics2D, martin.gui.quantum.Visualizer);
  void mouseMove(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mouseClick(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mouseDrag(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mousePressed(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mouseReleased(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  java.lang.String[] getMenuEntries(martin.gui.quantum.Visualizer);
  boolean doesItNeedToBeDeleted(java.util.HashSet<martin.gui.quantum.Item>);
  protected martin.gui.quantum.Item loadFromString(java.lang.String, martin.gui.quantum.Visualizer);
  protected java.lang.String saveToString();
  static {};
}
Compiled from "Inventory.java"
public class martin.gui.quantum.Inventory extends javax.swing.JToolBar {
  martin.gui.quantum.Item[] items;
  public martin.gui.quantum.Inventory(martin.gui.quantum.Item...);
  public void registerInventoryClickListener(martin.gui.quantum.Inventory$inventoryClickListener);
  public martin.gui.quantum.Item getSelectedItem();
  public void grabDefaultTool();
  static javax.swing.JToggleButton[] access$000(martin.gui.quantum.Inventory);
  static martin.gui.quantum.Item access$102(martin.gui.quantum.Inventory, martin.gui.quantum.Item);
  static martin.gui.quantum.Inventory$inventoryClickListener access$200(martin.gui.quantum.Inventory);
  static martin.gui.quantum.Item access$100(martin.gui.quantum.Inventory);
}
Compiled from "Inventory.java"
class martin.gui.quantum.Inventory$1 implements java.awt.event.ActionListener {
  final martin.gui.quantum.Item[] val$items;
  final martin.gui.quantum.Inventory this$0;
  martin.gui.quantum.Inventory$1(martin.gui.quantum.Inventory, martin.gui.quantum.Item[]);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "Inventory.java"
abstract class martin.gui.quantum.Inventory$inventoryClickListener {
  martin.gui.quantum.Inventory$inventoryClickListener();
  protected abstract void onSelected(martin.gui.quantum.Item);
}
Compiled from "Item.java"
public abstract class martin.gui.quantum.Item {
  protected java.awt.image.BufferedImage icon;
  public martin.gui.quantum.Item();
  abstract void renderInstance(java.awt.Graphics2D, martin.gui.quantum.Visualizer);
  boolean isMouseOntop(int, int);
  abstract java.lang.String getIconFileName();
  void moveWith(int, int, int, int, java.awt.Graphics2D, martin.gui.quantum.Visualizer);
  java.awt.image.BufferedImage getIcon();
  void mouseMove(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mouseClick(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mouseDrag(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mousePressed(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mouseReleased(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  java.awt.Cursor getCursor();
  java.lang.String[] getMenuEntries(martin.gui.quantum.Visualizer);
  void onMenuEntryClick(int, martin.gui.quantum.Visualizer);
  boolean doesItNeedToBeDeleted(java.util.HashSet<martin.gui.quantum.Item>);
  protected void onPostLayoutChanged(martin.gui.quantum.Visualizer);
  protected java.lang.String saveToString();
  protected martin.gui.quantum.Item loadFromString(java.lang.String, martin.gui.quantum.Visualizer);
  protected java.lang.String stringArrayToString(java.lang.String[]);
  protected java.lang.String[] stringToStringArray(java.lang.String);
  protected static martin.gui.quantum.Qubit getQubitWithId(int, martin.gui.quantum.Visualizer);
}
Compiled from "Qubit.java"
public class martin.gui.quantum.Qubit extends martin.gui.quantum.Item implements java.lang.Comparable<martin.gui.quantum.Qubit> {
  public static final int QUBIT_SIZE;
  public static final int SQUARE_AROUND_QUBIT_SIZE;
  public static final int DEFAULT_FONT_SIZE;
  java.lang.String measurement_angle;
  boolean perform_measurement;
  int x;
  int y;
  int movex;
  int movey;
  int id;
  public martin.gui.quantum.Qubit(martin.gui.quantum.Qubit$type);
  java.awt.Cursor getCursor();
  boolean isMouseOntop(int, int);
  void moveWith(int, int, int, int, java.awt.Graphics2D, martin.gui.quantum.Visualizer);
  public void renderInstance(java.awt.Graphics2D, martin.gui.quantum.Visualizer);
  public void mouseMove(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  public void mouseClick(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  public void mouseDrag(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  java.lang.String getIconFileName();
  void mousePressed(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  void mouseReleased(java.awt.Graphics2D, int, int, martin.gui.quantum.Visualizer);
  java.lang.String[] getMenuEntries(martin.gui.quantum.Visualizer);
  public martin.gui.quantum.Qubit$type getType();
  public int getId();
  public martin.gui.quantum.Qubit getHighestQubitId(martin.gui.quantum.Visualizer);
  public martin.gui.quantum.Qubit getHighestQubitLessThanMe(martin.gui.quantum.Visualizer);
  void onMenuEntryClick(int, martin.gui.quantum.Visualizer);
  protected void onPostLayoutChanged(martin.gui.quantum.Visualizer);
  public int compareTo(martin.gui.quantum.Qubit);
  public java.lang.String toString();
  protected martin.gui.quantum.Item loadFromString(java.lang.String, martin.gui.quantum.Visualizer);
  protected java.lang.String saveToString();
  public int compareTo(java.lang.Object);
  static {};
}
Compiled from "Qubit.java"
public final class martin.gui.quantum.Qubit$type extends java.lang.Enum<martin.gui.quantum.Qubit$type> {
  public static final martin.gui.quantum.Qubit$type input;
  public static final martin.gui.quantum.Qubit$type normal;
  public static martin.gui.quantum.Qubit$type[] values();
  public static martin.gui.quantum.Qubit$type valueOf(java.lang.String);
  static {};
}
Compiled from "Visualizer.java"
public class martin.gui.quantum.Visualizer extends javax.swing.JPanel {
  public static java.awt.Color background;
  public static java.awt.Color foreground;
  public static java.awt.Color fill_color;
  public static java.awt.Color grid_color;
  public java.util.ArrayList<martin.gui.quantum.Item> items;
  public java.util.ArrayList<javax.swing.JMenuItem> popup_items;
  public martin.gui.quantum.Visualizer();
  public void onMenuEntryClick(int);
  public void addItem(martin.gui.quantum.Item);
  public void setBounds(int, int, int, int);
  public void paint(java.awt.Graphics);
  public void registerInventory(martin.gui.quantum.Inventory);
  public void paint();
  public void grabDefaultTool();
  public martin.gui.quantum.Item getItemAt(int, int);
  public int showOptionDialog(java.lang.String, java.lang.String, java.lang.Object[]);
  public java.lang.String showInputDialog(java.lang.String, java.lang.String, java.lang.String);
  public <T> T[] getAllItemsOfType(T[]);
  public martin.gui.quantum.Qubit[] getQubitsDepending(martin.gui.quantum.Qubit, martin.gui.quantum.Corrector$corrtype);
  public martin.quantum.McalcDescription generateMcalcDesc() throws java.lang.Exception;
  public void saveToFile(java.io.File) throws java.lang.Exception;
  public void loadFromFile(java.io.File) throws java.lang.Exception;
  static int access$002(martin.gui.quantum.Visualizer, int);
  static int access$102(martin.gui.quantum.Visualizer, int);
  static martin.gui.quantum.Visualizer$mousestate access$202(martin.gui.quantum.Visualizer, martin.gui.quantum.Visualizer$mousestate);
  static int access$000(martin.gui.quantum.Visualizer);
  static int access$100(martin.gui.quantum.Visualizer);
  static martin.gui.quantum.Item access$302(martin.gui.quantum.Visualizer, martin.gui.quantum.Item);
  static javax.swing.JPopupMenu access$400(martin.gui.quantum.Visualizer);
  static java.lang.String[] access$500();
  static java.awt.event.ActionListener access$600(martin.gui.quantum.Visualizer);
  static martin.gui.quantum.Item access$300(martin.gui.quantum.Visualizer);
  static martin.gui.quantum.Item access$702(martin.gui.quantum.Visualizer, martin.gui.quantum.Item);
  static martin.gui.quantum.Item access$700(martin.gui.quantum.Visualizer);
  static {};
}
Compiled from "Visualizer.java"
class martin.gui.quantum.Visualizer$1 implements java.awt.event.MouseMotionListener {
  final martin.gui.quantum.Visualizer this$0;
  martin.gui.quantum.Visualizer$1(martin.gui.quantum.Visualizer);
  public void mouseMoved(java.awt.event.MouseEvent);
  public void mouseDragged(java.awt.event.MouseEvent);
}
Compiled from "Visualizer.java"
class martin.gui.quantum.Visualizer$2 implements java.awt.event.MouseListener {
  final martin.gui.quantum.Visualizer this$0;
  martin.gui.quantum.Visualizer$2(martin.gui.quantum.Visualizer);
  public void mouseReleased(java.awt.event.MouseEvent);
  public void mousePressed(java.awt.event.MouseEvent);
  public void mouseExited(java.awt.event.MouseEvent);
  public void mouseEntered(java.awt.event.MouseEvent);
  public void mouseClicked(java.awt.event.MouseEvent);
}
Compiled from "Visualizer.java"
class martin.gui.quantum.Visualizer$3 implements java.awt.event.ActionListener {
  final martin.gui.quantum.Visualizer this$0;
  martin.gui.quantum.Visualizer$3(martin.gui.quantum.Visualizer);
  public void actionPerformed(java.awt.event.ActionEvent);
}
Compiled from "Visualizer.java"
class martin.gui.quantum.Visualizer$4 extends martin.gui.quantum.Inventory$inventoryClickListener {
  final martin.gui.quantum.Visualizer this$0;
  martin.gui.quantum.Visualizer$4(martin.gui.quantum.Visualizer);
  protected void onSelected(martin.gui.quantum.Item);
}
Compiled from "Visualizer.java"
class martin.gui.quantum.Visualizer$5 {
  static final int[] $SwitchMap$martin$gui$quantum$Visualizer$mousestate;
  static {};
}
Compiled from "Visualizer.java"
final class martin.gui.quantum.Visualizer$mousestate extends java.lang.Enum<martin.gui.quantum.Visualizer$mousestate> {
  public static final martin.gui.quantum.Visualizer$mousestate moved;
  public static final martin.gui.quantum.Visualizer$mousestate dragged;
  public static final martin.gui.quantum.Visualizer$mousestate clicked;
  public static final martin.gui.quantum.Visualizer$mousestate none;
  public static final martin.gui.quantum.Visualizer$mousestate released;
  public static final martin.gui.quantum.Visualizer$mousestate pressed;
  public static martin.gui.quantum.Visualizer$mousestate[] values();
  public static martin.gui.quantum.Visualizer$mousestate valueOf(java.lang.String);
  static {};
}
Compiled from "Complex.java"
public class martin.math.Complex {
  public double R;
  public double I;
  public martin.math.Complex(double, double);
  public martin.math.Complex(java.lang.String) throws java.lang.Exception;
  public void multiply(martin.math.Complex);
  public void add(martin.math.Complex);
  public void negate();
  public boolean isZero();
  public boolean isOne();
  public martin.math.Complex clone();
  public boolean isNaN();
  public java.lang.String toString();
  public boolean equals(java.lang.Object);
  public boolean similarValue(martin.math.Complex, double);
  public double getSquare();
  public static martin.math.Complex divide(martin.math.Complex, double);
  public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
}
Compiled from "MathAutoTest.java"
public class martin.math.MathAutoTest {
  public martin.math.MathAutoTest();
  public void test();
  static {};
}
Compiled from "MathAutoTest.java"
class martin.math.MathAutoTest$1 {
  static final int[] $SwitchMap$martin$math$MathAutoTest$mathtypes;
  static {};
}
Compiled from "MathAutoTest.java"
class martin.math.MathAutoTest$Holder {
  public martin.math.MathAutoTest$Holder(martin.math.Complex, martin.math.MathsItem);
  static martin.math.MathsItem access$000(martin.math.MathAutoTest$Holder);
  static martin.math.Complex access$100(martin.math.MathAutoTest$Holder);
  static martin.math.Complex access$102(martin.math.MathAutoTest$Holder, martin.math.Complex);
  static martin.math.MathsItem access$002(martin.math.MathAutoTest$Holder, martin.math.MathsItem);
}
Compiled from "MathAutoTest.java"
final class martin.math.MathAutoTest$mathtypes extends java.lang.Enum<martin.math.MathAutoTest$mathtypes> {
  public static final martin.math.MathAutoTest$mathtypes exp;
  public static final martin.math.MathAutoTest$mathtypes fract;
  public static final martin.math.MathAutoTest$mathtypes im;
  public static final martin.math.MathAutoTest$mathtypes number;
  public static final martin.math.MathAutoTest$mathtypes sqrt;
  public static final martin.math.MathAutoTest$mathtypes symbol;
  public static martin.math.MathAutoTest$mathtypes[] values();
  public static martin.math.MathAutoTest$mathtypes valueOf(java.lang.String);
  static {};
}
Compiled from "MathExp.java"
public class martin.math.MathExp extends martin.math.MathFunction {
  public martin.math.MathExp(martin.math.MathsItem);
  public static martin.math.MathExp fromString(java.lang.String) throws java.lang.Exception;
  public boolean isZero();
  public boolean isOne();
  public martin.math.Complex getValue(java.util.HashMap<java.lang.String, martin.math.Complex>);
  public void simplify();
  public boolean multiply(martin.math.MathsItem);
  public boolean add(martin.math.MathsItem);
  public martin.math.MathsItem clone();
  public boolean divide(martin.math.MathsItem);
  public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
}
Compiled from "MathExpression.java"
public class martin.math.MathExpression implements martin.math.MathsItem {
  public static int MAX_NUMBER_OF_SIMPLIFICAITON_STEPS;
  final java.util.HashSet<java.util.HashSet<martin.math.MathsItem>> items;
  public static boolean DEEP_SIMPLIFY;
  public martin.math.MathExpression();
  public boolean hasNegativeSign();
  public void negate();
  public boolean isZero();
  public boolean isOne();
  public martin.math.Complex getValue(java.util.HashMap<java.lang.String, martin.math.Complex>);
  public void simplify();
  public boolean multiply(martin.math.MathsItem);
  public boolean add(martin.math.MathsItem);
  public martin.math.MathsItem clone();
  public java.lang.String toString();
  public static martin.math.MathExpression fromString(java.lang.String) throws java.lang.Exception;
  public void complexconjugate();
  public boolean equals(java.lang.Object);
  public boolean divide(martin.math.MathsItem);
  public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
  static {};
}
Compiled from "MathFract.java"
public class martin.math.MathFract implements martin.math.MathsItem {
  public martin.math.MathFract(martin.math.MathsItem, martin.math.MathsItem);
  public static martin.math.MathFract fromString(java.lang.String) throws java.lang.Exception;
  public boolean hasNegativeSign();
  public void negate();
  public boolean isZero();
  public boolean isOne();
  public martin.math.Complex getValue(java.util.HashMap<java.lang.String, martin.math.Complex>);
  public void simplify();
  public boolean multiply(martin.math.MathsItem);
  public boolean add(martin.math.MathsItem);
  public martin.math.MathsItem clone();
  public java.lang.String toString();
  public boolean equals(java.lang.Object);
  public boolean divide(martin.math.MathsItem);
  public void complexconjugate();
  public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
}
Compiled from "MathFunction.java"
public abstract class martin.math.MathFunction implements martin.math.MathsItem {
  protected final java.lang.String name;
  protected final martin.math.MathExpression expr;
  protected boolean negative;
  public martin.math.MathFunction(java.lang.String, martin.math.MathsItem);
  public static martin.quantum.tools.Tuple<java.lang.Boolean, martin.math.MathsItem> extractInner(java.lang.String, java.lang.String) throws java.lang.Exception;
  public boolean hasNegativeSign();
  public void negate();
  public abstract boolean isZero();
  public abstract boolean isOne();
  public abstract martin.math.Complex getValue(java.util.HashMap<java.lang.String, martin.math.Complex>);
  public abstract void simplify();
  public abstract boolean multiply(martin.math.MathsItem);
  public abstract boolean add(martin.math.MathsItem);
  public java.lang.String toString();
  public abstract martin.math.MathsItem clone();
  public boolean equals(java.lang.Object);
  public void complexconjugate();
  public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
}
Compiled from "MathIm.java"
public class martin.math.MathIm extends martin.math.MathFunction {
  public martin.math.MathIm(martin.math.MathsItem);
  public static martin.math.MathIm fromString(java.lang.String) throws java.lang.Exception;
  public boolean isZero();
  public boolean isOne();
  public martin.math.Complex getValue(java.util.HashMap<java.lang.String, martin.math.Complex>);
  public void simplify();
  public boolean multiply(martin.math.MathsItem);
  public boolean add(martin.math.MathsItem);
  public martin.math.MathsItem clone();
  public java.lang.String toString();
  public boolean equals(java.lang.Object);
  public boolean divide(martin.math.MathsItem);
  public void complexconjugate();
  public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
}
Compiled from "MathNumber.java"
public class martin.math.MathNumber implements martin.math.MathsItem {
  double number;
  public martin.math.MathNumber(double);
  public boolean hasNegativeSign();
  public boolean multiply(martin.math.MathsItem);
  public boolean add(martin.math.MathsItem);
  public void negate();
  public martin.math.MathsItem clone();
  public boolean equals(java.lang.Object);
  public java.lang.String toString();
  public boolean isZero();
  public boolean isOne();
  public boolean isInteger();
  public martin.math.Complex getValue(java.util.HashMap<java.lang.String, martin.math.Complex>);
  public void simplify();
  public static martin.math.MathNumber fromString(java.lang.String) throws java.lang.Exception;
  public boolean divide(martin.math.MathsItem);
  public void complexconjugate();
  public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
}
Compiled from "MathSqrt.java"
public class martin.math.MathSqrt extends martin.math.MathFunction {
  public martin.math.MathSqrt(martin.math.MathsItem);
  public static martin.math.MathSqrt fromString(java.lang.String) throws java.lang.Exception;
  public boolean isZero();
  public boolean isOne();
  public martin.math.Complex getValue(java.util.HashMap<java.lang.String, martin.math.Complex>);
  public void simplify();
  public boolean multiply(martin.math.MathsItem);
  public boolean add(martin.math.MathsItem);
  public martin.math.MathsItem clone();
  public boolean divide(martin.math.MathsItem);
  public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
}
Compiled from "MathSymbol.java"
public class martin.math.MathSymbol implements martin.math.MathsItem {
  public martin.math.MathSymbol(java.lang.String);
  public boolean hasNegativeSign();
  public void negate();
  public boolean isZero();
  public boolean isOne();
  public martin.math.Complex getValue(java.util.HashMap<java.lang.String, martin.math.Complex>);
  public void simplify();
  public boolean multiply(martin.math.MathsItem);
  public boolean add(martin.math.MathsItem);
  public martin.math.MathsItem clone();
  public static martin.math.MathSymbol fromString(java.lang.String) throws java.lang.Exception;
  public java.lang.String toString();
  public boolean equals(java.lang.Object);
  public boolean divide(martin.math.MathsItem);
  public void complexconjugate();
  public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
}
Compiled from "MathsItem.java"
public interface martin.math.MathsItem {
  public static final boolean DEBUG;
  public abstract boolean hasNegativeSign();
  public abstract void negate();
  public abstract void complexconjugate();
  public abstract boolean isZero();
  public abstract boolean isOne();
  public abstract martin.math.Complex getValue(java.util.HashMap<java.lang.String, martin.math.Complex>);
  public abstract martin.math.MathsItem clone();
  public abstract void simplify();
  public abstract boolean multiply(martin.math.MathsItem);
  public abstract boolean divide(martin.math.MathsItem);
  public abstract boolean add(martin.math.MathsItem);
  public abstract java.lang.String toString();
}
Compiled from "MathsParser.java"
public class martin.math.MathsParser {
  public martin.math.MathsParser();
  public static final martin.math.MathsItem parse(java.lang.String) throws java.lang.Exception;
  public static final martin.math.MathsItem[] items(java.lang.String, java.lang.String) throws java.lang.Exception;
  static {};
}
Compiled from "AddCoeffTogether.java"
public class martin.operators.AddCoeffTogether implements martin.operators.Operator {
  public martin.operators.AddCoeffTogether();
  public void operate(martin.quantum.SystemMatrix) throws java.lang.Exception;
  public java.lang.String toString();
}
Compiled from "E.java"
public class martin.operators.E implements martin.operators.Operator {
  public martin.operators.E(int, int);
  public void operate(martin.quantum.SystemMatrix) throws java.lang.Exception;
  public java.lang.String toString();
  static {};
}
Compiled from "I.java"
public class martin.operators.I implements martin.operators.Operator {
  public martin.operators.I(martin.math.MathsItem...) throws java.lang.Exception;
  public void operate(martin.quantum.SystemMatrix) throws java.lang.Exception;
  public java.lang.String toString();
  static {};
}
Compiled from "M.java"
public class martin.operators.M implements martin.operators.Operator {
  protected static final martin.math.MathsItem MINUS_ONE;
  protected static final martin.math.MathsItem ONE_OVER_SQRT_2;
  protected final int t;
  protected final int s;
  protected final int qubitId;
  protected final int b;
  protected final martin.math.MathsItem alpha;
  public martin.operators.M(int, int, int, martin.math.MathsItem, int);
  public void operate(martin.quantum.SystemMatrix) throws java.lang.Exception;
  protected void perform(int, martin.quantum.SystemMatrix);
  public java.lang.String toString();
  static {};
}
Compiled from "N.java"
public class martin.operators.N implements martin.operators.Operator {
  public martin.operators.N(int);
  public martin.operators.N(int, martin.math.MathsItem, martin.math.MathsItem);
  public void operate(martin.quantum.SystemMatrix) throws java.lang.Exception;
  public java.lang.String toString();
}
Compiled from "Operator.java"
public interface martin.operators.Operator {
  public abstract void operate(martin.quantum.SystemMatrix) throws java.lang.Exception;
}
Compiled from "X.java"
public class martin.operators.X implements martin.operators.Operator {
  final int qubitId;
  final boolean skip;
  public martin.operators.X(int, int);
  public martin.operators.X(int);
  public void operate(martin.quantum.SystemMatrix) throws java.lang.Exception;
  public java.lang.String toString();
}
Compiled from "Z.java"
public class martin.operators.Z implements martin.operators.Operator {
  final int qubitId;
  final boolean skip;
  public martin.operators.Z(int, int);
  public martin.operators.Z(int);
  public void operate(martin.quantum.SystemMatrix) throws java.lang.Exception;
  public java.lang.String toString();
  static {};
}
Compiled from "ZM.java"
public class martin.operators.ZM extends martin.operators.M {
  protected static final martin.math.MathsItem ZERO;
  public martin.operators.ZM(int, int, int, int);
  protected void perform(int, martin.quantum.SystemMatrix);
  public java.lang.String toString();
  static {};
}
Compiled from "McalcDescription.java"
public class martin.quantum.McalcDescription {
  public int n;
  public java.lang.String inputs;
  public java.lang.String entanglement;
  public java.lang.String measurements;
  public java.lang.String corrections;
  public java.lang.String branches;
  public java.lang.String variables;
  public martin.quantum.McalcDescription();
  public martin.quantum.McalcDescription(int, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String);
  public martin.quantum.McalcDescription(int, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String);
  public martin.quantum.McalcDescription(java.io.File) throws java.lang.Exception;
  public void loadFromFile(java.io.File) throws java.lang.Exception;
  public void loadFromFile(java.lang.String) throws java.lang.Exception;
  public void saveToFile(java.io.File) throws java.lang.Exception;
  public void saveToFile(java.lang.String) throws java.lang.Exception;
  public java.lang.String toString();
}
Compiled from "SimulationRunner.java"
public final class martin.quantum.SimulationRunner {
  public martin.quantum.SimulationRunner();
  public static martin.quantum.SystemMatrix run(martin.quantum.McalcDescription) throws java.lang.Exception;
  public static java.util.HashMap<java.lang.String, martin.math.Complex> parseVariablesAndValues(java.lang.String) throws java.lang.Exception;
}
Compiled from "SystemMatrix.java"
public class martin.quantum.SystemMatrix {
  public final int mNumbQubits;
  public martin.math.MathsItem[] coeff;
  public final boolean[] measured;
  public final int size;
  public martin.quantum.SystemMatrix(martin.math.MathsItem[]) throws java.lang.Exception;
  public martin.quantum.SystemMatrix(int);
  protected java.lang.Object clone() throws java.lang.CloneNotSupportedException;
  public void setCoeff(martin.math.MathsItem, int...) throws java.lang.Exception;
  public martin.math.MathsItem getCoeff(int...) throws java.lang.Exception;
  public int getIdFromIndexes(int...) throws java.lang.Exception;
  public static int[] getIndexesFromId(int, int);
  public java.lang.String toString();
  public java.lang.String getBraKet(int);
  public static java.lang.String getBraKet(int, int);
  public java.lang.String printValues(java.util.HashMap<java.lang.String, martin.math.Complex>, boolean);
  public void performReverse(martin.operators.Operator...) throws java.lang.Exception;
  public void perform(martin.operators.Operator...) throws java.lang.Exception;
  public double getQuickProbability(java.util.HashMap<java.lang.String, martin.math.Complex>);
  public void simplify();
}
Compiled from "Tools.java"
public final class martin.quantum.tools.Tools {
  public static java.io.PrintStream logger;
  public static final boolean FORCE_SYSTEM_LOGGER;
  public static boolean SIMPLIFICATION_ENABLED;
  public static boolean VERBOSE;
  public static boolean SILENT;
  public static boolean MATHEMATICA_FRIENDLY_OUTPUT;
  public martin.quantum.tools.Tools();
  public static java.lang.String trimAndCheckBrackets(java.lang.String) throws java.lang.Exception;
  public static boolean balancedBrackets(java.lang.String);
  public static java.util.ArrayList<martin.quantum.tools.Tuple<char[], java.lang.String>> splitByTopLevel(java.lang.String, char[], boolean) throws java.lang.Exception;
  public static void printTuples(java.util.ArrayList<martin.quantum.tools.Tuple<char[], java.lang.String>>);
  public static java.util.HashMap<java.lang.String, martin.math.Complex> generatePairs(java.lang.String[], martin.math.Complex[]);
  public static final int zBOB(int);
  public static final int oBZB(int);
  public static int powerOfTwo(int) throws java.lang.Exception;
  static {};
}
Compiled from "Tuple.java"
public class martin.quantum.tools.Tuple<X, Y> {
  public final X x;
  public final Y y;
  public martin.quantum.tools.Tuple(X, Y);
  public java.lang.String toString();
}
Compiled from "QCGate.java"
public class martin.translatortest.QCGate {
  public int q1;
  public int q2;
  public martin.translatortest.QCGate$type t;
  public martin.translatortest.QCGate(martin.translatortest.QCGate$type, int, int);
  public martin.translatortest.QCGate(martin.translatortest.QCGate$type, int);
  public java.lang.String toString();
  public static java.lang.String printWebCicuit(martin.translatortest.QCGate...);
  public static java.lang.String printEinarCicuit(martin.translatortest.QCGate...);
  public static martin.quantum.McalcDescription translateToMBQCRaw(java.lang.String, martin.translatortest.QCGate...) throws java.lang.Exception;
  public static martin.translatortest.QCGate[] generateCircuitFromEinar(java.lang.String) throws java.lang.Exception;
}
Compiled from "QCGate.java"
class martin.translatortest.QCGate$1 {
  static final int[] $SwitchMap$martin$translatortest$QCGate$type;
  static {};
}
Compiled from "QCGate.java"
public final class martin.translatortest.QCGate$type extends java.lang.Enum<martin.translatortest.QCGate$type> {
  public static final martin.translatortest.QCGate$type H;
  public static final martin.translatortest.QCGate$type ZZ;
  public static final martin.translatortest.QCGate$type JPI;
  public static final martin.translatortest.QCGate$type JPI2;
  public static final martin.translatortest.QCGate$type JPI4;
  public static final martin.translatortest.QCGate$type JPI8;
  public static martin.translatortest.QCGate$type[] values();
  public static martin.translatortest.QCGate$type valueOf(java.lang.String);
  static {};
}
Compiled from "TranslatorRunner.java"
public class martin.translatortest.TranslatorRunner {
  public martin.translatortest.TranslatorRunner();
  public static java.lang.String[] runTestFromString(java.lang.String, java.lang.String) throws java.lang.Exception;
  public static java.lang.String generateRandomCircuitDesc();
  static {};
}
Compiled from "TranslatorRunner.java"
class martin.translatortest.TranslatorRunner$1 {
  static final int[] $SwitchMap$martin$translatortest$QCGate$type;
  static {};
}
